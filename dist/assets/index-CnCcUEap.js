const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/AboutView-CgIs-Ii5.js","assets/AboutView-C6Dx7pxG.css"])))=>i.map(i=>d[i]);
(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const a of document.querySelectorAll('link[rel="modulepreload"]'))o(a);new MutationObserver(a=>{for(const l of a)if(l.type==="childList")for(const m of l.addedNodes)m.tagName==="LINK"&&m.rel==="modulepreload"&&o(m)}).observe(document,{childList:!0,subtree:!0});function i(a){const l={};return a.integrity&&(l.integrity=a.integrity),a.referrerPolicy&&(l.referrerPolicy=a.referrerPolicy),a.crossOrigin==="use-credentials"?l.credentials="include":a.crossOrigin==="anonymous"?l.credentials="omit":l.credentials="same-origin",l}function o(a){if(a.ep)return;a.ep=!0;const l=i(a);fetch(a.href,l)}})();/**
* @vue/shared v3.5.9
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**//*! #__NO_SIDE_EFFECTS__ */function Vi(e){const t=Object.create(null);for(const i of e.split(","))t[i]=1;return i=>i in t}const de={},qt=[],ot=()=>{},ka=()=>!1,Dn=e=>e.charCodeAt(0)===111&&e.charCodeAt(1)===110&&(e.charCodeAt(2)>122||e.charCodeAt(2)<97),ki=e=>e.startsWith("onUpdate:"),$e=Object.assign,ji=(e,t)=>{const i=e.indexOf(t);i>-1&&e.splice(i,1)},ja=Object.prototype.hasOwnProperty,ae=(e,t)=>ja.call(e,t),Z=Array.isArray,Bt=e=>Ln(e)==="[object Map]",ro=e=>Ln(e)==="[object Set]",ne=e=>typeof e=="function",Se=e=>typeof e=="string",At=e=>typeof e=="symbol",ye=e=>e!==null&&typeof e=="object",lo=e=>(ye(e)||ne(e))&&ne(e.then)&&ne(e.catch),co=Object.prototype.toString,Ln=e=>co.call(e),Da=e=>Ln(e).slice(8,-1),uo=e=>Ln(e)==="[object Object]",Di=e=>Se(e)&&e!=="NaN"&&e[0]!=="-"&&""+parseInt(e,10)===e,Zt=Vi(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"),On=e=>{const t=Object.create(null);return i=>t[i]||(t[i]=e(i))},La=/-(\w)/g,Et=On(e=>e.replace(La,(t,i)=>i?i.toUpperCase():"")),Oa=/\B([A-Z])/g,Vt=On(e=>e.replace(Oa,"-$1").toLowerCase()),ho=On(e=>e.charAt(0).toUpperCase()+e.slice(1)),Zn=On(e=>e?`on${ho(e)}`:""),Mt=(e,t)=>!Object.is(e,t),Pn=(e,...t)=>{for(let i=0;i<e.length;i++)e[i](...t)},fo=(e,t,i,o=!1)=>{Object.defineProperty(e,t,{configurable:!0,enumerable:!1,writable:o,value:i})},gi=e=>{const t=parseFloat(e);return isNaN(t)?e:t};let cs;const po=()=>cs||(cs=typeof globalThis<"u"?globalThis:typeof self<"u"?self:typeof window<"u"?window:typeof global<"u"?global:{});function Li(e){if(Z(e)){const t={};for(let i=0;i<e.length;i++){const o=e[i],a=Se(o)?Ha(o):Li(o);if(a)for(const l in a)t[l]=a[l]}return t}else if(Se(e)||ye(e))return e}const za=/;(?![^(]*\))/g,qa=/:([^]+)/,Ba=/\/\*[^]*?\*\//g;function Ha(e){const t={};return e.replace(Ba,"").split(za).forEach(i=>{if(i){const o=i.split(qa);o.length>1&&(t[o[0].trim()]=o[1].trim())}}),t}function zn(e){let t="";if(Se(e))t=e;else if(Z(e))for(let i=0;i<e.length;i++){const o=zn(e[i]);o&&(t+=o+" ")}else if(ye(e))for(const i in e)e[i]&&(t+=i+" ");return t.trim()}const Wa="itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly",Ua=Vi(Wa);function go(e){return!!e||e===""}const mo=e=>!!(e&&e.__v_isRef===!0),Ne=e=>Se(e)?e:e==null?"":Z(e)||ye(e)&&(e.toString===co||!ne(e.toString))?mo(e)?Ne(e.value):JSON.stringify(e,xo,2):String(e),xo=(e,t)=>mo(t)?xo(e,t.value):Bt(t)?{[`Map(${t.size})`]:[...t.entries()].reduce((i,[o,a],l)=>(i[ei(o,l)+" =>"]=a,i),{})}:ro(t)?{[`Set(${t.size})`]:[...t.values()].map(i=>ei(i))}:At(t)?ei(t):ye(t)&&!Z(t)&&!uo(t)?String(t):t,ei=(e,t="")=>{var i;return At(e)?`Symbol(${(i=e.description)!=null?i:t})`:e};/**
* @vue/reactivity v3.5.9
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/let ke;class yo{constructor(t=!1){this.detached=t,this._active=!0,this.effects=[],this.cleanups=[],this._isPaused=!1,this.parent=ke,!t&&ke&&(this.index=(ke.scopes||(ke.scopes=[])).push(this)-1)}get active(){return this._active}pause(){if(this._active){this._isPaused=!0;let t,i;if(this.scopes)for(t=0,i=this.scopes.length;t<i;t++)this.scopes[t].pause();for(t=0,i=this.effects.length;t<i;t++)this.effects[t].pause()}}resume(){if(this._active&&this._isPaused){this._isPaused=!1;let t,i;if(this.scopes)for(t=0,i=this.scopes.length;t<i;t++)this.scopes[t].resume();for(t=0,i=this.effects.length;t<i;t++)this.effects[t].resume()}}run(t){if(this._active){const i=ke;try{return ke=this,t()}finally{ke=i}}}on(){ke=this}off(){ke=this.parent}stop(t){if(this._active){let i,o;for(i=0,o=this.effects.length;i<o;i++)this.effects[i].stop();for(i=0,o=this.cleanups.length;i<o;i++)this.cleanups[i]();if(this.scopes)for(i=0,o=this.scopes.length;i<o;i++)this.scopes[i].stop(!0);if(!this.detached&&this.parent&&!t){const a=this.parent.scopes.pop();a&&a!==this&&(this.parent.scopes[this.index]=a,a.index=this.index)}this.parent=void 0,this._active=!1}}}function vo(e){return new yo(e)}function bo(){return ke}function Na(e,t=!1){ke&&ke.cleanups.push(e)}let ge;const ti=new WeakSet;class wo{constructor(t){this.fn=t,this.deps=void 0,this.depsTail=void 0,this.flags=5,this.next=void 0,this.cleanup=void 0,this.scheduler=void 0,ke&&ke.active&&ke.effects.push(this)}pause(){this.flags|=64}resume(){this.flags&64&&(this.flags&=-65,ti.has(this)&&(ti.delete(this),this.trigger()))}notify(){this.flags&2&&!(this.flags&32)||this.flags&8||Ao(this)}run(){if(!(this.flags&1))return this.fn();this.flags|=2,us(this),So(this);const t=ge,i=Je;ge=this,Je=!0;try{return this.fn()}finally{Po(this),ge=t,Je=i,this.flags&=-3}}stop(){if(this.flags&1){for(let t=this.deps;t;t=t.nextDep)qi(t);this.deps=this.depsTail=void 0,us(this),this.onStop&&this.onStop(),this.flags&=-2}}trigger(){this.flags&64?ti.add(this):this.scheduler?this.scheduler():this.runIfDirty()}runIfDirty(){mi(this)&&this.run()}get dirty(){return mi(this)}}let Mo=0,zt;function Ao(e){e.flags|=8,e.next=zt,zt=e}function Oi(){Mo++}function zi(){if(--Mo>0)return;let e;for(;zt;){let t=zt,i;for(;t;)t.flags&=-9,t=t.next;for(t=zt,zt=void 0;t;){if(t.flags&1)try{t.trigger()}catch(o){e||(e=o)}i=t.next,t.next=void 0,t=i}}if(e)throw e}function So(e){for(let t=e.deps;t;t=t.nextDep)t.version=-1,t.prevActiveLink=t.dep.activeLink,t.dep.activeLink=t}function Po(e){let t,i=e.depsTail,o=i;for(;o;){const a=o.prevDep;o.version===-1?(o===i&&(i=a),qi(o),Ya(o)):t=o,o.dep.activeLink=o.prevActiveLink,o.prevActiveLink=void 0,o=a}e.deps=t,e.depsTail=i}function mi(e){for(let t=e.deps;t;t=t.nextDep)if(t.dep.version!==t.version||t.dep.computed&&(To(t.dep.computed)||t.dep.version!==t.version))return!0;return!!e._dirty}function To(e){if(e.flags&4&&!(e.flags&16)||(e.flags&=-17,e.globalVersion===rn))return;e.globalVersion=rn;const t=e.dep;if(e.flags|=2,t.version>0&&!e.isSSR&&e.deps&&!mi(e)){e.flags&=-3;return}const i=ge,o=Je;ge=e,Je=!0;try{So(e);const a=e.fn(e._value);(t.version===0||Mt(a,e._value))&&(e._value=a,t.version++)}catch(a){throw t.version++,a}finally{ge=i,Je=o,Po(e),e.flags&=-3}}function qi(e,t=!1){const{dep:i,prevSub:o,nextSub:a}=e;if(o&&(o.nextSub=a,e.prevSub=void 0),a&&(a.prevSub=o,e.nextSub=void 0),i.subs===e&&(i.subs=o),!i.subs&&i.computed){i.computed.flags&=-5;for(let l=i.computed.deps;l;l=l.nextDep)qi(l,!0)}!t&&!--i.sc&&i.map&&i.map.delete(i.key)}function Ya(e){const{prevDep:t,nextDep:i}=e;t&&(t.nextDep=i,e.prevDep=void 0),i&&(i.prevDep=t,e.nextDep=void 0)}let Je=!0;const $o=[];function St(){$o.push(Je),Je=!1}function Pt(){const e=$o.pop();Je=e===void 0?!0:e}function us(e){const{cleanup:t}=e;if(e.cleanup=void 0,t){const i=ge;ge=void 0;try{t()}finally{ge=i}}}let rn=0;class Xa{constructor(t,i){this.sub=t,this.dep=i,this.version=i.version,this.nextDep=this.prevDep=this.nextSub=this.prevSub=this.prevActiveLink=void 0}}class Bi{constructor(t){this.computed=t,this.version=0,this.activeLink=void 0,this.subs=void 0,this.target=void 0,this.map=void 0,this.key=void 0,this.sc=0}track(t){if(!ge||!Je||ge===this.computed)return;let i=this.activeLink;if(i===void 0||i.sub!==ge)i=this.activeLink=new Xa(ge,this),ge.deps?(i.prevDep=ge.depsTail,ge.depsTail.nextDep=i,ge.depsTail=i):ge.deps=ge.depsTail=i,Fo(i);else if(i.version===-1&&(i.version=this.version,i.nextDep)){const o=i.nextDep;o.prevDep=i.prevDep,i.prevDep&&(i.prevDep.nextDep=o),i.prevDep=ge.depsTail,i.nextDep=void 0,ge.depsTail.nextDep=i,ge.depsTail=i,ge.deps===i&&(ge.deps=o)}return i}trigger(t){this.version++,rn++,this.notify(t)}notify(t){Oi();try{for(let i=this.subs;i;i=i.prevSub)i.sub.notify()&&i.sub.dep.notify()}finally{zi()}}}function Fo(e){if(e.dep.sc++,e.sub.flags&4){const t=e.dep.computed;if(t&&!e.dep.subs){t.flags|=20;for(let o=t.deps;o;o=o.nextDep)Fo(o)}const i=e.dep.subs;i!==e&&(e.prevSub=i,i&&(i.nextSub=e)),e.dep.subs=e}}const Cn=new WeakMap,_t=Symbol(""),xi=Symbol(""),ln=Symbol("");function Ie(e,t,i){if(Je&&ge){let o=Cn.get(e);o||Cn.set(e,o=new Map);let a=o.get(i);a||(o.set(i,a=new Bi),a.target=e,a.map=o,a.key=i),a.track()}}function ft(e,t,i,o,a,l){const m=Cn.get(e);if(!m){rn++;return}const v=y=>{y&&y.trigger()};if(Oi(),t==="clear")m.forEach(v);else{const y=Z(e),M=y&&Di(i);if(y&&i==="length"){const S=Number(o);m.forEach(($,x)=>{(x==="length"||x===ln||!At(x)&&x>=S)&&v($)})}else switch(i!==void 0&&v(m.get(i)),M&&v(m.get(ln)),t){case"add":y?M&&v(m.get("length")):(v(m.get(_t)),Bt(e)&&v(m.get(xi)));break;case"delete":y||(v(m.get(_t)),Bt(e)&&v(m.get(xi)));break;case"set":Bt(e)&&v(m.get(_t));break}}zi()}function Ka(e,t){const i=Cn.get(e);return i&&i.get(t)}function kt(e){const t=oe(e);return t===e?t:(Ie(t,"iterate",ln),Ke(e)?t:t.map(Ee))}function qn(e){return Ie(e=oe(e),"iterate",ln),e}const Ga={__proto__:null,[Symbol.iterator](){return ni(this,Symbol.iterator,Ee)},concat(...e){return kt(this).concat(...e.map(t=>Z(t)?kt(t):t))},entries(){return ni(this,"entries",e=>(e[1]=Ee(e[1]),e))},every(e,t){return lt(this,"every",e,t,void 0,arguments)},filter(e,t){return lt(this,"filter",e,t,i=>i.map(Ee),arguments)},find(e,t){return lt(this,"find",e,t,Ee,arguments)},findIndex(e,t){return lt(this,"findIndex",e,t,void 0,arguments)},findLast(e,t){return lt(this,"findLast",e,t,Ee,arguments)},findLastIndex(e,t){return lt(this,"findLastIndex",e,t,void 0,arguments)},forEach(e,t){return lt(this,"forEach",e,t,void 0,arguments)},includes(...e){return ii(this,"includes",e)},indexOf(...e){return ii(this,"indexOf",e)},join(e){return kt(this).join(e)},lastIndexOf(...e){return ii(this,"lastIndexOf",e)},map(e,t){return lt(this,"map",e,t,void 0,arguments)},pop(){return Kt(this,"pop")},push(...e){return Kt(this,"push",e)},reduce(e,...t){return hs(this,"reduce",e,t)},reduceRight(e,...t){return hs(this,"reduceRight",e,t)},shift(){return Kt(this,"shift")},some(e,t){return lt(this,"some",e,t,void 0,arguments)},splice(...e){return Kt(this,"splice",e)},toReversed(){return kt(this).toReversed()},toSorted(e){return kt(this).toSorted(e)},toSpliced(...e){return kt(this).toSpliced(...e)},unshift(...e){return Kt(this,"unshift",e)},values(){return ni(this,"values",Ee)}};function ni(e,t,i){const o=qn(e),a=o[t]();return o!==e&&!Ke(e)&&(a._next=a.next,a.next=()=>{const l=a._next();return l.value&&(l.value=i(l.value)),l}),a}const Qa=Array.prototype;function lt(e,t,i,o,a,l){const m=qn(e),v=m!==e&&!Ke(e),y=m[t];if(y!==Qa[t]){const $=y.apply(e,l);return v?Ee($):$}let M=i;m!==e&&(v?M=function($,x){return i.call(this,Ee($),x,e)}:i.length>2&&(M=function($,x){return i.call(this,$,x,e)}));const S=y.call(m,M,o);return v&&a?a(S):S}function hs(e,t,i,o){const a=qn(e);let l=i;return a!==e&&(Ke(e)?i.length>3&&(l=function(m,v,y){return i.call(this,m,v,y,e)}):l=function(m,v,y){return i.call(this,m,Ee(v),y,e)}),a[t](l,...o)}function ii(e,t,i){const o=oe(e);Ie(o,"iterate",ln);const a=o[t](...i);return(a===-1||a===!1)&&Ni(i[0])?(i[0]=oe(i[0]),o[t](...i)):a}function Kt(e,t,i=[]){St(),Oi();const o=oe(e)[t].apply(e,i);return zi(),Pt(),o}const Ja=Vi("__proto__,__v_isRef,__isVue"),_o=new Set(Object.getOwnPropertyNames(Symbol).filter(e=>e!=="arguments"&&e!=="caller").map(e=>Symbol[e]).filter(At));function Za(e){At(e)||(e=String(e));const t=oe(this);return Ie(t,"has",e),t.hasOwnProperty(e)}class Co{constructor(t=!1,i=!1){this._isReadonly=t,this._isShallow=i}get(t,i,o){const a=this._isReadonly,l=this._isShallow;if(i==="__v_isReactive")return!a;if(i==="__v_isReadonly")return a;if(i==="__v_isShallow")return l;if(i==="__v_raw")return o===(a?l?fr:Vo:l?Io:Ro).get(t)||Object.getPrototypeOf(t)===Object.getPrototypeOf(o)?t:void 0;const m=Z(t);if(!a){let y;if(m&&(y=Ga[i]))return y;if(i==="hasOwnProperty")return Za}const v=Reflect.get(t,i,we(t)?t:o);return(At(i)?_o.has(i):Ja(i))||(a||Ie(t,"get",i),l)?v:we(v)?m&&Di(i)?v:v.value:ye(v)?a?jo(v):gn(v):v}}class Eo extends Co{constructor(t=!1){super(!1,t)}set(t,i,o,a){let l=t[i];if(!this._isShallow){const y=Rt(l);if(!Ke(o)&&!Rt(o)&&(l=oe(l),o=oe(o)),!Z(t)&&we(l)&&!we(o))return y?!1:(l.value=o,!0)}const m=Z(t)&&Di(i)?Number(i)<t.length:ae(t,i),v=Reflect.set(t,i,o,we(t)?t:a);return t===oe(a)&&(m?Mt(o,l)&&ft(t,"set",i,o):ft(t,"add",i,o)),v}deleteProperty(t,i){const o=ae(t,i);t[i];const a=Reflect.deleteProperty(t,i);return a&&o&&ft(t,"delete",i,void 0),a}has(t,i){const o=Reflect.has(t,i);return(!At(i)||!_o.has(i))&&Ie(t,"has",i),o}ownKeys(t){return Ie(t,"iterate",Z(t)?"length":_t),Reflect.ownKeys(t)}}class er extends Co{constructor(t=!1){super(!0,t)}set(t,i){return!0}deleteProperty(t,i){return!0}}const tr=new Eo,nr=new er,ir=new Eo(!0);const Hi=e=>e,Bn=e=>Reflect.getPrototypeOf(e);function yn(e,t,i=!1,o=!1){e=e.__v_raw;const a=oe(e),l=oe(t);i||(Mt(t,l)&&Ie(a,"get",t),Ie(a,"get",l));const{has:m}=Bn(a),v=o?Hi:i?Xi:Ee;if(m.call(a,t))return v(e.get(t));if(m.call(a,l))return v(e.get(l));e!==a&&e.get(t)}function vn(e,t=!1){const i=this.__v_raw,o=oe(i),a=oe(e);return t||(Mt(e,a)&&Ie(o,"has",e),Ie(o,"has",a)),e===a?i.has(e):i.has(e)||i.has(a)}function bn(e,t=!1){return e=e.__v_raw,!t&&Ie(oe(e),"iterate",_t),Reflect.get(e,"size",e)}function fs(e,t=!1){!t&&!Ke(e)&&!Rt(e)&&(e=oe(e));const i=oe(this);return Bn(i).has.call(i,e)||(i.add(e),ft(i,"add",e,e)),this}function ds(e,t,i=!1){!i&&!Ke(t)&&!Rt(t)&&(t=oe(t));const o=oe(this),{has:a,get:l}=Bn(o);let m=a.call(o,e);m||(e=oe(e),m=a.call(o,e));const v=l.call(o,e);return o.set(e,t),m?Mt(t,v)&&ft(o,"set",e,t):ft(o,"add",e,t),this}function ps(e){const t=oe(this),{has:i,get:o}=Bn(t);let a=i.call(t,e);a||(e=oe(e),a=i.call(t,e)),o&&o.call(t,e);const l=t.delete(e);return a&&ft(t,"delete",e,void 0),l}function gs(){const e=oe(this),t=e.size!==0,i=e.clear();return t&&ft(e,"clear",void 0,void 0),i}function wn(e,t){return function(o,a){const l=this,m=l.__v_raw,v=oe(m),y=t?Hi:e?Xi:Ee;return!e&&Ie(v,"iterate",_t),m.forEach((M,S)=>o.call(a,y(M),y(S),l))}}function Mn(e,t,i){return function(...o){const a=this.__v_raw,l=oe(a),m=Bt(l),v=e==="entries"||e===Symbol.iterator&&m,y=e==="keys"&&m,M=a[e](...o),S=i?Hi:t?Xi:Ee;return!t&&Ie(l,"iterate",y?xi:_t),{next(){const{value:$,done:x}=M.next();return x?{value:$,done:x}:{value:v?[S($[0]),S($[1])]:S($),done:x}},[Symbol.iterator](){return this}}}}function gt(e){return function(...t){return e==="delete"?!1:e==="clear"?void 0:this}}function sr(){const e={get(l){return yn(this,l)},get size(){return bn(this)},has:vn,add:fs,set:ds,delete:ps,clear:gs,forEach:wn(!1,!1)},t={get(l){return yn(this,l,!1,!0)},get size(){return bn(this)},has:vn,add(l){return fs.call(this,l,!0)},set(l,m){return ds.call(this,l,m,!0)},delete:ps,clear:gs,forEach:wn(!1,!0)},i={get(l){return yn(this,l,!0)},get size(){return bn(this,!0)},has(l){return vn.call(this,l,!0)},add:gt("add"),set:gt("set"),delete:gt("delete"),clear:gt("clear"),forEach:wn(!0,!1)},o={get(l){return yn(this,l,!0,!0)},get size(){return bn(this,!0)},has(l){return vn.call(this,l,!0)},add:gt("add"),set:gt("set"),delete:gt("delete"),clear:gt("clear"),forEach:wn(!0,!0)};return["keys","values","entries",Symbol.iterator].forEach(l=>{e[l]=Mn(l,!1,!1),i[l]=Mn(l,!0,!1),t[l]=Mn(l,!1,!0),o[l]=Mn(l,!0,!0)}),[e,i,t,o]}const[or,ar,rr,lr]=sr();function Wi(e,t){const i=t?e?lr:rr:e?ar:or;return(o,a,l)=>a==="__v_isReactive"?!e:a==="__v_isReadonly"?e:a==="__v_raw"?o:Reflect.get(ae(i,a)&&a in o?i:o,a,l)}const cr={get:Wi(!1,!1)},ur={get:Wi(!1,!0)},hr={get:Wi(!0,!1)};const Ro=new WeakMap,Io=new WeakMap,Vo=new WeakMap,fr=new WeakMap;function dr(e){switch(e){case"Object":case"Array":return 1;case"Map":case"Set":case"WeakMap":case"WeakSet":return 2;default:return 0}}function pr(e){return e.__v_skip||!Object.isExtensible(e)?0:dr(Da(e))}function gn(e){return Rt(e)?e:Ui(e,!1,tr,cr,Ro)}function ko(e){return Ui(e,!1,ir,ur,Io)}function jo(e){return Ui(e,!0,nr,hr,Vo)}function Ui(e,t,i,o,a){if(!ye(e)||e.__v_raw&&!(t&&e.__v_isReactive))return e;const l=a.get(e);if(l)return l;const m=pr(e);if(m===0)return e;const v=new Proxy(e,m===2?o:i);return a.set(e,v),v}function wt(e){return Rt(e)?wt(e.__v_raw):!!(e&&e.__v_isReactive)}function Rt(e){return!!(e&&e.__v_isReadonly)}function Ke(e){return!!(e&&e.__v_isShallow)}function Ni(e){return e?!!e.__v_raw:!1}function oe(e){const t=e&&e.__v_raw;return t?oe(t):e}function Yi(e){return!ae(e,"__v_skip")&&Object.isExtensible(e)&&fo(e,"__v_skip",!0),e}const Ee=e=>ye(e)?gn(e):e,Xi=e=>ye(e)?jo(e):e;function we(e){return e?e.__v_isRef===!0:!1}function at(e){return Do(e,!1)}function gr(e){return Do(e,!0)}function Do(e,t){return we(e)?e:new mr(e,t)}class mr{constructor(t,i){this.dep=new Bi,this.__v_isRef=!0,this.__v_isShallow=!1,this._rawValue=i?t:oe(t),this._value=i?t:Ee(t),this.__v_isShallow=i}get value(){return this.dep.track(),this._value}set value(t){const i=this._rawValue,o=this.__v_isShallow||Ke(t)||Rt(t);t=o?t:oe(t),Mt(t,i)&&(this._rawValue=t,this._value=o?t:Ee(t),this.dep.trigger())}}function dt(e){return we(e)?e.value:e}const xr={get:(e,t,i)=>t==="__v_raw"?e:dt(Reflect.get(e,t,i)),set:(e,t,i,o)=>{const a=e[t];return we(a)&&!we(i)?(a.value=i,!0):Reflect.set(e,t,i,o)}};function Lo(e){return wt(e)?e:new Proxy(e,xr)}function yr(e){const t=Z(e)?new Array(e.length):{};for(const i in e)t[i]=br(e,i);return t}class vr{constructor(t,i,o){this._object=t,this._key=i,this._defaultValue=o,this.__v_isRef=!0,this._value=void 0}get value(){const t=this._object[this._key];return this._value=t===void 0?this._defaultValue:t}set value(t){this._object[this._key]=t}get dep(){return Ka(oe(this._object),this._key)}}function br(e,t,i){const o=e[t];return we(o)?o:new vr(e,t,i)}class wr{constructor(t,i,o){this.fn=t,this.setter=i,this._value=void 0,this.dep=new Bi(this),this.__v_isRef=!0,this.deps=void 0,this.depsTail=void 0,this.flags=16,this.globalVersion=rn-1,this.effect=this,this.__v_isReadonly=!i,this.isSSR=o}notify(){if(this.flags|=16,!(this.flags&8)&&ge!==this)return Ao(this),!0}get value(){const t=this.dep.track();return To(this),t&&(t.version=this.dep.version),this._value}set value(t){this.setter&&this.setter(t)}}function Mr(e,t,i=!1){let o,a;return ne(e)?o=e:(o=e.get,a=e.set),new wr(o,a,i)}const An={},En=new WeakMap;let Ft;function Ar(e,t=!1,i=Ft){if(i){let o=En.get(i);o||En.set(i,o=[]),o.push(e)}}function Sr(e,t,i=de){const{immediate:o,deep:a,once:l,scheduler:m,augmentJob:v,call:y}=i,M=r=>a?r:Ke(r)||a===!1||a===0?ht(r,1):ht(r);let S,$,x,s,n=!1,f=!1;if(we(e)?($=()=>e.value,n=Ke(e)):wt(e)?($=()=>M(e),n=!0):Z(e)?(f=!0,n=e.some(r=>wt(r)||Ke(r)),$=()=>e.map(r=>{if(we(r))return r.value;if(wt(r))return M(r);if(ne(r))return y?y(r,2):r()})):ne(e)?t?$=y?()=>y(e,2):e:$=()=>{if(x){St();try{x()}finally{Pt()}}const r=Ft;Ft=S;try{return y?y(e,3,[s]):e(s)}finally{Ft=r}}:$=ot,t&&a){const r=$,p=a===!0?1/0:a;$=()=>ht(r(),p)}const d=bo(),h=()=>{S.stop(),d&&ji(d.effects,S)};if(l&&t){const r=t;t=(...p)=>{r(...p),h()}}let u=f?new Array(e.length).fill(An):An;const c=r=>{if(!(!(S.flags&1)||!S.dirty&&!r))if(t){const p=S.run();if(a||n||(f?p.some((F,b)=>Mt(F,u[b])):Mt(p,u))){x&&x();const F=Ft;Ft=S;try{const b=[p,u===An?void 0:f&&u[0]===An?[]:u,s];y?y(t,3,b):t(...b),u=p}finally{Ft=F}}}else S.run()};return v&&v(c),S=new wo($),S.scheduler=m?()=>m(c,!1):c,s=r=>Ar(r,!1,S),x=S.onStop=()=>{const r=En.get(S);if(r){if(y)y(r,4);else for(const p of r)p();En.delete(S)}},t?o?c(!0):u=S.run():m?m(c.bind(null,!0),!0):S.run(),h.pause=S.pause.bind(S),h.resume=S.resume.bind(S),h.stop=h,h}function ht(e,t=1/0,i){if(t<=0||!ye(e)||e.__v_skip||(i=i||new Set,i.has(e)))return e;if(i.add(e),t--,we(e))ht(e.value,t,i);else if(Z(e))for(let o=0;o<e.length;o++)ht(e[o],t,i);else if(ro(e)||Bt(e))e.forEach(o=>{ht(o,t,i)});else if(uo(e)){for(const o in e)ht(e[o],t,i);for(const o of Object.getOwnPropertySymbols(e))Object.prototype.propertyIsEnumerable.call(e,o)&&ht(e[o],t,i)}return e}/**
* @vue/runtime-core v3.5.9
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/function mn(e,t,i,o){try{return o?e(...o):e()}catch(a){Hn(a,t,i)}}function rt(e,t,i,o){if(ne(e)){const a=mn(e,t,i,o);return a&&lo(a)&&a.catch(l=>{Hn(l,t,i)}),a}if(Z(e)){const a=[];for(let l=0;l<e.length;l++)a.push(rt(e[l],t,i,o));return a}}function Hn(e,t,i,o=!0){const a=t?t.vnode:null,{errorHandler:l,throwUnhandledErrorInProduction:m}=t&&t.appContext.config||de;if(t){let v=t.parent;const y=t.proxy,M=`https://vuejs.org/error-reference/#runtime-${i}`;for(;v;){const S=v.ec;if(S){for(let $=0;$<S.length;$++)if(S[$](e,y,M)===!1)return}v=v.parent}if(l){St(),mn(l,null,10,[e,y,M]),Pt();return}}Pr(e,i,a,o,m)}function Pr(e,t,i,o=!0,a=!1){if(a)throw e;console.error(e)}let cn=!1,yi=!1;const De=[];let it=0;const Ht=[];let yt=null,Dt=0;const Oo=Promise.resolve();let Ki=null;function un(e){const t=Ki||Oo;return e?t.then(this?e.bind(this):e):t}function Tr(e){let t=cn?it+1:0,i=De.length;for(;t<i;){const o=t+i>>>1,a=De[o],l=hn(a);l<e||l===e&&a.flags&2?t=o+1:i=o}return t}function Gi(e){if(!(e.flags&1)){const t=hn(e),i=De[De.length-1];!i||!(e.flags&2)&&t>=hn(i)?De.push(e):De.splice(Tr(t),0,e),e.flags|=1,zo()}}function zo(){!cn&&!yi&&(yi=!0,Ki=Oo.then(Bo))}function $r(e){Z(e)?Ht.push(...e):yt&&e.id===-1?yt.splice(Dt+1,0,e):e.flags&1||(Ht.push(e),e.flags|=1),zo()}function ms(e,t,i=cn?it+1:0){for(;i<De.length;i++){const o=De[i];if(o&&o.flags&2){if(e&&o.id!==e.uid)continue;De.splice(i,1),i--,o.flags&4&&(o.flags&=-2),o(),o.flags&4||(o.flags&=-2)}}}function qo(e){if(Ht.length){const t=[...new Set(Ht)].sort((i,o)=>hn(i)-hn(o));if(Ht.length=0,yt){yt.push(...t);return}for(yt=t,Dt=0;Dt<yt.length;Dt++){const i=yt[Dt];i.flags&4&&(i.flags&=-2),i.flags&8||i(),i.flags&=-2}yt=null,Dt=0}}const hn=e=>e.id==null?e.flags&2?-1:1/0:e.id;function Bo(e){yi=!1,cn=!0;try{for(it=0;it<De.length;it++){const t=De[it];t&&!(t.flags&8)&&(t.flags&4&&(t.flags&=-2),mn(t,t.i,t.i?15:14),t.flags&4||(t.flags&=-2))}}finally{for(;it<De.length;it++){const t=De[it];t&&(t.flags&=-2)}it=0,De.length=0,qo(),cn=!1,Ki=null,(De.length||Ht.length)&&Bo()}}let Ye=null,Ho=null;function Rn(e){const t=Ye;return Ye=e,Ho=e&&e.type.__scopeId||null,t}function vi(e,t=Ye,i){if(!t||e._n)return e;const o=(...a)=>{o._d&&Ss(-1);const l=Rn(t);let m;try{m=e(...a)}finally{Rn(l),o._d&&Ss(1)}return m};return o._n=!0,o._c=!0,o._d=!0,o}function Fr(e,t){if(Ye===null)return e;const i=Kn(Ye),o=e.dirs||(e.dirs=[]);for(let a=0;a<t.length;a++){let[l,m,v,y=de]=t[a];l&&(ne(l)&&(l={mounted:l,updated:l}),l.deep&&ht(m),o.push({dir:l,instance:i,value:m,oldValue:void 0,arg:v,modifiers:y}))}return e}function Tt(e,t,i,o){const a=e.dirs,l=t&&t.dirs;for(let m=0;m<a.length;m++){const v=a[m];l&&(v.oldValue=l[m].value);let y=v.dir[o];y&&(St(),rt(y,i,8,[e.el,v,e,t]),Pt())}}const _r=Symbol("_vte"),Cr=e=>e.__isTeleport;function Qi(e,t){e.shapeFlag&6&&e.component?(e.transition=t,Qi(e.component.subTree,t)):e.shapeFlag&128?(e.ssContent.transition=t.clone(e.ssContent),e.ssFallback.transition=t.clone(e.ssFallback)):e.transition=t}/*! #__NO_SIDE_EFFECTS__ */function Wn(e,t){return ne(e)?$e({name:e.name},t,{setup:e}):e}function Wo(e){e.ids=[e.ids[0]+e.ids[2]+++"-",0,0]}function bi(e,t,i,o,a=!1){if(Z(e)){e.forEach((n,f)=>bi(n,t&&(Z(t)?t[f]:t),i,o,a));return}if(en(o)&&!a)return;const l=o.shapeFlag&4?Kn(o.component):o.el,m=a?null:l,{i:v,r:y}=e,M=t&&t.r,S=v.refs===de?v.refs={}:v.refs,$=v.setupState,x=oe($),s=$===de?()=>!1:n=>ae(x,n);if(M!=null&&M!==y&&(Se(M)?(S[M]=null,s(M)&&($[M]=null)):we(M)&&(M.value=null)),ne(y))mn(y,v,12,[m,S]);else{const n=Se(y),f=we(y);if(n||f){const d=()=>{if(e.f){const h=n?s(y)?$[y]:S[y]:y.value;a?Z(h)&&ji(h,l):Z(h)?h.includes(l)||h.push(l):n?(S[y]=[l],s(y)&&($[y]=S[y])):(y.value=[l],e.k&&(S[e.k]=y.value))}else n?(S[y]=m,s(y)&&($[y]=m)):f&&(y.value=m,e.k&&(S[e.k]=m))};m?(d.id=-1,We(d,i)):d()}}}const en=e=>!!e.type.__asyncLoader,Uo=e=>e.type.__isKeepAlive;function Er(e,t){No(e,"a",t)}function Rr(e,t){No(e,"da",t)}function No(e,t,i=Re){const o=e.__wdc||(e.__wdc=()=>{let a=i;for(;a;){if(a.isDeactivated)return;a=a.parent}return e()});if(Un(t,o,i),i){let a=i.parent;for(;a&&a.parent;)Uo(a.parent.vnode)&&Ir(o,t,i,a),a=a.parent}}function Ir(e,t,i,o){const a=Un(t,e,o,!0);Ji(()=>{ji(o[t],a)},i)}function Un(e,t,i=Re,o=!1){if(i){const a=i[e]||(i[e]=[]),l=t.__weh||(t.__weh=(...m)=>{St();const v=xn(i),y=rt(t,i,e,m);return v(),Pt(),y});return o?a.unshift(l):a.push(l),l}}const pt=e=>(t,i=Re)=>{(!Xn||e==="sp")&&Un(e,(...o)=>t(...o),i)},Vr=pt("bm"),Yo=pt("m"),kr=pt("bu"),jr=pt("u"),Dr=pt("bum"),Ji=pt("um"),Lr=pt("sp"),Or=pt("rtg"),zr=pt("rtc");function qr(e,t=Re){Un("ec",e,t)}const Br=Symbol.for("v-ndc");function In(e,t,i,o){let a;const l=i,m=Z(e);if(m||Se(e)){const v=m&&wt(e);let y=!1;v&&(y=!Ke(e),e=qn(e)),a=new Array(e.length);for(let M=0,S=e.length;M<S;M++)a[M]=t(y?Ee(e[M]):e[M],M,void 0,l)}else if(typeof e=="number"){a=new Array(e);for(let v=0;v<e;v++)a[v]=t(v+1,v,void 0,l)}else if(ye(e))if(e[Symbol.iterator])a=Array.from(e,(v,y)=>t(v,y,void 0,l));else{const v=Object.keys(e);a=new Array(v.length);for(let y=0,M=v.length;y<M;y++){const S=v[y];a[y]=t(e[S],S,y,l)}}else a=[];return a}const wi=e=>e?pa(e)?Kn(e):wi(e.parent):null,tn=$e(Object.create(null),{$:e=>e,$el:e=>e.vnode.el,$data:e=>e.data,$props:e=>e.props,$attrs:e=>e.attrs,$slots:e=>e.slots,$refs:e=>e.refs,$parent:e=>wi(e.parent),$root:e=>wi(e.root),$host:e=>e.ce,$emit:e=>e.emit,$options:e=>Zi(e),$forceUpdate:e=>e.f||(e.f=()=>{Gi(e.update)}),$nextTick:e=>e.n||(e.n=un.bind(e.proxy)),$watch:e=>ul.bind(e)}),si=(e,t)=>e!==de&&!e.__isScriptSetup&&ae(e,t),Hr={get({_:e},t){if(t==="__v_skip")return!0;const{ctx:i,setupState:o,data:a,props:l,accessCache:m,type:v,appContext:y}=e;let M;if(t[0]!=="$"){const s=m[t];if(s!==void 0)switch(s){case 1:return o[t];case 2:return a[t];case 4:return i[t];case 3:return l[t]}else{if(si(o,t))return m[t]=1,o[t];if(a!==de&&ae(a,t))return m[t]=2,a[t];if((M=e.propsOptions[0])&&ae(M,t))return m[t]=3,l[t];if(i!==de&&ae(i,t))return m[t]=4,i[t];Mi&&(m[t]=0)}}const S=tn[t];let $,x;if(S)return t==="$attrs"&&Ie(e.attrs,"get",""),S(e);if(($=v.__cssModules)&&($=$[t]))return $;if(i!==de&&ae(i,t))return m[t]=4,i[t];if(x=y.config.globalProperties,ae(x,t))return x[t]},set({_:e},t,i){const{data:o,setupState:a,ctx:l}=e;return si(a,t)?(a[t]=i,!0):o!==de&&ae(o,t)?(o[t]=i,!0):ae(e.props,t)||t[0]==="$"&&t.slice(1)in e?!1:(l[t]=i,!0)},has({_:{data:e,setupState:t,accessCache:i,ctx:o,appContext:a,propsOptions:l}},m){let v;return!!i[m]||e!==de&&ae(e,m)||si(t,m)||(v=l[0])&&ae(v,m)||ae(o,m)||ae(tn,m)||ae(a.config.globalProperties,m)},defineProperty(e,t,i){return i.get!=null?e._.accessCache[t]=0:ae(i,"value")&&this.set(e,t,i.value,null),Reflect.defineProperty(e,t,i)}};function xs(e){return Z(e)?e.reduce((t,i)=>(t[i]=null,t),{}):e}let Mi=!0;function Wr(e){const t=Zi(e),i=e.proxy,o=e.ctx;Mi=!1,t.beforeCreate&&ys(t.beforeCreate,e,"bc");const{data:a,computed:l,methods:m,watch:v,provide:y,inject:M,created:S,beforeMount:$,mounted:x,beforeUpdate:s,updated:n,activated:f,deactivated:d,beforeDestroy:h,beforeUnmount:u,destroyed:c,unmounted:r,render:p,renderTracked:F,renderTriggered:b,errorCaptured:A,serverPrefetch:_,expose:T,inheritAttrs:C,components:j,directives:O,filters:k}=t;if(M&&Ur(M,o,null),m)for(const W in m){const G=m[W];ne(G)&&(o[W]=G.bind(i))}if(a){const W=a.call(i,i);ye(W)&&(e.data=gn(W))}if(Mi=!0,l)for(const W in l){const G=l[W],me=ne(G)?G.bind(i,i):ne(G.get)?G.get.bind(i,i):ot,ve=!ne(G)&&ne(G.set)?G.set.bind(i):ot,fe=Pe({get:me,set:ve});Object.defineProperty(o,W,{enumerable:!0,configurable:!0,get:()=>fe.value,set:ue=>fe.value=ue})}if(v)for(const W in v)Xo(v[W],o,i,W);if(y){const W=ne(y)?y.call(i):y;Reflect.ownKeys(W).forEach(G=>{Tn(G,W[G])})}S&&ys(S,e,"c");function K(W,G){Z(G)?G.forEach(me=>W(me.bind(i))):G&&W(G.bind(i))}if(K(Vr,$),K(Yo,x),K(kr,s),K(jr,n),K(Er,f),K(Rr,d),K(qr,A),K(zr,F),K(Or,b),K(Dr,u),K(Ji,r),K(Lr,_),Z(T))if(T.length){const W=e.exposed||(e.exposed={});T.forEach(G=>{Object.defineProperty(W,G,{get:()=>i[G],set:me=>i[G]=me})})}else e.exposed||(e.exposed={});p&&e.render===ot&&(e.render=p),C!=null&&(e.inheritAttrs=C),j&&(e.components=j),O&&(e.directives=O),_&&Wo(e)}function Ur(e,t,i=ot){Z(e)&&(e=Ai(e));for(const o in e){const a=e[o];let l;ye(a)?"default"in a?l=Ge(a.from||o,a.default,!0):l=Ge(a.from||o):l=Ge(a),we(l)?Object.defineProperty(t,o,{enumerable:!0,configurable:!0,get:()=>l.value,set:m=>l.value=m}):t[o]=l}}function ys(e,t,i){rt(Z(e)?e.map(o=>o.bind(t.proxy)):e.bind(t.proxy),t,i)}function Xo(e,t,i,o){let a=o.includes(".")?la(i,o):()=>i[o];if(Se(e)){const l=t[e];ne(l)&&Wt(a,l)}else if(ne(e))Wt(a,e.bind(i));else if(ye(e))if(Z(e))e.forEach(l=>Xo(l,t,i,o));else{const l=ne(e.handler)?e.handler.bind(i):t[e.handler];ne(l)&&Wt(a,l,e)}}function Zi(e){const t=e.type,{mixins:i,extends:o}=t,{mixins:a,optionsCache:l,config:{optionMergeStrategies:m}}=e.appContext,v=l.get(t);let y;return v?y=v:!a.length&&!i&&!o?y=t:(y={},a.length&&a.forEach(M=>Vn(y,M,m,!0)),Vn(y,t,m)),ye(t)&&l.set(t,y),y}function Vn(e,t,i,o=!1){const{mixins:a,extends:l}=t;l&&Vn(e,l,i,!0),a&&a.forEach(m=>Vn(e,m,i,!0));for(const m in t)if(!(o&&m==="expose")){const v=Nr[m]||i&&i[m];e[m]=v?v(e[m],t[m]):t[m]}return e}const Nr={data:vs,props:bs,emits:bs,methods:Jt,computed:Jt,beforeCreate:Ve,created:Ve,beforeMount:Ve,mounted:Ve,beforeUpdate:Ve,updated:Ve,beforeDestroy:Ve,beforeUnmount:Ve,destroyed:Ve,unmounted:Ve,activated:Ve,deactivated:Ve,errorCaptured:Ve,serverPrefetch:Ve,components:Jt,directives:Jt,watch:Xr,provide:vs,inject:Yr};function vs(e,t){return t?e?function(){return $e(ne(e)?e.call(this,this):e,ne(t)?t.call(this,this):t)}:t:e}function Yr(e,t){return Jt(Ai(e),Ai(t))}function Ai(e){if(Z(e)){const t={};for(let i=0;i<e.length;i++)t[e[i]]=e[i];return t}return e}function Ve(e,t){return e?[...new Set([].concat(e,t))]:t}function Jt(e,t){return e?$e(Object.create(null),e,t):t}function bs(e,t){return e?Z(e)&&Z(t)?[...new Set([...e,...t])]:$e(Object.create(null),xs(e),xs(t??{})):t}function Xr(e,t){if(!e)return t;if(!t)return e;const i=$e(Object.create(null),e);for(const o in t)i[o]=Ve(e[o],t[o]);return i}function Ko(){return{app:null,config:{isNativeTag:ka,performance:!1,globalProperties:{},optionMergeStrategies:{},errorHandler:void 0,warnHandler:void 0,compilerOptions:{}},mixins:[],components:{},directives:{},provides:Object.create(null),optionsCache:new WeakMap,propsCache:new WeakMap,emitsCache:new WeakMap}}let Kr=0;function Gr(e,t){return function(o,a=null){ne(o)||(o=$e({},o)),a!=null&&!ye(a)&&(a=null);const l=Ko(),m=new WeakSet,v=[];let y=!1;const M=l.app={_uid:Kr++,_component:o,_props:a,_container:null,_context:l,_instance:null,version:Cl,get config(){return l.config},set config(S){},use(S,...$){return m.has(S)||(S&&ne(S.install)?(m.add(S),S.install(M,...$)):ne(S)&&(m.add(S),S(M,...$))),M},mixin(S){return l.mixins.includes(S)||l.mixins.push(S),M},component(S,$){return $?(l.components[S]=$,M):l.components[S]},directive(S,$){return $?(l.directives[S]=$,M):l.directives[S]},mount(S,$,x){if(!y){const s=M._ceVNode||Le(o,a);return s.appContext=l,x===!0?x="svg":x===!1&&(x=void 0),$&&t?t(s,S):e(s,S,x),y=!0,M._container=S,S.__vue_app__=M,Kn(s.component)}},onUnmount(S){v.push(S)},unmount(){y&&(rt(v,M._instance,16),e(null,M._container),delete M._container.__vue_app__)},provide(S,$){return l.provides[S]=$,M},runWithContext(S){const $=Ct;Ct=M;try{return S()}finally{Ct=$}}};return M}}let Ct=null;function Tn(e,t){if(Re){let i=Re.provides;const o=Re.parent&&Re.parent.provides;o===i&&(i=Re.provides=Object.create(o)),i[e]=t}}function Ge(e,t,i=!1){const o=Re||Ye;if(o||Ct){const a=Ct?Ct._context.provides:o?o.parent==null?o.vnode.appContext&&o.vnode.appContext.provides:o.parent.provides:void 0;if(a&&e in a)return a[e];if(arguments.length>1)return i&&ne(t)?t.call(o&&o.proxy):t}}function Qr(){return!!(Re||Ye||Ct)}const Go={},Qo=()=>Object.create(Go),Jo=e=>Object.getPrototypeOf(e)===Go;function Jr(e,t,i,o=!1){const a={},l=Qo();e.propsDefaults=Object.create(null),Zo(e,t,a,l);for(const m in e.propsOptions[0])m in a||(a[m]=void 0);i?e.props=o?a:ko(a):e.type.props?e.props=a:e.props=l,e.attrs=l}function Zr(e,t,i,o){const{props:a,attrs:l,vnode:{patchFlag:m}}=e,v=oe(a),[y]=e.propsOptions;let M=!1;if((o||m>0)&&!(m&16)){if(m&8){const S=e.vnode.dynamicProps;for(let $=0;$<S.length;$++){let x=S[$];if(Nn(e.emitsOptions,x))continue;const s=t[x];if(y)if(ae(l,x))s!==l[x]&&(l[x]=s,M=!0);else{const n=Et(x);a[n]=Si(y,v,n,s,e,!1)}else s!==l[x]&&(l[x]=s,M=!0)}}}else{Zo(e,t,a,l)&&(M=!0);let S;for(const $ in v)(!t||!ae(t,$)&&((S=Vt($))===$||!ae(t,S)))&&(y?i&&(i[$]!==void 0||i[S]!==void 0)&&(a[$]=Si(y,v,$,void 0,e,!0)):delete a[$]);if(l!==v)for(const $ in l)(!t||!ae(t,$))&&(delete l[$],M=!0)}M&&ft(e.attrs,"set","")}function Zo(e,t,i,o){const[a,l]=e.propsOptions;let m=!1,v;if(t)for(let y in t){if(Zt(y))continue;const M=t[y];let S;a&&ae(a,S=Et(y))?!l||!l.includes(S)?i[S]=M:(v||(v={}))[S]=M:Nn(e.emitsOptions,y)||(!(y in o)||M!==o[y])&&(o[y]=M,m=!0)}if(l){const y=oe(i),M=v||de;for(let S=0;S<l.length;S++){const $=l[S];i[$]=Si(a,y,$,M[$],e,!ae(M,$))}}return m}function Si(e,t,i,o,a,l){const m=e[i];if(m!=null){const v=ae(m,"default");if(v&&o===void 0){const y=m.default;if(m.type!==Function&&!m.skipFactory&&ne(y)){const{propsDefaults:M}=a;if(i in M)o=M[i];else{const S=xn(a);o=M[i]=y.call(null,t),S()}}else o=y;a.ce&&a.ce._setProp(i,o)}m[0]&&(l&&!v?o=!1:m[1]&&(o===""||o===Vt(i))&&(o=!0))}return o}const el=new WeakMap;function ea(e,t,i=!1){const o=i?el:t.propsCache,a=o.get(e);if(a)return a;const l=e.props,m={},v=[];let y=!1;if(!ne(e)){const S=$=>{y=!0;const[x,s]=ea($,t,!0);$e(m,x),s&&v.push(...s)};!i&&t.mixins.length&&t.mixins.forEach(S),e.extends&&S(e.extends),e.mixins&&e.mixins.forEach(S)}if(!l&&!y)return ye(e)&&o.set(e,qt),qt;if(Z(l))for(let S=0;S<l.length;S++){const $=Et(l[S]);ws($)&&(m[$]=de)}else if(l)for(const S in l){const $=Et(S);if(ws($)){const x=l[S],s=m[$]=Z(x)||ne(x)?{type:x}:$e({},x),n=s.type;let f=!1,d=!0;if(Z(n))for(let h=0;h<n.length;++h){const u=n[h],c=ne(u)&&u.name;if(c==="Boolean"){f=!0;break}else c==="String"&&(d=!1)}else f=ne(n)&&n.name==="Boolean";s[0]=f,s[1]=d,(f||ae(s,"default"))&&v.push($)}}const M=[m,v];return ye(e)&&o.set(e,M),M}function ws(e){return e[0]!=="$"&&!Zt(e)}const ta=e=>e[0]==="_"||e==="$stable",es=e=>Z(e)?e.map(st):[st(e)],tl=(e,t,i)=>{if(t._n)return t;const o=vi((...a)=>es(t(...a)),i);return o._c=!1,o},na=(e,t,i)=>{const o=e._ctx;for(const a in e){if(ta(a))continue;const l=e[a];if(ne(l))t[a]=tl(a,l,o);else if(l!=null){const m=es(l);t[a]=()=>m}}},ia=(e,t)=>{const i=es(t);e.slots.default=()=>i},sa=(e,t,i)=>{for(const o in t)(i||o!=="_")&&(e[o]=t[o])},nl=(e,t,i)=>{const o=e.slots=Qo();if(e.vnode.shapeFlag&32){const a=t._;a?(sa(o,t,i),i&&fo(o,"_",a,!0)):na(t,o)}else t&&ia(e,t)},il=(e,t,i)=>{const{vnode:o,slots:a}=e;let l=!0,m=de;if(o.shapeFlag&32){const v=t._;v?i&&v===1?l=!1:sa(a,t,i):(l=!t.$stable,na(t,a)),m=t}else t&&(ia(e,t),m={default:1});if(l)for(const v in a)!ta(v)&&m[v]==null&&delete a[v]},We=xl;function sl(e){return ol(e)}function ol(e,t){const i=po();i.__VUE__=!0;const{insert:o,remove:a,patchProp:l,createElement:m,createText:v,createComment:y,setText:M,setElementText:S,parentNode:$,nextSibling:x,setScopeId:s=ot,insertStaticContent:n}=e,f=(w,P,E,D=null,V=null,L=null,N=void 0,H=null,q=!!P.dynamicChildren)=>{if(w===P)return;w&&!Gt(w,P)&&(D=I(w),ue(w,V,L,!0),w=null),P.patchFlag===-2&&(q=!1,P.dynamicChildren=null);const{type:z,ref:J,shapeFlag:Y}=P;switch(z){case Yn:d(w,P,E,D);break;case It:h(w,P,E,D);break;case ri:w==null&&u(P,E,D,N);break;case Oe:j(w,P,E,D,V,L,N,H,q);break;default:Y&1?p(w,P,E,D,V,L,N,H,q):Y&6?O(w,P,E,D,V,L,N,H,q):(Y&64||Y&128)&&z.process(w,P,E,D,V,L,N,H,q,X)}J!=null&&V&&bi(J,w&&w.ref,L,P||w,!P)},d=(w,P,E,D)=>{if(w==null)o(P.el=v(P.children),E,D);else{const V=P.el=w.el;P.children!==w.children&&M(V,P.children)}},h=(w,P,E,D)=>{w==null?o(P.el=y(P.children||""),E,D):P.el=w.el},u=(w,P,E,D)=>{[w.el,w.anchor]=n(w.children,P,E,D,w.el,w.anchor)},c=({el:w,anchor:P},E,D)=>{let V;for(;w&&w!==P;)V=x(w),o(w,E,D),w=V;o(P,E,D)},r=({el:w,anchor:P})=>{let E;for(;w&&w!==P;)E=x(w),a(w),w=E;a(P)},p=(w,P,E,D,V,L,N,H,q)=>{P.type==="svg"?N="svg":P.type==="math"&&(N="mathml"),w==null?F(P,E,D,V,L,N,H,q):_(w,P,V,L,N,H,q)},F=(w,P,E,D,V,L,N,H)=>{let q,z;const{props:J,shapeFlag:Y,transition:Q,dirs:te}=w;if(q=w.el=m(w.type,L,J&&J.is,J),Y&8?S(q,w.children):Y&16&&A(w.children,q,null,D,V,oi(w,L),N,H),te&&Tt(w,null,D,"created"),b(q,w,w.scopeId,N,D),J){for(const pe in J)pe!=="value"&&!Zt(pe)&&l(q,pe,null,J[pe],L,D);"value"in J&&l(q,"value",null,J.value,L),(z=J.onVnodeBeforeMount)&&tt(z,D,w)}te&&Tt(w,null,D,"beforeMount");const ie=al(V,Q);ie&&Q.beforeEnter(q),o(q,P,E),((z=J&&J.onVnodeMounted)||ie||te)&&We(()=>{z&&tt(z,D,w),ie&&Q.enter(q),te&&Tt(w,null,D,"mounted")},V)},b=(w,P,E,D,V)=>{if(E&&s(w,E),D)for(let L=0;L<D.length;L++)s(w,D[L]);if(V){let L=V.subTree;if(P===L||ua(L.type)&&(L.ssContent===P||L.ssFallback===P)){const N=V.vnode;b(w,N,N.scopeId,N.slotScopeIds,V.parent)}}},A=(w,P,E,D,V,L,N,H,q=0)=>{for(let z=q;z<w.length;z++){const J=w[z]=H?vt(w[z]):st(w[z]);f(null,J,P,E,D,V,L,N,H)}},_=(w,P,E,D,V,L,N)=>{const H=P.el=w.el;let{patchFlag:q,dynamicChildren:z,dirs:J}=P;q|=w.patchFlag&16;const Y=w.props||de,Q=P.props||de;let te;if(E&&$t(E,!1),(te=Q.onVnodeBeforeUpdate)&&tt(te,E,P,w),J&&Tt(P,w,E,"beforeUpdate"),E&&$t(E,!0),(Y.innerHTML&&Q.innerHTML==null||Y.textContent&&Q.textContent==null)&&S(H,""),z?T(w.dynamicChildren,z,H,E,D,oi(P,V),L):N||G(w,P,H,null,E,D,oi(P,V),L,!1),q>0){if(q&16)C(H,Y,Q,E,V);else if(q&2&&Y.class!==Q.class&&l(H,"class",null,Q.class,V),q&4&&l(H,"style",Y.style,Q.style,V),q&8){const ie=P.dynamicProps;for(let pe=0;pe<ie.length;pe++){const re=ie[pe],ze=Y[re],_e=Q[re];(_e!==ze||re==="value")&&l(H,re,ze,_e,V,E)}}q&1&&w.children!==P.children&&S(H,P.children)}else!N&&z==null&&C(H,Y,Q,E,V);((te=Q.onVnodeUpdated)||J)&&We(()=>{te&&tt(te,E,P,w),J&&Tt(P,w,E,"updated")},D)},T=(w,P,E,D,V,L,N)=>{for(let H=0;H<P.length;H++){const q=w[H],z=P[H],J=q.el&&(q.type===Oe||!Gt(q,z)||q.shapeFlag&70)?$(q.el):E;f(q,z,J,null,D,V,L,N,!0)}},C=(w,P,E,D,V)=>{if(P!==E){if(P!==de)for(const L in P)!Zt(L)&&!(L in E)&&l(w,L,P[L],null,V,D);for(const L in E){if(Zt(L))continue;const N=E[L],H=P[L];N!==H&&L!=="value"&&l(w,L,H,N,V,D)}"value"in E&&l(w,"value",P.value,E.value,V)}},j=(w,P,E,D,V,L,N,H,q)=>{const z=P.el=w?w.el:v(""),J=P.anchor=w?w.anchor:v("");let{patchFlag:Y,dynamicChildren:Q,slotScopeIds:te}=P;te&&(H=H?H.concat(te):te),w==null?(o(z,E,D),o(J,E,D),A(P.children||[],E,J,V,L,N,H,q)):Y>0&&Y&64&&Q&&w.dynamicChildren?(T(w.dynamicChildren,Q,E,V,L,N,H),(P.key!=null||V&&P===V.subTree)&&oa(w,P,!0)):G(w,P,E,J,V,L,N,H,q)},O=(w,P,E,D,V,L,N,H,q)=>{P.slotScopeIds=H,w==null?P.shapeFlag&512?V.ctx.activate(P,E,D,N,q):k(P,E,D,V,L,N,q):ee(w,P,q)},k=(w,P,E,D,V,L,N)=>{const H=w.component=Sl(w,D,V);if(Uo(w)&&(H.ctx.renderer=X),Pl(H,!1,N),H.asyncDep){if(V&&V.registerDep(H,K,N),!w.el){const q=H.subTree=Le(It);h(null,q,P,E)}}else K(H,w,P,E,V,L,N)},ee=(w,P,E)=>{const D=P.component=w.component;if(gl(w,P,E))if(D.asyncDep&&!D.asyncResolved){W(D,P,E);return}else D.next=P,D.update();else P.el=w.el,D.vnode=P},K=(w,P,E,D,V,L,N)=>{const H=()=>{if(w.isMounted){let{next:Y,bu:Q,u:te,parent:ie,vnode:pe}=w;{const qe=aa(w);if(qe){Y&&(Y.el=pe.el,W(w,Y,N)),qe.asyncDep.then(()=>{w.isUnmounted||H()});return}}let re=Y,ze;$t(w,!1),Y?(Y.el=pe.el,W(w,Y,N)):Y=pe,Q&&Pn(Q),(ze=Y.props&&Y.props.onVnodeBeforeUpdate)&&tt(ze,ie,Y,pe),$t(w,!0);const _e=ai(w),Qe=w.subTree;w.subTree=_e,f(Qe,_e,$(Qe.el),I(Qe),w,V,L),Y.el=_e.el,re===null&&ml(w,_e.el),te&&We(te,V),(ze=Y.props&&Y.props.onVnodeUpdated)&&We(()=>tt(ze,ie,Y,pe),V)}else{let Y;const{el:Q,props:te}=P,{bm:ie,m:pe,parent:re,root:ze,type:_e}=w,Qe=en(P);if($t(w,!1),ie&&Pn(ie),!Qe&&(Y=te&&te.onVnodeBeforeMount)&&tt(Y,re,P),$t(w,!0),Q&&xe){const qe=()=>{w.subTree=ai(w),xe(Q,w.subTree,w,V,null)};Qe&&_e.__asyncHydrate?_e.__asyncHydrate(Q,w,qe):qe()}else{ze.ce&&ze.ce._injectChildStyle(_e);const qe=w.subTree=ai(w);f(null,qe,E,D,w,V,L),P.el=qe.el}if(pe&&We(pe,V),!Qe&&(Y=te&&te.onVnodeMounted)){const qe=P;We(()=>tt(Y,re,qe),V)}(P.shapeFlag&256||re&&en(re.vnode)&&re.vnode.shapeFlag&256)&&w.a&&We(w.a,V),w.isMounted=!0,P=E=D=null}};w.scope.on();const q=w.effect=new wo(H);w.scope.off();const z=w.update=q.run.bind(q),J=w.job=q.runIfDirty.bind(q);J.i=w,J.id=w.uid,q.scheduler=()=>Gi(J),$t(w,!0),z()},W=(w,P,E)=>{P.component=w;const D=w.vnode.props;w.vnode=P,w.next=null,Zr(w,P.props,D,E),il(w,P.children,E),St(),ms(w),Pt()},G=(w,P,E,D,V,L,N,H,q=!1)=>{const z=w&&w.children,J=w?w.shapeFlag:0,Y=P.children,{patchFlag:Q,shapeFlag:te}=P;if(Q>0){if(Q&128){ve(z,Y,E,D,V,L,N,H,q);return}else if(Q&256){me(z,Y,E,D,V,L,N,H,q);return}}te&8?(J&16&&Me(z,V,L),Y!==z&&S(E,Y)):J&16?te&16?ve(z,Y,E,D,V,L,N,H,q):Me(z,V,L,!0):(J&8&&S(E,""),te&16&&A(Y,E,D,V,L,N,H,q))},me=(w,P,E,D,V,L,N,H,q)=>{w=w||qt,P=P||qt;const z=w.length,J=P.length,Y=Math.min(z,J);let Q;for(Q=0;Q<Y;Q++){const te=P[Q]=q?vt(P[Q]):st(P[Q]);f(w[Q],te,E,null,V,L,N,H,q)}z>J?Me(w,V,L,!0,!1,Y):A(P,E,D,V,L,N,H,q,Y)},ve=(w,P,E,D,V,L,N,H,q)=>{let z=0;const J=P.length;let Y=w.length-1,Q=J-1;for(;z<=Y&&z<=Q;){const te=w[z],ie=P[z]=q?vt(P[z]):st(P[z]);if(Gt(te,ie))f(te,ie,E,null,V,L,N,H,q);else break;z++}for(;z<=Y&&z<=Q;){const te=w[Y],ie=P[Q]=q?vt(P[Q]):st(P[Q]);if(Gt(te,ie))f(te,ie,E,null,V,L,N,H,q);else break;Y--,Q--}if(z>Y){if(z<=Q){const te=Q+1,ie=te<J?P[te].el:D;for(;z<=Q;)f(null,P[z]=q?vt(P[z]):st(P[z]),E,ie,V,L,N,H,q),z++}}else if(z>Q)for(;z<=Y;)ue(w[z],V,L,!0),z++;else{const te=z,ie=z,pe=new Map;for(z=ie;z<=Q;z++){const Be=P[z]=q?vt(P[z]):st(P[z]);Be.key!=null&&pe.set(Be.key,z)}let re,ze=0;const _e=Q-ie+1;let Qe=!1,qe=0;const Xt=new Array(_e);for(z=0;z<_e;z++)Xt[z]=0;for(z=te;z<=Y;z++){const Be=w[z];if(ze>=_e){ue(Be,V,L,!0);continue}let et;if(Be.key!=null)et=pe.get(Be.key);else for(re=ie;re<=Q;re++)if(Xt[re-ie]===0&&Gt(Be,P[re])){et=re;break}et===void 0?ue(Be,V,L,!0):(Xt[et-ie]=z+1,et>=qe?qe=et:Qe=!0,f(Be,P[et],E,null,V,L,N,H,q),ze++)}const rs=Qe?rl(Xt):qt;for(re=rs.length-1,z=_e-1;z>=0;z--){const Be=ie+z,et=P[Be],ls=Be+1<J?P[Be+1].el:D;Xt[z]===0?f(null,et,E,ls,V,L,N,H,q):Qe&&(re<0||z!==rs[re]?fe(et,E,ls,2):re--)}}},fe=(w,P,E,D,V=null)=>{const{el:L,type:N,transition:H,children:q,shapeFlag:z}=w;if(z&6){fe(w.component.subTree,P,E,D);return}if(z&128){w.suspense.move(P,E,D);return}if(z&64){N.move(w,P,E,X);return}if(N===Oe){o(L,P,E);for(let Y=0;Y<q.length;Y++)fe(q[Y],P,E,D);o(w.anchor,P,E);return}if(N===ri){c(w,P,E);return}if(D!==2&&z&1&&H)if(D===0)H.beforeEnter(L),o(L,P,E),We(()=>H.enter(L),V);else{const{leave:Y,delayLeave:Q,afterLeave:te}=H,ie=()=>o(L,P,E),pe=()=>{Y(L,()=>{ie(),te&&te()})};Q?Q(L,ie,pe):pe()}else o(L,P,E)},ue=(w,P,E,D=!1,V=!1)=>{const{type:L,props:N,ref:H,children:q,dynamicChildren:z,shapeFlag:J,patchFlag:Y,dirs:Q,cacheIndex:te}=w;if(Y===-2&&(V=!1),H!=null&&bi(H,null,E,w,!0),te!=null&&(P.renderCache[te]=void 0),J&256){P.ctx.deactivate(w);return}const ie=J&1&&Q,pe=!en(w);let re;if(pe&&(re=N&&N.onVnodeBeforeUnmount)&&tt(re,P,w),J&6)Fe(w.component,E,D);else{if(J&128){w.suspense.unmount(E,D);return}ie&&Tt(w,null,P,"beforeUnmount"),J&64?w.type.remove(w,P,E,X,D):z&&!z.hasOnce&&(L!==Oe||Y>0&&Y&64)?Me(z,P,E,!1,!0):(L===Oe&&Y&384||!V&&J&16)&&Me(q,P,E),D&&be(w)}(pe&&(re=N&&N.onVnodeUnmounted)||ie)&&We(()=>{re&&tt(re,P,w),ie&&Tt(w,null,P,"unmounted")},E)},be=w=>{const{type:P,el:E,anchor:D,transition:V}=w;if(P===Oe){Te(E,D);return}if(P===ri){r(w);return}const L=()=>{a(E),V&&!V.persisted&&V.afterLeave&&V.afterLeave()};if(w.shapeFlag&1&&V&&!V.persisted){const{leave:N,delayLeave:H}=V,q=()=>N(E,L);H?H(w.el,L,q):q()}else L()},Te=(w,P)=>{let E;for(;w!==P;)E=x(w),a(w),w=E;a(P)},Fe=(w,P,E)=>{const{bum:D,scope:V,job:L,subTree:N,um:H,m:q,a:z}=w;Ms(q),Ms(z),D&&Pn(D),V.stop(),L&&(L.flags|=8,ue(N,w,P,E)),H&&We(H,P),We(()=>{w.isUnmounted=!0},P),P&&P.pendingBranch&&!P.isUnmounted&&w.asyncDep&&!w.asyncResolved&&w.suspenseId===P.pendingId&&(P.deps--,P.deps===0&&P.resolve())},Me=(w,P,E,D=!1,V=!1,L=0)=>{for(let N=L;N<w.length;N++)ue(w[N],P,E,D,V)},I=w=>{if(w.shapeFlag&6)return I(w.component.subTree);if(w.shapeFlag&128)return w.suspense.next();const P=x(w.anchor||w.el),E=P&&P[_r];return E?x(E):P};let U=!1;const B=(w,P,E)=>{w==null?P._vnode&&ue(P._vnode,null,null,!0):f(P._vnode||null,w,P,null,null,null,E),P._vnode=w,U||(U=!0,ms(),qo(),U=!1)},X={p:f,um:ue,m:fe,r:be,mt:k,mc:A,pc:G,pbc:T,n:I,o:e};let se,xe;return{render:B,hydrate:se,createApp:Gr(B,se)}}function oi({type:e,props:t},i){return i==="svg"&&e==="foreignObject"||i==="mathml"&&e==="annotation-xml"&&t&&t.encoding&&t.encoding.includes("html")?void 0:i}function $t({effect:e,job:t},i){i?(e.flags|=32,t.flags|=4):(e.flags&=-33,t.flags&=-5)}function al(e,t){return(!e||e&&!e.pendingBranch)&&t&&!t.persisted}function oa(e,t,i=!1){const o=e.children,a=t.children;if(Z(o)&&Z(a))for(let l=0;l<o.length;l++){const m=o[l];let v=a[l];v.shapeFlag&1&&!v.dynamicChildren&&((v.patchFlag<=0||v.patchFlag===32)&&(v=a[l]=vt(a[l]),v.el=m.el),!i&&v.patchFlag!==-2&&oa(m,v)),v.type===Yn&&(v.el=m.el)}}function rl(e){const t=e.slice(),i=[0];let o,a,l,m,v;const y=e.length;for(o=0;o<y;o++){const M=e[o];if(M!==0){if(a=i[i.length-1],e[a]<M){t[o]=a,i.push(o);continue}for(l=0,m=i.length-1;l<m;)v=l+m>>1,e[i[v]]<M?l=v+1:m=v;M<e[i[l]]&&(l>0&&(t[o]=i[l-1]),i[l]=o)}}for(l=i.length,m=i[l-1];l-- >0;)i[l]=m,m=t[m];return i}function aa(e){const t=e.subTree.component;if(t)return t.asyncDep&&!t.asyncResolved?t:aa(t)}function Ms(e){if(e)for(let t=0;t<e.length;t++)e[t].flags|=8}const ll=Symbol.for("v-scx"),cl=()=>Ge(ll);function Wt(e,t,i){return ra(e,t,i)}function ra(e,t,i=de){const{immediate:o,deep:a,flush:l,once:m}=i,v=$e({},i);let y;if(Xn)if(l==="sync"){const x=cl();y=x.__watcherHandles||(x.__watcherHandles=[])}else if(!t||o)v.once=!0;else{const x=()=>{};return x.stop=ot,x.resume=ot,x.pause=ot,x}const M=Re;v.call=(x,s,n)=>rt(x,M,s,n);let S=!1;l==="post"?v.scheduler=x=>{We(x,M&&M.suspense)}:l!=="sync"&&(S=!0,v.scheduler=(x,s)=>{s?x():Gi(x)}),v.augmentJob=x=>{t&&(x.flags|=4),S&&(x.flags|=2,M&&(x.id=M.uid,x.i=M))};const $=Sr(e,t,v);return y&&y.push($),$}function ul(e,t,i){const o=this.proxy,a=Se(e)?e.includes(".")?la(o,e):()=>o[e]:e.bind(o,o);let l;ne(t)?l=t:(l=t.handler,i=t);const m=xn(this),v=ra(a,l.bind(o),i);return m(),v}function la(e,t){const i=t.split(".");return()=>{let o=e;for(let a=0;a<i.length&&o;a++)o=o[i[a]];return o}}const hl=(e,t)=>t==="modelValue"||t==="model-value"?e.modelModifiers:e[`${t}Modifiers`]||e[`${Et(t)}Modifiers`]||e[`${Vt(t)}Modifiers`];function fl(e,t,...i){if(e.isUnmounted)return;const o=e.vnode.props||de;let a=i;const l=t.startsWith("update:"),m=l&&hl(o,t.slice(7));m&&(m.trim&&(a=i.map(S=>Se(S)?S.trim():S)),m.number&&(a=i.map(gi)));let v,y=o[v=Zn(t)]||o[v=Zn(Et(t))];!y&&l&&(y=o[v=Zn(Vt(t))]),y&&rt(y,e,6,a);const M=o[v+"Once"];if(M){if(!e.emitted)e.emitted={};else if(e.emitted[v])return;e.emitted[v]=!0,rt(M,e,6,a)}}function ca(e,t,i=!1){const o=t.emitsCache,a=o.get(e);if(a!==void 0)return a;const l=e.emits;let m={},v=!1;if(!ne(e)){const y=M=>{const S=ca(M,t,!0);S&&(v=!0,$e(m,S))};!i&&t.mixins.length&&t.mixins.forEach(y),e.extends&&y(e.extends),e.mixins&&e.mixins.forEach(y)}return!l&&!v?(ye(e)&&o.set(e,null),null):(Z(l)?l.forEach(y=>m[y]=null):$e(m,l),ye(e)&&o.set(e,m),m)}function Nn(e,t){return!e||!Dn(t)?!1:(t=t.slice(2).replace(/Once$/,""),ae(e,t[0].toLowerCase()+t.slice(1))||ae(e,Vt(t))||ae(e,t))}function ai(e){const{type:t,vnode:i,proxy:o,withProxy:a,propsOptions:[l],slots:m,attrs:v,emit:y,render:M,renderCache:S,props:$,data:x,setupState:s,ctx:n,inheritAttrs:f}=e,d=Rn(e);let h,u;try{if(i.shapeFlag&4){const r=a||o,p=r;h=st(M.call(p,r,S,$,s,x,n)),u=v}else{const r=t;h=st(r.length>1?r($,{attrs:v,slots:m,emit:y}):r($,null)),u=t.props?v:dl(v)}}catch(r){nn.length=0,Hn(r,e,1),h=Le(It)}let c=h;if(u&&f!==!1){const r=Object.keys(u),{shapeFlag:p}=c;r.length&&p&7&&(l&&r.some(ki)&&(u=pl(u,l)),c=Ut(c,u,!1,!0))}return i.dirs&&(c=Ut(c,null,!1,!0),c.dirs=c.dirs?c.dirs.concat(i.dirs):i.dirs),i.transition&&Qi(c,i.transition),h=c,Rn(d),h}const dl=e=>{let t;for(const i in e)(i==="class"||i==="style"||Dn(i))&&((t||(t={}))[i]=e[i]);return t},pl=(e,t)=>{const i={};for(const o in e)(!ki(o)||!(o.slice(9)in t))&&(i[o]=e[o]);return i};function gl(e,t,i){const{props:o,children:a,component:l}=e,{props:m,children:v,patchFlag:y}=t,M=l.emitsOptions;if(t.dirs||t.transition)return!0;if(i&&y>=0){if(y&1024)return!0;if(y&16)return o?As(o,m,M):!!m;if(y&8){const S=t.dynamicProps;for(let $=0;$<S.length;$++){const x=S[$];if(m[x]!==o[x]&&!Nn(M,x))return!0}}}else return(a||v)&&(!v||!v.$stable)?!0:o===m?!1:o?m?As(o,m,M):!0:!!m;return!1}function As(e,t,i){const o=Object.keys(t);if(o.length!==Object.keys(e).length)return!0;for(let a=0;a<o.length;a++){const l=o[a];if(t[l]!==e[l]&&!Nn(i,l))return!0}return!1}function ml({vnode:e,parent:t},i){for(;t;){const o=t.subTree;if(o.suspense&&o.suspense.activeBranch===e&&(o.el=e.el),o===e)(e=t.vnode).el=i,t=t.parent;else break}}const ua=e=>e.__isSuspense;function xl(e,t){t&&t.pendingBranch?Z(e)?t.effects.push(...e):t.effects.push(e):$r(e)}const Oe=Symbol.for("v-fgt"),Yn=Symbol.for("v-txt"),It=Symbol.for("v-cmt"),ri=Symbol.for("v-stc"),nn=[];let Xe=null;function je(e=!1){nn.push(Xe=e?null:[])}function yl(){nn.pop(),Xe=nn[nn.length-1]||null}let fn=1;function Ss(e){fn+=e,e<0&&Xe&&(Xe.hasOnce=!0)}function ha(e){return e.dynamicChildren=fn>0?Xe||qt:null,yl(),fn>0&&Xe&&Xe.push(e),e}function Ue(e,t,i,o,a,l){return ha(Ce(e,t,i,o,a,l,!0))}function fa(e,t,i,o,a){return ha(Le(e,t,i,o,a,!0))}function kn(e){return e?e.__v_isVNode===!0:!1}function Gt(e,t){return e.type===t.type&&e.key===t.key}const da=({key:e})=>e??null,$n=({ref:e,ref_key:t,ref_for:i})=>(typeof e=="number"&&(e=""+e),e!=null?Se(e)||we(e)||ne(e)?{i:Ye,r:e,k:t,f:!!i}:e:null);function Ce(e,t=null,i=null,o=0,a=null,l=e===Oe?0:1,m=!1,v=!1){const y={__v_isVNode:!0,__v_skip:!0,type:e,props:t,key:t&&da(t),ref:t&&$n(t),scopeId:Ho,slotScopeIds:null,children:i,component:null,suspense:null,ssContent:null,ssFallback:null,dirs:null,transition:null,el:null,anchor:null,target:null,targetStart:null,targetAnchor:null,staticCount:0,shapeFlag:l,patchFlag:o,dynamicProps:a,dynamicChildren:null,appContext:null,ctx:Ye};return v?(ts(y,i),l&128&&e.normalize(y)):i&&(y.shapeFlag|=Se(i)?8:16),fn>0&&!m&&Xe&&(y.patchFlag>0||l&6)&&y.patchFlag!==32&&Xe.push(y),y}const Le=vl;function vl(e,t=null,i=null,o=0,a=null,l=!1){if((!e||e===Br)&&(e=It),kn(e)){const v=Ut(e,t,!0);return i&&ts(v,i),fn>0&&!l&&Xe&&(v.shapeFlag&6?Xe[Xe.indexOf(e)]=v:Xe.push(v)),v.patchFlag=-2,v}if(_l(e)&&(e=e.__vccOpts),t){t=bl(t);let{class:v,style:y}=t;v&&!Se(v)&&(t.class=zn(v)),ye(y)&&(Ni(y)&&!Z(y)&&(y=$e({},y)),t.style=Li(y))}const m=Se(e)?1:ua(e)?128:Cr(e)?64:ye(e)?4:ne(e)?2:0;return Ce(e,t,i,o,a,m,l,!0)}function bl(e){return e?Ni(e)||Jo(e)?$e({},e):e:null}function Ut(e,t,i=!1,o=!1){const{props:a,ref:l,patchFlag:m,children:v,transition:y}=e,M=t?wl(a||{},t):a,S={__v_isVNode:!0,__v_skip:!0,type:e.type,props:M,key:M&&da(M),ref:t&&t.ref?i&&l?Z(l)?l.concat($n(t)):[l,$n(t)]:$n(t):l,scopeId:e.scopeId,slotScopeIds:e.slotScopeIds,children:v,target:e.target,targetStart:e.targetStart,targetAnchor:e.targetAnchor,staticCount:e.staticCount,shapeFlag:e.shapeFlag,patchFlag:t&&e.type!==Oe?m===-1?16:m|16:m,dynamicProps:e.dynamicProps,dynamicChildren:e.dynamicChildren,appContext:e.appContext,dirs:e.dirs,transition:y,component:e.component,suspense:e.suspense,ssContent:e.ssContent&&Ut(e.ssContent),ssFallback:e.ssFallback&&Ut(e.ssFallback),el:e.el,anchor:e.anchor,ctx:e.ctx,ce:e.ce};return y&&o&&Qi(S,y.clone(S)),S}function Pi(e=" ",t=0){return Le(Yn,null,e,t)}function Fn(e="",t=!1){return t?(je(),fa(It,null,e)):Le(It,null,e)}function st(e){return e==null||typeof e=="boolean"?Le(It):Z(e)?Le(Oe,null,e.slice()):kn(e)?vt(e):Le(Yn,null,String(e))}function vt(e){return e.el===null&&e.patchFlag!==-1||e.memo?e:Ut(e)}function ts(e,t){let i=0;const{shapeFlag:o}=e;if(t==null)t=null;else if(Z(t))i=16;else if(typeof t=="object")if(o&65){const a=t.default;a&&(a._c&&(a._d=!1),ts(e,a()),a._c&&(a._d=!0));return}else{i=32;const a=t._;!a&&!Jo(t)?t._ctx=Ye:a===3&&Ye&&(Ye.slots._===1?t._=1:(t._=2,e.patchFlag|=1024))}else ne(t)?(t={default:t,_ctx:Ye},i=32):(t=String(t),o&64?(i=16,t=[Pi(t)]):i=8);e.children=t,e.shapeFlag|=i}function wl(...e){const t={};for(let i=0;i<e.length;i++){const o=e[i];for(const a in o)if(a==="class")t.class!==o.class&&(t.class=zn([t.class,o.class]));else if(a==="style")t.style=Li([t.style,o.style]);else if(Dn(a)){const l=t[a],m=o[a];m&&l!==m&&!(Z(l)&&l.includes(m))&&(t[a]=l?[].concat(l,m):m)}else a!==""&&(t[a]=o[a])}return t}function tt(e,t,i,o=null){rt(e,t,7,[i,o])}const Ml=Ko();let Al=0;function Sl(e,t,i){const o=e.type,a=(t?t.appContext:e.appContext)||Ml,l={uid:Al++,vnode:e,type:o,parent:t,appContext:a,root:null,next:null,subTree:null,effect:null,update:null,job:null,scope:new yo(!0),render:null,proxy:null,exposed:null,exposeProxy:null,withProxy:null,provides:t?t.provides:Object.create(a.provides),ids:t?t.ids:["",0,0],accessCache:null,renderCache:[],components:null,directives:null,propsOptions:ea(o,a),emitsOptions:ca(o,a),emit:null,emitted:null,propsDefaults:de,inheritAttrs:o.inheritAttrs,ctx:de,data:de,props:de,attrs:de,slots:de,refs:de,setupState:de,setupContext:null,suspense:i,suspenseId:i?i.pendingId:0,asyncDep:null,asyncResolved:!1,isMounted:!1,isUnmounted:!1,isDeactivated:!1,bc:null,c:null,bm:null,m:null,bu:null,u:null,um:null,bum:null,da:null,a:null,rtg:null,rtc:null,ec:null,sp:null};return l.ctx={_:l},l.root=t?t.root:l,l.emit=fl.bind(null,l),e.ce&&e.ce(l),l}let Re=null,jn,Ti;{const e=po(),t=(i,o)=>{let a;return(a=e[i])||(a=e[i]=[]),a.push(o),l=>{a.length>1?a.forEach(m=>m(l)):a[0](l)}};jn=t("__VUE_INSTANCE_SETTERS__",i=>Re=i),Ti=t("__VUE_SSR_SETTERS__",i=>Xn=i)}const xn=e=>{const t=Re;return jn(e),e.scope.on(),()=>{e.scope.off(),jn(t)}},Ps=()=>{Re&&Re.scope.off(),jn(null)};function pa(e){return e.vnode.shapeFlag&4}let Xn=!1;function Pl(e,t=!1,i=!1){t&&Ti(t);const{props:o,children:a}=e.vnode,l=pa(e);Jr(e,o,l,t),nl(e,a,i);const m=l?Tl(e,t):void 0;return t&&Ti(!1),m}function Tl(e,t){const i=e.type;e.accessCache=Object.create(null),e.proxy=new Proxy(e.ctx,Hr);const{setup:o}=i;if(o){const a=e.setupContext=o.length>1?Fl(e):null,l=xn(e);St();const m=mn(o,e,0,[e.props,a]);if(Pt(),l(),lo(m)){if(en(e)||Wo(e),m.then(Ps,Ps),t)return m.then(v=>{Ts(e,v,t)}).catch(v=>{Hn(v,e,0)});e.asyncDep=m}else Ts(e,m,t)}else ga(e,t)}function Ts(e,t,i){ne(t)?e.type.__ssrInlineRender?e.ssrRender=t:e.render=t:ye(t)&&(e.setupState=Lo(t)),ga(e,i)}let $s;function ga(e,t,i){const o=e.type;if(!e.render){if(!t&&$s&&!o.render){const a=o.template||Zi(e).template;if(a){const{isCustomElement:l,compilerOptions:m}=e.appContext.config,{delimiters:v,compilerOptions:y}=o,M=$e($e({isCustomElement:l,delimiters:v},m),y);o.render=$s(a,M)}}e.render=o.render||ot}{const a=xn(e);St();try{Wr(e)}finally{Pt(),a()}}}const $l={get(e,t){return Ie(e,"get",""),e[t]}};function Fl(e){const t=i=>{e.exposed=i||{}};return{attrs:new Proxy(e.attrs,$l),slots:e.slots,emit:e.emit,expose:t}}function Kn(e){return e.exposed?e.exposeProxy||(e.exposeProxy=new Proxy(Lo(Yi(e.exposed)),{get(t,i){if(i in t)return t[i];if(i in tn)return tn[i](e)},has(t,i){return i in t||i in tn}})):e.proxy}function _l(e){return ne(e)&&"__vccOpts"in e}const Pe=(e,t)=>Mr(e,t,Xn);function ma(e,t,i){const o=arguments.length;return o===2?ye(t)&&!Z(t)?kn(t)?Le(e,null,[t]):Le(e,t):Le(e,null,t):(o>3?i=Array.prototype.slice.call(arguments,2):o===3&&kn(i)&&(i=[i]),Le(e,t,i))}const Cl="3.5.9";/**
* @vue/runtime-dom v3.5.9
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/let $i;const Fs=typeof window<"u"&&window.trustedTypes;if(Fs)try{$i=Fs.createPolicy("vue",{createHTML:e=>e})}catch{}const xa=$i?e=>$i.createHTML(e):e=>e,El="http://www.w3.org/2000/svg",Rl="http://www.w3.org/1998/Math/MathML",ut=typeof document<"u"?document:null,_s=ut&&ut.createElement("template"),Il={insert:(e,t,i)=>{t.insertBefore(e,i||null)},remove:e=>{const t=e.parentNode;t&&t.removeChild(e)},createElement:(e,t,i,o)=>{const a=t==="svg"?ut.createElementNS(El,e):t==="mathml"?ut.createElementNS(Rl,e):i?ut.createElement(e,{is:i}):ut.createElement(e);return e==="select"&&o&&o.multiple!=null&&a.setAttribute("multiple",o.multiple),a},createText:e=>ut.createTextNode(e),createComment:e=>ut.createComment(e),setText:(e,t)=>{e.nodeValue=t},setElementText:(e,t)=>{e.textContent=t},parentNode:e=>e.parentNode,nextSibling:e=>e.nextSibling,querySelector:e=>ut.querySelector(e),setScopeId(e,t){e.setAttribute(t,"")},insertStaticContent(e,t,i,o,a,l){const m=i?i.previousSibling:t.lastChild;if(a&&(a===l||a.nextSibling))for(;t.insertBefore(a.cloneNode(!0),i),!(a===l||!(a=a.nextSibling)););else{_s.innerHTML=xa(o==="svg"?`<svg>${e}</svg>`:o==="mathml"?`<math>${e}</math>`:e);const v=_s.content;if(o==="svg"||o==="mathml"){const y=v.firstChild;for(;y.firstChild;)v.appendChild(y.firstChild);v.removeChild(y)}t.insertBefore(v,i)}return[m?m.nextSibling:t.firstChild,i?i.previousSibling:t.lastChild]}},Vl=Symbol("_vtc");function kl(e,t,i){const o=e[Vl];o&&(t=(t?[t,...o]:[...o]).join(" ")),t==null?e.removeAttribute("class"):i?e.setAttribute("class",t):e.className=t}const Cs=Symbol("_vod"),jl=Symbol("_vsh"),Dl=Symbol(""),Ll=/(^|;)\s*display\s*:/;function Ol(e,t,i){const o=e.style,a=Se(i);let l=!1;if(i&&!a){if(t)if(Se(t))for(const m of t.split(";")){const v=m.slice(0,m.indexOf(":")).trim();i[v]==null&&_n(o,v,"")}else for(const m in t)i[m]==null&&_n(o,m,"");for(const m in i)m==="display"&&(l=!0),_n(o,m,i[m])}else if(a){if(t!==i){const m=o[Dl];m&&(i+=";"+m),o.cssText=i,l=Ll.test(i)}}else t&&e.removeAttribute("style");Cs in e&&(e[Cs]=l?o.display:"",e[jl]&&(o.display="none"))}const Es=/\s*!important$/;function _n(e,t,i){if(Z(i))i.forEach(o=>_n(e,t,o));else if(i==null&&(i=""),t.startsWith("--"))e.setProperty(t,i);else{const o=zl(e,t);Es.test(i)?e.setProperty(Vt(o),i.replace(Es,""),"important"):e[o]=i}}const Rs=["Webkit","Moz","ms"],li={};function zl(e,t){const i=li[t];if(i)return i;let o=Et(t);if(o!=="filter"&&o in e)return li[t]=o;o=ho(o);for(let a=0;a<Rs.length;a++){const l=Rs[a]+o;if(l in e)return li[t]=l}return t}const Is="http://www.w3.org/1999/xlink";function Vs(e,t,i,o,a,l=Ua(t)){o&&t.startsWith("xlink:")?i==null?e.removeAttributeNS(Is,t.slice(6,t.length)):e.setAttributeNS(Is,t,i):i==null||l&&!go(i)?e.removeAttribute(t):e.setAttribute(t,l?"":At(i)?String(i):i)}function ql(e,t,i,o){if(t==="innerHTML"||t==="textContent"){i!=null&&(e[t]=t==="innerHTML"?xa(i):i);return}const a=e.tagName;if(t==="value"&&a!=="PROGRESS"&&!a.includes("-")){const m=a==="OPTION"?e.getAttribute("value")||"":e.value,v=i==null?e.type==="checkbox"?"on":"":String(i);(m!==v||!("_value"in e))&&(e.value=v),i==null&&e.removeAttribute(t),e._value=i;return}let l=!1;if(i===""||i==null){const m=typeof e[t];m==="boolean"?i=go(i):i==null&&m==="string"?(i="",l=!0):m==="number"&&(i=0,l=!0)}try{e[t]=i}catch{}l&&e.removeAttribute(t)}function Lt(e,t,i,o){e.addEventListener(t,i,o)}function Bl(e,t,i,o){e.removeEventListener(t,i,o)}const ks=Symbol("_vei");function Hl(e,t,i,o,a=null){const l=e[ks]||(e[ks]={}),m=l[t];if(o&&m)m.value=o;else{const[v,y]=Wl(t);if(o){const M=l[t]=Yl(o,a);Lt(e,v,M,y)}else m&&(Bl(e,v,m,y),l[t]=void 0)}}const js=/(?:Once|Passive|Capture)$/;function Wl(e){let t;if(js.test(e)){t={};let o;for(;o=e.match(js);)e=e.slice(0,e.length-o[0].length),t[o[0].toLowerCase()]=!0}return[e[2]===":"?e.slice(3):Vt(e.slice(2)),t]}let ci=0;const Ul=Promise.resolve(),Nl=()=>ci||(Ul.then(()=>ci=0),ci=Date.now());function Yl(e,t){const i=o=>{if(!o._vts)o._vts=Date.now();else if(o._vts<=i.attached)return;rt(Xl(o,i.value),t,5,[o])};return i.value=e,i.attached=Nl(),i}function Xl(e,t){if(Z(t)){const i=e.stopImmediatePropagation;return e.stopImmediatePropagation=()=>{i.call(e),e._stopped=!0},t.map(o=>a=>!a._stopped&&o&&o(a))}else return t}const Ds=e=>e.charCodeAt(0)===111&&e.charCodeAt(1)===110&&e.charCodeAt(2)>96&&e.charCodeAt(2)<123,Kl=(e,t,i,o,a,l)=>{const m=a==="svg";t==="class"?kl(e,o,m):t==="style"?Ol(e,i,o):Dn(t)?ki(t)||Hl(e,t,i,o,l):(t[0]==="."?(t=t.slice(1),!0):t[0]==="^"?(t=t.slice(1),!1):Gl(e,t,o,m))?(ql(e,t,o),!e.tagName.includes("-")&&(t==="value"||t==="checked"||t==="selected")&&Vs(e,t,o,m,l,t!=="value")):(t==="true-value"?e._trueValue=o:t==="false-value"&&(e._falseValue=o),Vs(e,t,o,m))};function Gl(e,t,i,o){if(o)return!!(t==="innerHTML"||t==="textContent"||t in e&&Ds(t)&&ne(i));if(t==="spellcheck"||t==="draggable"||t==="translate"||t==="form"||t==="list"&&e.tagName==="INPUT"||t==="type"&&e.tagName==="TEXTAREA")return!1;if(t==="width"||t==="height"){const a=e.tagName;if(a==="IMG"||a==="VIDEO"||a==="CANVAS"||a==="SOURCE")return!1}return Ds(t)&&Se(i)?!1:!!(t in e||e._isVueCE&&(/[A-Z]/.test(t)||!Se(i)))}const Ls=e=>{const t=e.props["onUpdate:modelValue"]||!1;return Z(t)?i=>Pn(t,i):t};function Ql(e){e.target.composing=!0}function Os(e){const t=e.target;t.composing&&(t.composing=!1,t.dispatchEvent(new Event("input")))}const ui=Symbol("_assign"),Jl={created(e,{modifiers:{lazy:t,trim:i,number:o}},a){e[ui]=Ls(a);const l=o||a.props&&a.props.type==="number";Lt(e,t?"change":"input",m=>{if(m.target.composing)return;let v=e.value;i&&(v=v.trim()),l&&(v=gi(v)),e[ui](v)}),i&&Lt(e,"change",()=>{e.value=e.value.trim()}),t||(Lt(e,"compositionstart",Ql),Lt(e,"compositionend",Os),Lt(e,"change",Os))},mounted(e,{value:t}){e.value=t??""},beforeUpdate(e,{value:t,oldValue:i,modifiers:{lazy:o,trim:a,number:l}},m){if(e[ui]=Ls(m),e.composing)return;const v=(l||e.type==="number")&&!/^0\d/.test(e.value)?gi(e.value):e.value,y=t??"";v!==y&&(document.activeElement===e&&e.type!=="range"&&(o&&t===i||a&&e.value.trim()===y)||(e.value=y))}},Zl=$e({patchProp:Kl},Il);let zs;function ec(){return zs||(zs=sl(Zl))}const tc=(...e)=>{const t=ec().createApp(...e),{mount:i}=t;return t.mount=o=>{const a=ic(o);if(!a)return;const l=t._component;!ne(l)&&!l.render&&!l.template&&(l.template=a.innerHTML),a.nodeType===1&&(a.textContent="");const m=i(a,!1,nc(a));return a instanceof Element&&(a.removeAttribute("v-cloak"),a.setAttribute("data-v-app","")),m},t};function nc(e){if(e instanceof SVGElement)return"svg";if(typeof MathMLElement=="function"&&e instanceof MathMLElement)return"mathml"}function ic(e){return Se(e)?document.querySelector(e):e}var sc=!1;/*!
 * pinia v2.2.2
 * (c) 2024 Eduardo San Martin Morote
 * @license MIT
 */let ya;const Gn=e=>ya=e,va=Symbol();function Fi(e){return e&&typeof e=="object"&&Object.prototype.toString.call(e)==="[object Object]"&&typeof e.toJSON!="function"}var sn;(function(e){e.direct="direct",e.patchObject="patch object",e.patchFunction="patch function"})(sn||(sn={}));function oc(){const e=vo(!0),t=e.run(()=>at({}));let i=[],o=[];const a=Yi({install(l){Gn(a),a._a=l,l.provide(va,a),l.config.globalProperties.$pinia=a,o.forEach(m=>i.push(m)),o=[]},use(l){return!this._a&&!sc?o.push(l):i.push(l),this},_p:i,_a:null,_e:e,_s:new Map,state:t});return a}const ba=()=>{};function qs(e,t,i,o=ba){e.push(t);const a=()=>{const l=e.indexOf(t);l>-1&&(e.splice(l,1),o())};return!i&&bo()&&Na(a),a}function jt(e,...t){e.slice().forEach(i=>{i(...t)})}const ac=e=>e(),Bs=Symbol(),hi=Symbol();function _i(e,t){e instanceof Map&&t instanceof Map?t.forEach((i,o)=>e.set(o,i)):e instanceof Set&&t instanceof Set&&t.forEach(e.add,e);for(const i in t){if(!t.hasOwnProperty(i))continue;const o=t[i],a=e[i];Fi(a)&&Fi(o)&&e.hasOwnProperty(i)&&!we(o)&&!wt(o)?e[i]=_i(a,o):e[i]=o}return e}const rc=Symbol();function lc(e){return!Fi(e)||!e.hasOwnProperty(rc)}const{assign:xt}=Object;function cc(e){return!!(we(e)&&e.effect)}function uc(e,t,i,o){const{state:a,actions:l,getters:m}=t,v=i.state.value[e];let y;function M(){v||(i.state.value[e]=a?a():{});const S=yr(i.state.value[e]);return xt(S,l,Object.keys(m||{}).reduce(($,x)=>($[x]=Yi(Pe(()=>{Gn(i);const s=i._s.get(e);return m[x].call(s,s)})),$),{}))}return y=wa(e,M,t,i,o,!0),y}function wa(e,t,i={},o,a,l){let m;const v=xt({actions:{}},i),y={deep:!0};let M,S,$=[],x=[],s;const n=o.state.value[e];!l&&!n&&(o.state.value[e]={}),at({});let f;function d(A){let _;M=S=!1,typeof A=="function"?(A(o.state.value[e]),_={type:sn.patchFunction,storeId:e,events:s}):(_i(o.state.value[e],A),_={type:sn.patchObject,payload:A,storeId:e,events:s});const T=f=Symbol();un().then(()=>{f===T&&(M=!0)}),S=!0,jt($,_,o.state.value[e])}const h=l?function(){const{state:_}=i,T=_?_():{};this.$patch(C=>{xt(C,T)})}:ba;function u(){m.stop(),$=[],x=[],o._s.delete(e)}const c=(A,_="")=>{if(Bs in A)return A[hi]=_,A;const T=function(){Gn(o);const C=Array.from(arguments),j=[],O=[];function k(W){j.push(W)}function ee(W){O.push(W)}jt(x,{args:C,name:T[hi],store:p,after:k,onError:ee});let K;try{K=A.apply(this&&this.$id===e?this:p,C)}catch(W){throw jt(O,W),W}return K instanceof Promise?K.then(W=>(jt(j,W),W)).catch(W=>(jt(O,W),Promise.reject(W))):(jt(j,K),K)};return T[Bs]=!0,T[hi]=_,T},r={_p:o,$id:e,$onAction:qs.bind(null,x),$patch:d,$reset:h,$subscribe(A,_={}){const T=qs($,A,_.detached,()=>C()),C=m.run(()=>Wt(()=>o.state.value[e],j=>{(_.flush==="sync"?S:M)&&A({storeId:e,type:sn.direct,events:s},j)},xt({},y,_)));return T},$dispose:u},p=gn(r);o._s.set(e,p);const b=(o._a&&o._a.runWithContext||ac)(()=>o._e.run(()=>(m=vo()).run(()=>t({action:c}))));for(const A in b){const _=b[A];if(we(_)&&!cc(_)||wt(_))l||(n&&lc(_)&&(we(_)?_.value=n[A]:_i(_,n[A])),o.state.value[e][A]=_);else if(typeof _=="function"){const T=c(_,A);b[A]=T,v.actions[A]=_}}return xt(p,b),xt(oe(p),b),Object.defineProperty(p,"$state",{get:()=>o.state.value[e],set:A=>{d(_=>{xt(_,A)})}}),o._p.forEach(A=>{xt(p,m.run(()=>A({store:p,app:o._a,pinia:o,options:v})))}),n&&l&&i.hydrate&&i.hydrate(p.$state,n),M=!0,S=!0,p}function hc(e,t,i){let o,a;const l=typeof t=="function";o=e,a=l?i:t;function m(v,y){const M=Qr();return v=v||(M?Ge(va,null):null),v&&Gn(v),v=ya,v._s.has(o)||(l?wa(o,t,a,v):uc(o,a,v)),v._s.get(o)}return m.$id=o,m}/*!
  * vue-router v4.4.5
  * (c) 2024 Eduardo San Martin Morote
  * @license MIT
  */const Ot=typeof document<"u";function Ma(e){return typeof e=="object"||"displayName"in e||"props"in e||"__vccOpts"in e}function fc(e){return e.__esModule||e[Symbol.toStringTag]==="Module"||e.default&&Ma(e.default)}const ce=Object.assign;function fi(e,t){const i={};for(const o in t){const a=t[o];i[o]=Ze(a)?a.map(e):e(a)}return i}const on=()=>{},Ze=Array.isArray,Aa=/#/g,dc=/&/g,pc=/\//g,gc=/=/g,mc=/\?/g,Sa=/\+/g,xc=/%5B/g,yc=/%5D/g,Pa=/%5E/g,vc=/%60/g,Ta=/%7B/g,bc=/%7C/g,$a=/%7D/g,wc=/%20/g;function ns(e){return encodeURI(""+e).replace(bc,"|").replace(xc,"[").replace(yc,"]")}function Mc(e){return ns(e).replace(Ta,"{").replace($a,"}").replace(Pa,"^")}function Ci(e){return ns(e).replace(Sa,"%2B").replace(wc,"+").replace(Aa,"%23").replace(dc,"%26").replace(vc,"`").replace(Ta,"{").replace($a,"}").replace(Pa,"^")}function Ac(e){return Ci(e).replace(gc,"%3D")}function Sc(e){return ns(e).replace(Aa,"%23").replace(mc,"%3F")}function Pc(e){return e==null?"":Sc(e).replace(pc,"%2F")}function dn(e){try{return decodeURIComponent(""+e)}catch{}return""+e}const Tc=/\/$/,$c=e=>e.replace(Tc,"");function di(e,t,i="/"){let o,a={},l="",m="";const v=t.indexOf("#");let y=t.indexOf("?");return v<y&&v>=0&&(y=-1),y>-1&&(o=t.slice(0,y),l=t.slice(y+1,v>-1?v:t.length),a=e(l)),v>-1&&(o=o||t.slice(0,v),m=t.slice(v,t.length)),o=Ec(o??t,i),{fullPath:o+(l&&"?")+l+m,path:o,query:a,hash:dn(m)}}function Fc(e,t){const i=t.query?e(t.query):"";return t.path+(i&&"?")+i+(t.hash||"")}function Hs(e,t){return!t||!e.toLowerCase().startsWith(t.toLowerCase())?e:e.slice(t.length)||"/"}function _c(e,t,i){const o=t.matched.length-1,a=i.matched.length-1;return o>-1&&o===a&&Nt(t.matched[o],i.matched[a])&&Fa(t.params,i.params)&&e(t.query)===e(i.query)&&t.hash===i.hash}function Nt(e,t){return(e.aliasOf||e)===(t.aliasOf||t)}function Fa(e,t){if(Object.keys(e).length!==Object.keys(t).length)return!1;for(const i in e)if(!Cc(e[i],t[i]))return!1;return!0}function Cc(e,t){return Ze(e)?Ws(e,t):Ze(t)?Ws(t,e):e===t}function Ws(e,t){return Ze(t)?e.length===t.length&&e.every((i,o)=>i===t[o]):e.length===1&&e[0]===t}function Ec(e,t){if(e.startsWith("/"))return e;if(!e)return t;const i=t.split("/"),o=e.split("/"),a=o[o.length-1];(a===".."||a===".")&&o.push("");let l=i.length-1,m,v;for(m=0;m<o.length;m++)if(v=o[m],v!==".")if(v==="..")l>1&&l--;else break;return i.slice(0,l).join("/")+"/"+o.slice(m).join("/")}const mt={path:"/",name:void 0,params:{},query:{},hash:"",fullPath:"/",matched:[],meta:{},redirectedFrom:void 0};var pn;(function(e){e.pop="pop",e.push="push"})(pn||(pn={}));var an;(function(e){e.back="back",e.forward="forward",e.unknown=""})(an||(an={}));function Rc(e){if(!e)if(Ot){const t=document.querySelector("base");e=t&&t.getAttribute("href")||"/",e=e.replace(/^\w+:\/\/[^\/]+/,"")}else e="/";return e[0]!=="/"&&e[0]!=="#"&&(e="/"+e),$c(e)}const Ic=/^[^#]+#/;function Vc(e,t){return e.replace(Ic,"#")+t}function kc(e,t){const i=document.documentElement.getBoundingClientRect(),o=e.getBoundingClientRect();return{behavior:t.behavior,left:o.left-i.left-(t.left||0),top:o.top-i.top-(t.top||0)}}const Qn=()=>({left:window.scrollX,top:window.scrollY});function jc(e){let t;if("el"in e){const i=e.el,o=typeof i=="string"&&i.startsWith("#"),a=typeof i=="string"?o?document.getElementById(i.slice(1)):document.querySelector(i):i;if(!a)return;t=kc(a,e)}else t=e;"scrollBehavior"in document.documentElement.style?window.scrollTo(t):window.scrollTo(t.left!=null?t.left:window.scrollX,t.top!=null?t.top:window.scrollY)}function Us(e,t){return(history.state?history.state.position-t:-1)+e}const Ei=new Map;function Dc(e,t){Ei.set(e,t)}function Lc(e){const t=Ei.get(e);return Ei.delete(e),t}let Oc=()=>location.protocol+"//"+location.host;function _a(e,t){const{pathname:i,search:o,hash:a}=t,l=e.indexOf("#");if(l>-1){let v=a.includes(e.slice(l))?e.slice(l).length:1,y=a.slice(v);return y[0]!=="/"&&(y="/"+y),Hs(y,"")}return Hs(i,e)+o+a}function zc(e,t,i,o){let a=[],l=[],m=null;const v=({state:x})=>{const s=_a(e,location),n=i.value,f=t.value;let d=0;if(x){if(i.value=s,t.value=x,m&&m===n){m=null;return}d=f?x.position-f.position:0}else o(s);a.forEach(h=>{h(i.value,n,{delta:d,type:pn.pop,direction:d?d>0?an.forward:an.back:an.unknown})})};function y(){m=i.value}function M(x){a.push(x);const s=()=>{const n=a.indexOf(x);n>-1&&a.splice(n,1)};return l.push(s),s}function S(){const{history:x}=window;x.state&&x.replaceState(ce({},x.state,{scroll:Qn()}),"")}function $(){for(const x of l)x();l=[],window.removeEventListener("popstate",v),window.removeEventListener("beforeunload",S)}return window.addEventListener("popstate",v),window.addEventListener("beforeunload",S,{passive:!0}),{pauseListeners:y,listen:M,destroy:$}}function Ns(e,t,i,o=!1,a=!1){return{back:e,current:t,forward:i,replaced:o,position:window.history.length,scroll:a?Qn():null}}function qc(e){const{history:t,location:i}=window,o={value:_a(e,i)},a={value:t.state};a.value||l(o.value,{back:null,current:o.value,forward:null,position:t.length-1,replaced:!0,scroll:null},!0);function l(y,M,S){const $=e.indexOf("#"),x=$>-1?(i.host&&document.querySelector("base")?e:e.slice($))+y:Oc()+e+y;try{t[S?"replaceState":"pushState"](M,"",x),a.value=M}catch(s){console.error(s),i[S?"replace":"assign"](x)}}function m(y,M){const S=ce({},t.state,Ns(a.value.back,y,a.value.forward,!0),M,{position:a.value.position});l(y,S,!0),o.value=y}function v(y,M){const S=ce({},a.value,t.state,{forward:y,scroll:Qn()});l(S.current,S,!0);const $=ce({},Ns(o.value,y,null),{position:S.position+1},M);l(y,$,!1),o.value=y}return{location:o,state:a,push:v,replace:m}}function Bc(e){e=Rc(e);const t=qc(e),i=zc(e,t.state,t.location,t.replace);function o(l,m=!0){m||i.pauseListeners(),history.go(l)}const a=ce({location:"",base:e,go:o,createHref:Vc.bind(null,e)},t,i);return Object.defineProperty(a,"location",{enumerable:!0,get:()=>t.location.value}),Object.defineProperty(a,"state",{enumerable:!0,get:()=>t.state.value}),a}function Hc(e){return typeof e=="string"||e&&typeof e=="object"}function Ca(e){return typeof e=="string"||typeof e=="symbol"}const Ea=Symbol("");var Ys;(function(e){e[e.aborted=4]="aborted",e[e.cancelled=8]="cancelled",e[e.duplicated=16]="duplicated"})(Ys||(Ys={}));function Yt(e,t){return ce(new Error,{type:e,[Ea]:!0},t)}function ct(e,t){return e instanceof Error&&Ea in e&&(t==null||!!(e.type&t))}const Xs="[^/]+?",Wc={sensitive:!1,strict:!1,start:!0,end:!0},Uc=/[.+*?^${}()[\]/\\]/g;function Nc(e,t){const i=ce({},Wc,t),o=[];let a=i.start?"^":"";const l=[];for(const M of e){const S=M.length?[]:[90];i.strict&&!M.length&&(a+="/");for(let $=0;$<M.length;$++){const x=M[$];let s=40+(i.sensitive?.25:0);if(x.type===0)$||(a+="/"),a+=x.value.replace(Uc,"\\$&"),s+=40;else if(x.type===1){const{value:n,repeatable:f,optional:d,regexp:h}=x;l.push({name:n,repeatable:f,optional:d});const u=h||Xs;if(u!==Xs){s+=10;try{new RegExp(`(${u})`)}catch(r){throw new Error(`Invalid custom RegExp for param "${n}" (${u}): `+r.message)}}let c=f?`((?:${u})(?:/(?:${u}))*)`:`(${u})`;$||(c=d&&M.length<2?`(?:/${c})`:"/"+c),d&&(c+="?"),a+=c,s+=20,d&&(s+=-8),f&&(s+=-20),u===".*"&&(s+=-50)}S.push(s)}o.push(S)}if(i.strict&&i.end){const M=o.length-1;o[M][o[M].length-1]+=.7000000000000001}i.strict||(a+="/?"),i.end?a+="$":i.strict&&(a+="(?:/|$)");const m=new RegExp(a,i.sensitive?"":"i");function v(M){const S=M.match(m),$={};if(!S)return null;for(let x=1;x<S.length;x++){const s=S[x]||"",n=l[x-1];$[n.name]=s&&n.repeatable?s.split("/"):s}return $}function y(M){let S="",$=!1;for(const x of e){(!$||!S.endsWith("/"))&&(S+="/"),$=!1;for(const s of x)if(s.type===0)S+=s.value;else if(s.type===1){const{value:n,repeatable:f,optional:d}=s,h=n in M?M[n]:"";if(Ze(h)&&!f)throw new Error(`Provided param "${n}" is an array but it is not repeatable (* or + modifiers)`);const u=Ze(h)?h.join("/"):h;if(!u)if(d)x.length<2&&(S.endsWith("/")?S=S.slice(0,-1):$=!0);else throw new Error(`Missing required param "${n}"`);S+=u}}return S||"/"}return{re:m,score:o,keys:l,parse:v,stringify:y}}function Yc(e,t){let i=0;for(;i<e.length&&i<t.length;){const o=t[i]-e[i];if(o)return o;i++}return e.length<t.length?e.length===1&&e[0]===80?-1:1:e.length>t.length?t.length===1&&t[0]===80?1:-1:0}function Ra(e,t){let i=0;const o=e.score,a=t.score;for(;i<o.length&&i<a.length;){const l=Yc(o[i],a[i]);if(l)return l;i++}if(Math.abs(a.length-o.length)===1){if(Ks(o))return 1;if(Ks(a))return-1}return a.length-o.length}function Ks(e){const t=e[e.length-1];return e.length>0&&t[t.length-1]<0}const Xc={type:0,value:""},Kc=/[a-zA-Z0-9_]/;function Gc(e){if(!e)return[[]];if(e==="/")return[[Xc]];if(!e.startsWith("/"))throw new Error(`Invalid path "${e}"`);function t(s){throw new Error(`ERR (${i})/"${M}": ${s}`)}let i=0,o=i;const a=[];let l;function m(){l&&a.push(l),l=[]}let v=0,y,M="",S="";function $(){M&&(i===0?l.push({type:0,value:M}):i===1||i===2||i===3?(l.length>1&&(y==="*"||y==="+")&&t(`A repeatable param (${M}) must be alone in its segment. eg: '/:ids+.`),l.push({type:1,value:M,regexp:S,repeatable:y==="*"||y==="+",optional:y==="*"||y==="?"})):t("Invalid state to consume buffer"),M="")}function x(){M+=y}for(;v<e.length;){if(y=e[v++],y==="\\"&&i!==2){o=i,i=4;continue}switch(i){case 0:y==="/"?(M&&$(),m()):y===":"?($(),i=1):x();break;case 4:x(),i=o;break;case 1:y==="("?i=2:Kc.test(y)?x():($(),i=0,y!=="*"&&y!=="?"&&y!=="+"&&v--);break;case 2:y===")"?S[S.length-1]=="\\"?S=S.slice(0,-1)+y:i=3:S+=y;break;case 3:$(),i=0,y!=="*"&&y!=="?"&&y!=="+"&&v--,S="";break;default:t("Unknown state");break}}return i===2&&t(`Unfinished custom RegExp for param "${M}"`),$(),m(),a}function Qc(e,t,i){const o=Nc(Gc(e.path),i),a=ce(o,{record:e,parent:t,children:[],alias:[]});return t&&!a.record.aliasOf==!t.record.aliasOf&&t.children.push(a),a}function Jc(e,t){const i=[],o=new Map;t=Zs({strict:!1,end:!0,sensitive:!1},t);function a($){return o.get($)}function l($,x,s){const n=!s,f=Qs($);f.aliasOf=s&&s.record;const d=Zs(t,$),h=[f];if("alias"in $){const r=typeof $.alias=="string"?[$.alias]:$.alias;for(const p of r)h.push(Qs(ce({},f,{components:s?s.record.components:f.components,path:p,aliasOf:s?s.record:f})))}let u,c;for(const r of h){const{path:p}=r;if(x&&p[0]!=="/"){const F=x.record.path,b=F[F.length-1]==="/"?"":"/";r.path=x.record.path+(p&&b+p)}if(u=Qc(r,x,d),s?s.alias.push(u):(c=c||u,c!==u&&c.alias.push(u),n&&$.name&&!Js(u)&&m($.name)),Ia(u)&&y(u),f.children){const F=f.children;for(let b=0;b<F.length;b++)l(F[b],u,s&&s.children[b])}s=s||u}return c?()=>{m(c)}:on}function m($){if(Ca($)){const x=o.get($);x&&(o.delete($),i.splice(i.indexOf(x),1),x.children.forEach(m),x.alias.forEach(m))}else{const x=i.indexOf($);x>-1&&(i.splice(x,1),$.record.name&&o.delete($.record.name),$.children.forEach(m),$.alias.forEach(m))}}function v(){return i}function y($){const x=tu($,i);i.splice(x,0,$),$.record.name&&!Js($)&&o.set($.record.name,$)}function M($,x){let s,n={},f,d;if("name"in $&&$.name){if(s=o.get($.name),!s)throw Yt(1,{location:$});d=s.record.name,n=ce(Gs(x.params,s.keys.filter(c=>!c.optional).concat(s.parent?s.parent.keys.filter(c=>c.optional):[]).map(c=>c.name)),$.params&&Gs($.params,s.keys.map(c=>c.name))),f=s.stringify(n)}else if($.path!=null)f=$.path,s=i.find(c=>c.re.test(f)),s&&(n=s.parse(f),d=s.record.name);else{if(s=x.name?o.get(x.name):i.find(c=>c.re.test(x.path)),!s)throw Yt(1,{location:$,currentLocation:x});d=s.record.name,n=ce({},x.params,$.params),f=s.stringify(n)}const h=[];let u=s;for(;u;)h.unshift(u.record),u=u.parent;return{name:d,path:f,params:n,matched:h,meta:eu(h)}}e.forEach($=>l($));function S(){i.length=0,o.clear()}return{addRoute:l,resolve:M,removeRoute:m,clearRoutes:S,getRoutes:v,getRecordMatcher:a}}function Gs(e,t){const i={};for(const o of t)o in e&&(i[o]=e[o]);return i}function Qs(e){const t={path:e.path,redirect:e.redirect,name:e.name,meta:e.meta||{},aliasOf:e.aliasOf,beforeEnter:e.beforeEnter,props:Zc(e),children:e.children||[],instances:{},leaveGuards:new Set,updateGuards:new Set,enterCallbacks:{},components:"components"in e?e.components||null:e.component&&{default:e.component}};return Object.defineProperty(t,"mods",{value:{}}),t}function Zc(e){const t={},i=e.props||!1;if("component"in e)t.default=i;else for(const o in e.components)t[o]=typeof i=="object"?i[o]:i;return t}function Js(e){for(;e;){if(e.record.aliasOf)return!0;e=e.parent}return!1}function eu(e){return e.reduce((t,i)=>ce(t,i.meta),{})}function Zs(e,t){const i={};for(const o in e)i[o]=o in t?t[o]:e[o];return i}function tu(e,t){let i=0,o=t.length;for(;i!==o;){const l=i+o>>1;Ra(e,t[l])<0?o=l:i=l+1}const a=nu(e);return a&&(o=t.lastIndexOf(a,o-1)),o}function nu(e){let t=e;for(;t=t.parent;)if(Ia(t)&&Ra(e,t)===0)return t}function Ia({record:e}){return!!(e.name||e.components&&Object.keys(e.components).length||e.redirect)}function iu(e){const t={};if(e===""||e==="?")return t;const o=(e[0]==="?"?e.slice(1):e).split("&");for(let a=0;a<o.length;++a){const l=o[a].replace(Sa," "),m=l.indexOf("="),v=dn(m<0?l:l.slice(0,m)),y=m<0?null:dn(l.slice(m+1));if(v in t){let M=t[v];Ze(M)||(M=t[v]=[M]),M.push(y)}else t[v]=y}return t}function eo(e){let t="";for(let i in e){const o=e[i];if(i=Ac(i),o==null){o!==void 0&&(t+=(t.length?"&":"")+i);continue}(Ze(o)?o.map(l=>l&&Ci(l)):[o&&Ci(o)]).forEach(l=>{l!==void 0&&(t+=(t.length?"&":"")+i,l!=null&&(t+="="+l))})}return t}function su(e){const t={};for(const i in e){const o=e[i];o!==void 0&&(t[i]=Ze(o)?o.map(a=>a==null?null:""+a):o==null?o:""+o)}return t}const ou=Symbol(""),to=Symbol(""),Jn=Symbol(""),is=Symbol(""),Ri=Symbol("");function Qt(){let e=[];function t(o){return e.push(o),()=>{const a=e.indexOf(o);a>-1&&e.splice(a,1)}}function i(){e=[]}return{add:t,list:()=>e.slice(),reset:i}}function bt(e,t,i,o,a,l=m=>m()){const m=o&&(o.enterCallbacks[a]=o.enterCallbacks[a]||[]);return()=>new Promise((v,y)=>{const M=x=>{x===!1?y(Yt(4,{from:i,to:t})):x instanceof Error?y(x):Hc(x)?y(Yt(2,{from:t,to:x})):(m&&o.enterCallbacks[a]===m&&typeof x=="function"&&m.push(x),v())},S=l(()=>e.call(o&&o.instances[a],t,i,M));let $=Promise.resolve(S);e.length<3&&($=$.then(M)),$.catch(x=>y(x))})}function pi(e,t,i,o,a=l=>l()){const l=[];for(const m of e)for(const v in m.components){let y=m.components[v];if(!(t!=="beforeRouteEnter"&&!m.instances[v]))if(Ma(y)){const S=(y.__vccOpts||y)[t];S&&l.push(bt(S,i,o,m,v,a))}else{let M=y();l.push(()=>M.then(S=>{if(!S)throw new Error(`Couldn't resolve component "${v}" at "${m.path}"`);const $=fc(S)?S.default:S;m.mods[v]=S,m.components[v]=$;const s=($.__vccOpts||$)[t];return s&&bt(s,i,o,m,v,a)()}))}}return l}function no(e){const t=Ge(Jn),i=Ge(is),o=Pe(()=>{const y=dt(e.to);return t.resolve(y)}),a=Pe(()=>{const{matched:y}=o.value,{length:M}=y,S=y[M-1],$=i.matched;if(!S||!$.length)return-1;const x=$.findIndex(Nt.bind(null,S));if(x>-1)return x;const s=io(y[M-2]);return M>1&&io(S)===s&&$[$.length-1].path!==s?$.findIndex(Nt.bind(null,y[M-2])):x}),l=Pe(()=>a.value>-1&&lu(i.params,o.value.params)),m=Pe(()=>a.value>-1&&a.value===i.matched.length-1&&Fa(i.params,o.value.params));function v(y={}){return ru(y)?t[dt(e.replace)?"replace":"push"](dt(e.to)).catch(on):Promise.resolve()}return{route:o,href:Pe(()=>o.value.href),isActive:l,isExactActive:m,navigate:v}}const au=Wn({name:"RouterLink",compatConfig:{MODE:3},props:{to:{type:[String,Object],required:!0},replace:Boolean,activeClass:String,exactActiveClass:String,custom:Boolean,ariaCurrentValue:{type:String,default:"page"}},useLink:no,setup(e,{slots:t}){const i=gn(no(e)),{options:o}=Ge(Jn),a=Pe(()=>({[so(e.activeClass,o.linkActiveClass,"router-link-active")]:i.isActive,[so(e.exactActiveClass,o.linkExactActiveClass,"router-link-exact-active")]:i.isExactActive}));return()=>{const l=t.default&&t.default(i);return e.custom?l:ma("a",{"aria-current":i.isExactActive?e.ariaCurrentValue:null,href:i.href,onClick:i.navigate,class:a.value},l)}}}),Ii=au;function ru(e){if(!(e.metaKey||e.altKey||e.ctrlKey||e.shiftKey)&&!e.defaultPrevented&&!(e.button!==void 0&&e.button!==0)){if(e.currentTarget&&e.currentTarget.getAttribute){const t=e.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(t))return}return e.preventDefault&&e.preventDefault(),!0}}function lu(e,t){for(const i in t){const o=t[i],a=e[i];if(typeof o=="string"){if(o!==a)return!1}else if(!Ze(a)||a.length!==o.length||o.some((l,m)=>l!==a[m]))return!1}return!0}function io(e){return e?e.aliasOf?e.aliasOf.path:e.path:""}const so=(e,t,i)=>e??t??i,cu=Wn({name:"RouterView",inheritAttrs:!1,props:{name:{type:String,default:"default"},route:Object},compatConfig:{MODE:3},setup(e,{attrs:t,slots:i}){const o=Ge(Ri),a=Pe(()=>e.route||o.value),l=Ge(to,0),m=Pe(()=>{let M=dt(l);const{matched:S}=a.value;let $;for(;($=S[M])&&!$.components;)M++;return M}),v=Pe(()=>a.value.matched[m.value]);Tn(to,Pe(()=>m.value+1)),Tn(ou,v),Tn(Ri,a);const y=at();return Wt(()=>[y.value,v.value,e.name],([M,S,$],[x,s,n])=>{S&&(S.instances[$]=M,s&&s!==S&&M&&M===x&&(S.leaveGuards.size||(S.leaveGuards=s.leaveGuards),S.updateGuards.size||(S.updateGuards=s.updateGuards))),M&&S&&(!s||!Nt(S,s)||!x)&&(S.enterCallbacks[$]||[]).forEach(f=>f(M))},{flush:"post"}),()=>{const M=a.value,S=e.name,$=v.value,x=$&&$.components[S];if(!x)return oo(i.default,{Component:x,route:M});const s=$.props[S],n=s?s===!0?M.params:typeof s=="function"?s(M):s:null,d=ma(x,ce({},n,t,{onVnodeUnmounted:h=>{h.component.isUnmounted&&($.instances[S]=null)},ref:y}));return oo(i.default,{Component:d,route:M})||d}}});function oo(e,t){if(!e)return null;const i=e(t);return i.length===1?i[0]:i}const Va=cu;function uu(e){const t=Jc(e.routes,e),i=e.parseQuery||iu,o=e.stringifyQuery||eo,a=e.history,l=Qt(),m=Qt(),v=Qt(),y=gr(mt);let M=mt;Ot&&e.scrollBehavior&&"scrollRestoration"in history&&(history.scrollRestoration="manual");const S=fi.bind(null,I=>""+I),$=fi.bind(null,Pc),x=fi.bind(null,dn);function s(I,U){let B,X;return Ca(I)?(B=t.getRecordMatcher(I),X=U):X=I,t.addRoute(X,B)}function n(I){const U=t.getRecordMatcher(I);U&&t.removeRoute(U)}function f(){return t.getRoutes().map(I=>I.record)}function d(I){return!!t.getRecordMatcher(I)}function h(I,U){if(U=ce({},U||y.value),typeof I=="string"){const P=di(i,I,U.path),E=t.resolve({path:P.path},U),D=a.createHref(P.fullPath);return ce(P,E,{params:x(E.params),hash:dn(P.hash),redirectedFrom:void 0,href:D})}let B;if(I.path!=null)B=ce({},I,{path:di(i,I.path,U.path).path});else{const P=ce({},I.params);for(const E in P)P[E]==null&&delete P[E];B=ce({},I,{params:$(P)}),U.params=$(U.params)}const X=t.resolve(B,U),se=I.hash||"";X.params=S(x(X.params));const xe=Fc(o,ce({},I,{hash:Mc(se),path:X.path})),w=a.createHref(xe);return ce({fullPath:xe,hash:se,query:o===eo?su(I.query):I.query||{}},X,{redirectedFrom:void 0,href:w})}function u(I){return typeof I=="string"?di(i,I,y.value.path):ce({},I)}function c(I,U){if(M!==I)return Yt(8,{from:U,to:I})}function r(I){return b(I)}function p(I){return r(ce(u(I),{replace:!0}))}function F(I){const U=I.matched[I.matched.length-1];if(U&&U.redirect){const{redirect:B}=U;let X=typeof B=="function"?B(I):B;return typeof X=="string"&&(X=X.includes("?")||X.includes("#")?X=u(X):{path:X},X.params={}),ce({query:I.query,hash:I.hash,params:X.path!=null?{}:I.params},X)}}function b(I,U){const B=M=h(I),X=y.value,se=I.state,xe=I.force,w=I.replace===!0,P=F(B);if(P)return b(ce(u(P),{state:typeof P=="object"?ce({},se,P.state):se,force:xe,replace:w}),U||B);const E=B;E.redirectedFrom=U;let D;return!xe&&_c(o,X,B)&&(D=Yt(16,{to:E,from:X}),fe(X,X,!0,!1)),(D?Promise.resolve(D):T(E,X)).catch(V=>ct(V)?ct(V,2)?V:ve(V):G(V,E,X)).then(V=>{if(V){if(ct(V,2))return b(ce({replace:w},u(V.to),{state:typeof V.to=="object"?ce({},se,V.to.state):se,force:xe}),U||E)}else V=j(E,X,!0,w,se);return C(E,X,V),V})}function A(I,U){const B=c(I,U);return B?Promise.reject(B):Promise.resolve()}function _(I){const U=Te.values().next().value;return U&&typeof U.runWithContext=="function"?U.runWithContext(I):I()}function T(I,U){let B;const[X,se,xe]=hu(I,U);B=pi(X.reverse(),"beforeRouteLeave",I,U);for(const P of X)P.leaveGuards.forEach(E=>{B.push(bt(E,I,U))});const w=A.bind(null,I,U);return B.push(w),Me(B).then(()=>{B=[];for(const P of l.list())B.push(bt(P,I,U));return B.push(w),Me(B)}).then(()=>{B=pi(se,"beforeRouteUpdate",I,U);for(const P of se)P.updateGuards.forEach(E=>{B.push(bt(E,I,U))});return B.push(w),Me(B)}).then(()=>{B=[];for(const P of xe)if(P.beforeEnter)if(Ze(P.beforeEnter))for(const E of P.beforeEnter)B.push(bt(E,I,U));else B.push(bt(P.beforeEnter,I,U));return B.push(w),Me(B)}).then(()=>(I.matched.forEach(P=>P.enterCallbacks={}),B=pi(xe,"beforeRouteEnter",I,U,_),B.push(w),Me(B))).then(()=>{B=[];for(const P of m.list())B.push(bt(P,I,U));return B.push(w),Me(B)}).catch(P=>ct(P,8)?P:Promise.reject(P))}function C(I,U,B){v.list().forEach(X=>_(()=>X(I,U,B)))}function j(I,U,B,X,se){const xe=c(I,U);if(xe)return xe;const w=U===mt,P=Ot?history.state:{};B&&(X||w?a.replace(I.fullPath,ce({scroll:w&&P&&P.scroll},se)):a.push(I.fullPath,se)),y.value=I,fe(I,U,B,w),ve()}let O;function k(){O||(O=a.listen((I,U,B)=>{if(!Fe.listening)return;const X=h(I),se=F(X);if(se){b(ce(se,{replace:!0}),X).catch(on);return}M=X;const xe=y.value;Ot&&Dc(Us(xe.fullPath,B.delta),Qn()),T(X,xe).catch(w=>ct(w,12)?w:ct(w,2)?(b(w.to,X).then(P=>{ct(P,20)&&!B.delta&&B.type===pn.pop&&a.go(-1,!1)}).catch(on),Promise.reject()):(B.delta&&a.go(-B.delta,!1),G(w,X,xe))).then(w=>{w=w||j(X,xe,!1),w&&(B.delta&&!ct(w,8)?a.go(-B.delta,!1):B.type===pn.pop&&ct(w,20)&&a.go(-1,!1)),C(X,xe,w)}).catch(on)}))}let ee=Qt(),K=Qt(),W;function G(I,U,B){ve(I);const X=K.list();return X.length?X.forEach(se=>se(I,U,B)):console.error(I),Promise.reject(I)}function me(){return W&&y.value!==mt?Promise.resolve():new Promise((I,U)=>{ee.add([I,U])})}function ve(I){return W||(W=!I,k(),ee.list().forEach(([U,B])=>I?B(I):U()),ee.reset()),I}function fe(I,U,B,X){const{scrollBehavior:se}=e;if(!Ot||!se)return Promise.resolve();const xe=!B&&Lc(Us(I.fullPath,0))||(X||!B)&&history.state&&history.state.scroll||null;return un().then(()=>se(I,U,xe)).then(w=>w&&jc(w)).catch(w=>G(w,I,U))}const ue=I=>a.go(I);let be;const Te=new Set,Fe={currentRoute:y,listening:!0,addRoute:s,removeRoute:n,clearRoutes:t.clearRoutes,hasRoute:d,getRoutes:f,resolve:h,options:e,push:r,replace:p,go:ue,back:()=>ue(-1),forward:()=>ue(1),beforeEach:l.add,beforeResolve:m.add,afterEach:v.add,onError:K.add,isReady:me,install(I){const U=this;I.component("RouterLink",Ii),I.component("RouterView",Va),I.config.globalProperties.$router=U,Object.defineProperty(I.config.globalProperties,"$route",{enumerable:!0,get:()=>dt(y)}),Ot&&!be&&y.value===mt&&(be=!0,r(a.location).catch(se=>{}));const B={};for(const se in mt)Object.defineProperty(B,se,{get:()=>y.value[se],enumerable:!0});I.provide(Jn,U),I.provide(is,ko(B)),I.provide(Ri,y);const X=I.unmount;Te.add(I),I.unmount=function(){Te.delete(I),Te.size<1&&(M=mt,O&&O(),O=null,y.value=mt,be=!1,W=!1),X()}}};function Me(I){return I.reduce((U,B)=>U.then(()=>_(B)),Promise.resolve())}return Fe}function hu(e,t){const i=[],o=[],a=[],l=Math.max(t.matched.length,e.matched.length);for(let m=0;m<l;m++){const v=t.matched[m];v&&(e.matched.find(M=>Nt(M,v))?o.push(v):i.push(v));const y=e.matched[m];y&&(t.matched.find(M=>Nt(M,y))||a.push(y))}return[i,o,a]}function fu(){return Ge(Jn)}function du(e){return Ge(is)}const ss=hc("lessons",()=>{const e=at([]),t=at(null),i=at(null),o=Pe(()=>e.value.find(y=>y.id===t.value)),a=Pe(()=>{var y;return(y=o.value)==null?void 0:y.sublessons.find(M=>M.id===i.value)});function l(y){var M;t.value=y,i.value=((M=o.value)==null?void 0:M.sublessons[0].id)||null}function m(y){i.value=y}function v(y){e.value.push(y)}return{lessons:e,currentLessonId:t,currentSublessonId:i,currentLesson:o,currentSublesson:a,setCurrentLesson:l,setCurrentSublesson:m,addLesson:v}}),pu=["onClick"],gu={class:"expand-icon"},mu={key:0,class:"sublesson-group"},xu=Wn({__name:"App",setup(e){const t=ss(),i=Pe(()=>t.lessons),o=at([]);function a(m){const v=o.value.indexOf(m);v===-1?o.value.push(m):o.value.splice(v,1)}function l(m){return o.value.includes(m)}return(m,v)=>(je(),Ue(Oe,null,[Ce("nav",null,[(je(!0),Ue(Oe,null,In(i.value,y=>(je(),Ue("div",{key:y.id,class:"lesson-group"},[Ce("div",{onClick:M=>a(y.id),class:"lesson-header"},[Le(dt(Ii),{to:{name:"lesson",params:{id:y.id}}},{default:vi(()=>[Pi(" Lesson "+Ne(y.id)+": "+Ne(y.title),1)]),_:2},1032,["to"]),Ce("span",gu,Ne(l(y.id)?"":""),1)],8,pu),l(y.id)?(je(),Ue("div",mu,[(je(!0),Ue(Oe,null,In(y.sublessons,M=>(je(),fa(dt(Ii),{key:M.id,to:{name:"lesson",params:{id:y.id,sublessonId:M.id}},class:"sublesson-link"},{default:vi(()=>[Pi(Ne(y.id)+"."+Ne(M.id)+": "+Ne(M.title),1)]),_:2},1032,["to"]))),128))])):Fn("",!0)]))),128))]),Le(dt(Va))],64))}}),os=(e,t)=>{const i=e.__vccOpts||e;for(const[o,a]of t)i[o]=a;return i},yu=os(xu,[["__scopeId","data-v-0f486e2f"]]),vu="modulepreload",bu=function(e){return"/idgTrig/"+e},ao={},wu=function(t,i,o){let a=Promise.resolve();if(i&&i.length>0){document.getElementsByTagName("link");const m=document.querySelector("meta[property=csp-nonce]"),v=(m==null?void 0:m.nonce)||(m==null?void 0:m.getAttribute("nonce"));a=Promise.allSettled(i.map(y=>{if(y=bu(y),y in ao)return;ao[y]=!0;const M=y.endsWith(".css"),S=M?'[rel="stylesheet"]':"";if(document.querySelector(`link[href="${y}"]${S}`))return;const $=document.createElement("link");if($.rel=M?"stylesheet":vu,M||($.as="script"),$.crossOrigin="",$.href=y,v&&$.setAttribute("nonce",v),document.head.appendChild($),M)return new Promise((x,s)=>{$.addEventListener("load",x),$.addEventListener("error",()=>s(new Error(`Unable to preload CSS for ${y}`)))})}))}function l(m){const v=new Event("vite:preloadError",{cancelable:!0});if(v.payload=m,window.dispatchEvent(v),!v.defaultPrevented)throw m}return a.then(m=>{for(const v of m||[])v.status==="rejected"&&l(v.reason);return t().catch(l)})},Mu={};function Au(e,t){return je(),Ue("main")}const Su=os(Mu,[["render",Au]]),Pu={key:0,class:"lesson-view"},Tu=["innerHTML"],$u={class:"sublesson-nav"},Fu=["onClick"],_u={key:0,class:"sublesson-content"},Cu=["innerHTML"],Eu={class:"visualization-wrapper"},Ru={key:0,class:"sliders-container"},Iu=["for"],Vu=["id","min","max","step","onUpdate:modelValue"],ku={class:"slider-value"},ju={class:"slider-explanation"},Du=Wn({__name:"LessonView",setup(e){const t=du(),i=fu(),o=ss(),a=at({}),l=Pe(()=>parseInt(t.params.id)),m=Pe(()=>t.params.sublessonId),v=Pe(()=>(o.setCurrentLesson(l.value),o.currentLesson)),y=Pe(()=>{if(v.value&&m.value)return o.setCurrentSublesson(m.value),o.currentSublesson}),M=at(null);at(null);let S=null,$=null;function x(){if(y.value&&M.value){M.value.firstChild&&M.value.removeChild(M.value.firstChild);const f=y.value.visualizations[0];$=f.setup(a.value),M.value.appendChild($.canvas);const d=()=>{$&&f.update({...$,...a.value}),S=requestAnimationFrame(d)};d()}}function s(){S!==null&&(cancelAnimationFrame(S),S=null),M.value&&M.value.firstChild&&M.value.removeChild(M.value.firstChild)}Wt([v,y],([f,d],[h,u])=>{(f!==h||d!==u)&&(s(),a.value={},d!=null&&d.sliders&&d.sliders.forEach(c=>{a.value[c.id]=c.defaultValue}),un(()=>{x()}))},{immediate:!0}),Yo(()=>{var f,d;!m.value&&((f=v.value)==null?void 0:f.sublessons.length)>0&&i.replace({params:{...t.params,sublessonId:v.value.sublessons[0].id}}),(d=y.value)!=null&&d.sliders&&y.value.sliders.forEach(h=>{a.value[h.id]=h.defaultValue}),un(()=>{x()})}),Ji(()=>{s()});function n(f){i.push({params:{...t.params,sublessonId:f}})}return(f,d)=>v.value?(je(),Ue("div",Pu,[Ce("h1",null,Ne(v.value.title),1),Ce("div",{innerHTML:v.value.introduction,class:"lesson-introduction"},null,8,Tu),Ce("nav",$u,[(je(!0),Ue(Oe,null,In(v.value.sublessons,h=>(je(),Ue("button",{key:h.id,onClick:u=>n(h.id),class:zn({active:h.id===m.value})},Ne(h.title),11,Fu))),128))]),y.value?(je(),Ue("div",_u,[Ce("h2",null,Ne(y.value.title),1),Ce("div",{innerHTML:y.value.content,class:"lesson-content"},null,8,Cu),Ce("div",Eu,[Ce("div",{ref_key:"containerRef",ref:M,class:"visualization-container"},null,512)]),y.value.sliders?(je(),Ue("div",Ru,[(je(!0),Ue(Oe,null,In(y.value.sliders,h=>(je(),Ue("div",{key:h.id,class:"slider-item"},[Ce("label",{for:h.id},Ne(h.label),9,Iu),Fr(Ce("input",{id:h.id,type:"range",min:h.min,max:h.max,step:h.step,"onUpdate:modelValue":u=>a.value[h.id]=u,class:"slider-input"},null,8,Vu),[[Jl,a.value[h.id],void 0,{number:!0}]]),Ce("span",ku,Ne(a.value[h.id]),1),Ce("p",ju,Ne(h.explanation),1)]))),128))])):Fn("",!0)])):Fn("",!0)])):Fn("",!0)}}),Lu=os(Du,[["__scopeId","data-v-8455f66c"]]),Ou=uu({history:Bc("/idgTrig"),routes:[{path:"/",name:"home",component:Su},{path:"/lesson/:id/:sublessonId?",name:"lesson",component:Lu},{path:"/about",name:"about",component:()=>wu(()=>import("./AboutView-CgIs-Ii5.js"),__vite__mapDeps([0,1]))}]});function nt(e,t,i,o,a,l,m){e.beginPath(),e.moveTo(t,i),e.lineTo(o,a),e.lineTo(l,m),e.closePath(),e.stroke()}function he(e,t,i,o){e.beginPath(),e.arc(t,i,o,0,Math.PI*2),e.stroke()}function le(e,t,i,o=5){e.beginPath(),e.arc(t,i,o,0,Math.PI*2),e.fill()}function R(e,t,i,o,a){e.beginPath(),e.moveTo(t,i),e.lineTo(o,a),e.stroke()}function Ae(e,t){const i=document.createElement("canvas");i.width=e,i.height=t;const o=i.getContext("2d");return o&&(o.strokeStyle="#00ffff",o.fillStyle="#00ffff",o.lineWidth=2,o.font="16px Arial"),{canvas:i,ctx:o}}function g(e,t,i,o,a=16){e.font=`${a}px Arial`,e.fillText(t,i,o)}function Sn(e,t,i,o,a,l,m=!1){e.beginPath(),e.arc(t,i,o,a,l,m),e.stroke()}function He(e,t,i,o,a,l){const v=o-t,y=a-i,M=Math.atan2(y,v);e.save(),e.strokeStyle=l,e.fillStyle=l,e.beginPath(),e.moveTo(t,i),e.lineTo(o,a),e.stroke(),e.beginPath(),e.moveTo(o,a),e.lineTo(o-10*Math.cos(M-Math.PI/6),a-10*Math.sin(M-Math.PI/6)),e.lineTo(o-10*Math.cos(M+Math.PI/6),a-10*Math.sin(M+Math.PI/6)),e.closePath(),e.fill(),e.restore()}function zu(){const e=ss(),t={id:1,title:"Introduction to Triangles and Right Angles",introduction:`
            <p>Welcome to our first lesson on triangles! In this lesson, we'll explore the fundamental concepts of triangles, with a special focus on right-angled triangles. We'll break this down into several sublessons to make it easier to understand and digest.</p>
            <p>By the end of this lesson, you'll have a solid understanding of what makes a triangle, the different types of triangles, and the special properties of right-angled triangles.</p>
        `,prerequisites:[],sublessons:[{id:"1.1",title:"What is a Triangle?",content:`
                    <h2>Basic Triangle Properties</h2>
                    <p>A triangle is a geometric shape with three sides and three angles. Here are some key properties:</p>
                    <ul>
                        <li>The sum of the angles in any triangle is always 180 degrees.</li>
                        <li>The longest side is always opposite the largest angle.</li>
                        <li>The shortest side is always opposite the smallest angle.</li>
                    </ul>
                    <p>Use the sliders below to adjust the triangle and observe how changing one side affects the others.</p>
                `,sliders:[{id:"side1",label:"Side 1 Length",min:50,max:300,step:1,defaultValue:100,explanation:"Adjust the length of the first side of the triangle."},{id:"side2",label:"Side 2 Length",min:50,max:300,step:1,defaultValue:100,explanation:"Adjust the length of the second side of the triangle."}],visualizations:[{type:"canvas",setup:x=>Ae(600,600),update:x=>{const{ctx:s,side1:n=100,side2:f=100}=x;if(s){s.clearRect(0,0,600,600);const d=100,h=500,u=Math.acos((n**2+f**2-n**2)/(2*n*f)),c=d+n,r=h-f*Math.sin(u);nt(s,d,h,c,h,c,r),g(s,`Side 1: ${n}`,(d+c)/2,h+20,18),g(s,`Side 2: ${f}`,c+10,(h+r)/2,18);const p=Math.sqrt(n**2+f**2-2*n*f*Math.cos(u)).toFixed(2);g(s,`Side 3: ${p}`,(d+c)/2-40,(h+r)/2-20,18);const F=(Math.acos((f**2+p**2-n**2)/(2*f*p))*180/Math.PI).toFixed(1),b=(Math.acos((n**2+p**2-f**2)/(2*n*p))*180/Math.PI).toFixed(1),A=(180-parseFloat(F)-parseFloat(b)).toFixed(1);g(s,`A: ${F}`,d-40,h-20,18),g(s,`B: ${b}`,c+20,h-20,18),g(s,`C: ${A}`,c-40,r-20,18)}}}]},{id:"1.2",title:"Right-Angled Triangles",content:`
                    <h2>What Makes a Right-Angled Triangle Special?</h2>
                    <p>A right-angled triangle is a special type of triangle that has one angle measuring exactly 90 degrees (a right angle). This type of triangle is fundamental to trigonometry and has some unique properties:</p>
                    <ul>
                        <li><strong>Hypotenuse:</strong> The longest side of the triangle, opposite the right angle.</li>
                        <li><strong>Pythagorean Theorem:</strong> In a right-angled triangle, a + b = c, where c is the length of the hypotenuse and a and b are the lengths of the other two sides.</li>
                    </ul>
                    <p>Use the sliders below to adjust the right-angled triangle. Observe how changing the length of one side affects the other sides while maintaining the 90-degree angle.</p>
                `,sliders:[{id:"baseLength",label:"Base Length",min:50,max:400,step:1,defaultValue:200,explanation:"This slider adjusts the length of the base (adjacent side) of the right-angled triangle. As you increase this value, watch how the hypotenuse changes while the height remains constant."},{id:"height",label:"Height",min:50,max:400,step:1,defaultValue:200,explanation:"This slider controls the height (opposite side) of the right-angled triangle. Adjust this to see how it affects the hypotenuse and the angles of the triangle."}],visualizations:[{type:"canvas",setup:x=>Ae(600,600),update:x=>{const{ctx:s,baseLength:n=200,height:f=200}=x;if(s){s.clearRect(0,0,600,600);const d=100,h=500;nt(s,d,h,d+n,h,d,h-f),s.beginPath(),s.moveTo(d+40,h),s.lineTo(d+40,h-40),s.lineTo(d,h-40),s.stroke(),g(s,`Base: ${n}`,d+n/2-40,h+40,18),g(s,`Height: ${f}`,d-80,h-f/2,18);const u=Math.sqrt(n**2+f**2).toFixed(2);g(s,`Hypotenuse: ${u}`,d+n/2+40,h-f/2,18);const c=Math.atan(f/n)*(180/Math.PI),r=90-c;g(s,`: ${c.toFixed(1)}`,d+20,h-20,18),g(s,`: ${r.toFixed(1)}`,d+n-60,h-40,18)}}}]},{id:"1.3",title:"Types of Triangles",content:`
                    <h2>Understanding Different Types of Triangles</h2>
                    <p>Triangles can be classified based on their angles and sides. Let's explore the main types:</p>
                    <ul>
                        <li><strong>Equilateral Triangle:</strong> All three sides are equal in length, and all angles are 60.</li>
                        <li><strong>Isosceles Triangle:</strong> Two sides are equal in length, and two angles are equal.</li>
                        <li><strong>Scalene Triangle:</strong> All sides have different lengths, and all angles are different.</li>
                        <li><strong>Right Triangle:</strong> Has one 90 angle (which we covered in the previous lesson).</li>
                        <li><strong>Acute Triangle:</strong> All angles are less than 90.</li>
                        <li><strong>Obtuse Triangle:</strong> Has one angle greater than 90.</li>
                    </ul>
                    <p>Use the sliders below to explore different triangle types. Watch how the triangle changes as you adjust the side lengths.</p>
                `,sliders:[{id:"side1",label:"Side 1 Length",min:50,max:300,step:1,defaultValue:100,explanation:"Adjust the length of the first side of the triangle."},{id:"side2",label:"Side 2 Length",min:50,max:300,step:1,defaultValue:100,explanation:"Adjust the length of the second side of the triangle."},{id:"side3",label:"Side 3 Length",min:50,max:300,step:1,defaultValue:100,explanation:"Adjust the length of the third side of the triangle."}],visualizations:[{type:"canvas",setup:x=>Ae(600,600),update:x=>{const{ctx:s,side1:n=100,side2:f=100,side3:d=100}=x;if(s){s.clearRect(0,0,600,600);const h=100,u=500;if(n+f>d&&f+d>n&&n+d>f){const c=Math.acos((f**2+d**2-n**2)/(2*f*d)),r=Math.acos((n**2+d**2-f**2)/(2*n*d)),p=Math.PI-c-r,F=h+d,b=u,A=h+f*Math.cos(c),_=u-f*Math.sin(c);nt(s,h,u,F,b,A,_),g(s,`Side 1: ${n}`,(h+A)/2-40,(u+_)/2+20,18),g(s,`Side 2: ${f}`,(F+A)/2+20,(b+_)/2,18),g(s,`Side 3: ${d}`,(h+F)/2,u+40,18),g(s,`A: ${(c*180/Math.PI).toFixed(1)}`,h-40,u-20,18),g(s,`B: ${(r*180/Math.PI).toFixed(1)}`,F+20,b-20,18),g(s,`C: ${(p*180/Math.PI).toFixed(1)}`,A-20,_-20,18);let T="";n===f&&f===d?T="Equilateral Triangle":n===f||f===d||n===d?T="Isosceles Triangle":T="Scalene Triangle",Math.max(c,r,p)>Math.PI/2?T+=", Obtuse Triangle":Math.max(c,r,p)===Math.PI/2?T+=", Right Triangle":T+=", Acute Triangle",g(s,T,300,50,24)}else g(s,"Invalid triangle: sum of any two sides must be greater than the third side",300,300,18)}}}]},{id:"1.4",title:"The Pythagorean Theorem",content:`
                    <h2>Understanding the Pythagorean Theorem</h2>
                    <p>The Pythagorean theorem is a fundamental principle in geometry that relates the lengths of the sides in a right-angled triangle. It states that:</p>
                    <p><strong>In a right-angled triangle, the square of the length of the hypotenuse (the side opposite the right angle) is equal to the sum of squares of the other two sides.</strong></p>
                    <p>Mathematically, it's expressed as: a + b = c, where c is the length of the hypotenuse, and a and b are the lengths of the other two sides.</p>
                    <p>This theorem is incredibly useful for:</p>
                    <ul>
                        <li>Finding the length of an unknown side in a right-angled triangle</li>
                        <li>Determining if a triangle is a right triangle</li>
                        <li>Calculating distances in two-dimensional space</li>
                    </ul>
                    <p>Use the sliders below to adjust the lengths of the two shorter sides of a right-angled triangle. Observe how the length of the hypotenuse changes according to the Pythagorean theorem.</p>
                `,sliders:[{id:"sideA",label:"Side a Length",min:1,max:10,step:.1,defaultValue:3,explanation:"Adjust the length of side a of the right triangle."},{id:"sideB",label:"Side b Length",min:1,max:10,step:.1,defaultValue:4,explanation:"Adjust the length of side b of the right triangle."}],visualizations:[{type:"canvas",setup:x=>Ae(600,600),update:x=>{const{ctx:s,sideA:n=3,sideB:f=4}=x;if(s){s.clearRect(0,0,600,600);const d=40,h=100,u=500,c=Math.sqrt(n*n+f*f);nt(s,h,u,h+n*d,u,h,u-f*d),s.beginPath(),s.moveTo(h+20,u),s.lineTo(h+20,u-20),s.lineTo(h,u-20),s.stroke(),g(s,`a = ${n.toFixed(1)}`,h+n*d/2-20,u+30,18),g(s,`b = ${f.toFixed(1)}`,h-50,u-f*d/2,18),g(s,`c = (a + b) = ${c.toFixed(2)}`,h+n*d/2+20,u-f*d/2-20,18),g(s,"a + b = c",100,50,24),g(s,`${(n*n).toFixed(2)} + ${(f*f).toFixed(2)} = ${(c*c).toFixed(2)}`,100,90,20)}}}]},{id:"1.5",title:"Special Right Triangles (30-60-90 and 45-45-90)",content:`
                    <h2>Understanding Special Right Triangles</h2>
                    <p>There are two types of right triangles that have special properties and occur frequently in geometry and trigonometry problems: the 30-60-90 triangle and the 45-45-90 triangle.</p>
                    <h3>30-60-90 Triangle</h3>
                    <ul>
                        <li>Angles: 30, 60, and 90</li>
                        <li>If the shortest side (opposite to 30) has length x:</li>
                        <li>The hypotenuse (opposite to 90) has length 2x</li>
                        <li>The remaining side (opposite to 60) has length x3</li>
                    </ul>
                    <h3>45-45-90 Triangle</h3>
                    <ul>
                        <li>Also known as an isosceles right triangle</li>
                        <li>Angles: 45, 45, and 90</li>
                        <li>If the two equal sides (opposite to 45) have length x:</li>
                        <li>The hypotenuse (opposite to 90) has length x2</li>
                    </ul>
                    <p>Use the slider below to switch between these special right triangles and observe their unique properties.</p>
                `,sliders:[{id:"triangleType",label:"Triangle Type",min:0,max:1,step:1,defaultValue:0,explanation:"Switch between 30-60-90 (0) and 45-45-90 (1) triangles."}],visualizations:[{type:"canvas",setup:x=>Ae(600,600),update:x=>{const{ctx:s,triangleType:n=0}=x;if(s){s.clearRect(0,0,600,600);const f=200,d=100,h=500;if(n===0){const c=Math.sqrt(3),r=2;nt(s,d,h,d+r*f,h,d+1*f/2,h-c*f/2),s.beginPath(),s.moveTo(d+20,h),s.lineTo(d+20,h-20),s.lineTo(d,h-20),s.stroke(),g(s,"x",d+r*f/2-20,h+30,18),g(s,"x3",d-50,h-c*f/4,18),g(s,"2x",d+1*f/4+20,h-c*f/4-20,18),g(s,"30",d+30,h-30,18),g(s,"60",d+r*f-50,h-30,18),g(s,"30-60-90 Triangle",100,50,24)}else{const u=Math.sqrt(2);nt(s,d,h,d+u*f,h,d,h-u*f),s.beginPath(),s.moveTo(d+20,h),s.lineTo(d+20,h-20),s.lineTo(d,h-20),s.stroke(),g(s,"x",d+u*f/2-20,h+30,18),g(s,"x",d-40,h-u*f/2,18),g(s,"x2",d+u*f/2+20,h-u*f/2-20,18),g(s,"45",d+30,h-30,18),g(s,"45",d+u*f-50,h-30,18),g(s,"45-45-90 Triangle",100,50,24)}}}}]}]},i={id:2,title:"The Unit Circle and Basic Trigonometric Functions",introduction:`
        <p>Welcome to our exploration of the unit circle and basic trigonometric functions! This lesson is crucial for understanding the foundations of trigonometry and how it relates to circles and periodic functions.</p>
        <p>We'll start by introducing the unit circle, then move on to understand radians, and finally explore the fundamental trigonometric functions: sine and cosine.</p>
    `,prerequisites:[1],sublessons:[{id:"2.1",title:"Understanding the Unit Circle",content:`
                <h2>What is the Unit Circle?</h2>
                <p>The unit circle is a circle with a radius of 1 centered at the origin (0, 0) in a coordinate plane. It's a powerful tool for understanding trigonometric functions and their relationships.</p>
                <ul>
                    <li>The circumference of the unit circle is exactly 2 (approximately 6.28).</li>
                    <li>Any point (x, y) on the unit circle corresponds to (cos , sin ) for some angle .</li>
                    <li>Key points on the unit circle:
                        <ul>
                            <li>(1, 0) at 0</li>
                            <li>(0, 1) at 90</li>
                            <li>(-1, 0) at 180</li>
                            <li>(0, -1) at 270</li>
                        </ul>
                    </li>
                </ul>
                <p>Use the slider below to rotate a point around the unit circle and observe how its coordinates change.</p>
            `,sliders:[{id:"angle",label:"Angle (degrees)",min:0,max:360,step:1,defaultValue:0,explanation:"Adjust the angle to move the point around the unit circle."}],visualizations:[{type:"canvas",setup:x=>Ae(600,600),update:x=>{const{ctx:s,angle:n=0}=x;if(s){s.clearRect(0,0,600,600);const f=300,d=300,h=200;R(s,100,300,500,300),R(s,300,100,300,500),g(s,"x",510,300,20),g(s,"y",300,90,20),he(s,f,d,h);const u=n*Math.PI/180,c=Math.cos(u),r=Math.sin(u);le(s,f+c*h,d-r*h,5),s.setLineDash([5,5]),R(s,f+c*h,d-r*h,f+c*h,d),R(s,f+c*h,d-r*h,f,d-r*h),s.setLineDash([]),g(s,`(${c.toFixed(2)}, ${r.toFixed(2)})`,f+c*h+10,d-r*h-10,16),g(s,`${n}`,f+20,d-20,16)}}}]},{id:"2.2",title:"Radians and Degrees",content:`
                <h2>Understanding Radians</h2>
                <p>Radians are another way to measure angles, often preferred in advanced mathematics due to their natural relationship with the radius of a circle.</p>
                <ul>
                    <li>One radian is the angle subtended at the center of a circle by an arc equal in length to the radius.</li>
                    <li>2 radians = 360</li>
                    <li> radians = 180</li>
                    <li>Common angles:
                        <ul>
                            <li>/6 radians = 30</li>
                            <li>/4 radians = 45</li>
                            <li>/3 radians = 60</li>
                            <li>/2 radians = 90</li>
                        </ul>
                    </li>
                </ul>
                <p>Use the slider to convert between degrees and radians.</p>
            `,sliders:[{id:"degrees",label:"Angle (degrees)",min:0,max:360,step:1,defaultValue:0,explanation:"Adjust the angle in degrees and see the equivalent in radians."}],visualizations:[{type:"canvas",setup:x=>Ae(600,600),update:x=>{const{ctx:s,degrees:n=0}=x;if(s){s.clearRect(0,0,600,600);const f=300,d=300,h=200;he(s,f,d,h);const u=n*Math.PI/180;s.beginPath(),s.moveTo(f,d),s.arc(f,d,h,-Math.PI/2,-Math.PI/2+u),s.lineTo(f,d),s.fillStyle="rgba(0, 255, 255, 0.2)",s.fill(),g(s,`${n}`,f+20,d-20,20),g(s,`${u.toFixed(2)} radians`,f+20,d+20,20),g(s,"Conversion Formula:",50,50,20),g(s,"radians = degrees * ( / 180)",50,80,18),g(s,"degrees = radians * (180 / )",50,110,18)}}}]},{id:"2.3",title:"Introduction to Sine and Cosine",content:`
                <h2>Sine and Cosine on the Unit Circle</h2>
                <p>Sine and cosine are the two most fundamental trigonometric functions. On the unit circle, they correspond directly to the y and x coordinates of a point.</p>
                <ul>
                    <li>For any angle  on the unit circle:
                        <ul>
                            <li>cos() is the x-coordinate of the point</li>
                            <li>sin() is the y-coordinate of the point</li>
                        </ul>
                    </li>
                    <li>This relationship is true for any angle, positive or negative.</li>
                    <li>The values of sine and cosine are always between -1 and 1.</li>
                </ul>
                <p>Use the slider to see how sine and cosine change as you move around the unit circle.</p>
            `,sliders:[{id:"angle",label:"Angle (degrees)",min:0,max:360,step:1,defaultValue:0,explanation:"Adjust the angle to see how sine and cosine values change."}],visualizations:[{type:"canvas",setup:x=>Ae(600,600),update:x=>{const{ctx:s,angle:n=0}=x;if(s){s.clearRect(0,0,600,600);const f=300,d=300,h=200;R(s,100,300,500,300),R(s,300,100,300,500),g(s,"x (cos )",510,300,16),g(s,"y (sin )",300,90,16),he(s,f,d,h);const u=n*Math.PI/180,c=Math.cos(u),r=Math.sin(u);le(s,f+c*h,d-r*h,5),s.strokeStyle="red",R(s,f+c*h,d-r*h,f+c*h,d),s.strokeStyle="blue",R(s,f+c*h,d-r*h,f,d-r*h),s.strokeStyle="#00ffff",g(s,`cos(${n}) = ${c.toFixed(2)}`,50,550,18),g(s,`sin(${n}) = ${r.toFixed(2)}`,350,550,18),s.beginPath(),s.moveTo(f,d),s.arc(f,d,40,-Math.PI/2,-Math.PI/2+u),s.lineTo(f,d),s.fillStyle="rgba(0, 255, 255, 0.2)",s.fill(),g(s,`${n}`,f+45,d-10,16)}}}]},{id:"2.4",title:"The Tangent Function",content:`
                <h2>Understanding the Tangent Function</h2>
                <p>The tangent function, often abbreviated as tan, is another fundamental trigonometric function. It has a special relationship with sine and cosine.</p>
                <ul>
                    <li><strong>Definition:</strong> For any angle , tan() = sin() / cos()</li>
                    <li>On the unit circle, tan() represents the length of the line segment from the point (1, 0) to the y-axis, drawn tangent to the circle at (1, 0).</li>
                    <li>Unlike sine and cosine, tangent can take any real value, including infinity.</li>
                    <li>Tangent is undefined when cos() = 0, which occurs at 90 and 270 (/2 and 3/2 radians).</li>
                </ul>
                <p>Use the slider to see how tangent changes as you move around the unit circle. Notice how it approaches infinity as you near 90 and 270.</p>
            `,sliders:[{id:"angle",label:"Angle (degrees)",min:0,max:360,step:1,defaultValue:0,explanation:"Adjust the angle to see how the tangent value changes."}],visualizations:[{type:"canvas",setup:x=>Ae(600,600),update:x=>{const{ctx:s,angle:n=0}=x;if(s){s.clearRect(0,0,600,600);const f=300,d=300,h=200;R(s,100,300,500,300),R(s,300,100,300,500),g(s,"x",510,300,16),g(s,"y",300,90,16),he(s,f,d,h);const u=n*Math.PI/180,c=Math.cos(u),r=Math.sin(u),p=Math.tan(u);le(s,f+c*h,d-r*h,5),Math.abs(p)<10&&(s.strokeStyle="green",R(s,f+h,d,f+h,d-p*h),s.strokeStyle="#00ffff"),s.beginPath(),s.moveTo(f,d),s.arc(f,d,40,-Math.PI/2,-Math.PI/2+u),s.lineTo(f,d),s.fillStyle="rgba(0, 255, 255, 0.2)",s.fill(),g(s,`${n}`,f+45,d-10,16),Math.abs(p)<1e3?g(s,`tan(${n}) = ${p.toFixed(2)}`,50,550,18):g(s,`tan(${n}) = undefined`,50,550,18),g(s,"tan() = sin() / cos()",50,50,18),g(s,`tan(${n}) = ${r.toFixed(2)} / ${c.toFixed(2)}`,50,80,18)}}}]},{id:"2.5",title:"Relationship Between Unit Circle and Right-Angled Triangles",content:`
                <h2>Connecting the Unit Circle to Right Triangles</h2>
                <p>The unit circle and right-angled triangles are closely related. Understanding this connection helps bridge the gap between trigonometric functions and triangle geometry.</p>
                <ul>
                    <li>Any point (x, y) on the unit circle forms a right triangle with the x-axis and a line from the origin.</li>
                    <li>In this triangle:
                        <ul>
                            <li>The hypotenuse is always 1 (the radius of the unit circle)</li>
                            <li>The adjacent side to the angle is cos()</li>
                            <li>The opposite side to the angle is sin()</li>
                        </ul>
                    </li>
                    <li>This relationship gives us the fundamental trigonometric ratios:
                        <ul>
                            <li>sin() = opposite / hypotenuse</li>
                            <li>cos() = adjacent / hypotenuse</li>
                            <li>tan() = opposite / adjacent = sin() / cos()</li>
                        </ul>
                    </li>
                </ul>
                <p>Use the slider to see how the right triangle changes as you move around the unit circle, and how this relates to the trigonometric functions.</p>
            `,sliders:[{id:"angle",label:"Angle (degrees)",min:0,max:360,step:1,defaultValue:0,explanation:"Adjust the angle to see how the right triangle changes on the unit circle."}],visualizations:[{type:"canvas",setup:x=>Ae(600,600),update:x=>{const{ctx:s,angle:n=0}=x;if(s){s.clearRect(0,0,600,600);const f=300,d=300,h=200;R(s,100,300,500,300),R(s,300,100,300,500),g(s,"x",510,300,16),g(s,"y",300,90,16),he(s,f,d,h);const u=n*Math.PI/180,c=Math.cos(u),r=Math.sin(u);s.strokeStyle="red",nt(s,f,d,f+c*h,d,f+c*h,d-r*h),s.strokeStyle="#00ffff",le(s,f+c*h,d-r*h,5),g(s,"cos ",f+c*h/2,d+20,16),g(s,"sin ",f+c*h+10,d-r*h/2,16),g(s,"1",f+c*h/2-20,d-r*h/2-10,16),s.beginPath(),s.moveTo(f,d),s.arc(f,d,40,-Math.PI/2,-Math.PI/2+u),s.lineTo(f,d),s.fillStyle="rgba(0, 255, 255, 0.2)",s.fill(),g(s,` = ${n}`,f+45,d-10,16),g(s,`sin() = opposite / hypotenuse = ${r.toFixed(2)}`,50,500,16),g(s,`cos() = adjacent / hypotenuse = ${c.toFixed(2)}`,50,530,16),g(s,`tan() = opposite / adjacent = ${(r/c).toFixed(2)}`,50,560,16)}}}]}]},o={id:3,title:"Trigonometric Ratios in Right-Angled Triangles",introduction:`
        <p>Welcome to our lesson on Trigonometric Ratios in Right-Angled Triangles! This lesson will build on your understanding of the unit circle and apply it to right-angled triangles.</p>
        <p>We'll explore how sine, cosine, and tangent relate to the sides of right triangles, learn how to use these ratios to solve problems, understand inverse trigonometric functions, and see how these concepts apply to real-world situations.</p>
    `,prerequisites:[1,2],sublessons:[{id:"3.1",title:"Sine, Cosine, and Tangent Ratios",content:`
                <h2>Defining Trigonometric Ratios</h2>
                <p>In a right-angled triangle, the trigonometric ratios are defined in terms of the lengths of the sides of the triangle:</p>
                <ul>
                    <li><strong>Sine (sin):</strong> Opposite / Hypotenuse</li>
                    <li><strong>Cosine (cos):</strong> Adjacent / Hypotenuse</li>
                    <li><strong>Tangent (tan):</strong> Opposite / Adjacent</li>
                </ul>
                <h3>SOHCAHTOA Mnemonic</h3>
                <p>To remember these ratios, you can use the mnemonic SOHCAHTOA:</p>
                <ul>
                    <li><strong>SOH</strong>: Sine = Opposite / Hypotenuse</li>
                    <li><strong>CAH</strong>: Cosine = Adjacent / Hypotenuse</li>
                    <li><strong>TOA</strong>: Tangent = Opposite / Adjacent</li>
                </ul>
                <p>Use the slider to adjust the angle of the right triangle and see how the ratios change.</p>
            `,sliders:[{id:"angle",label:"Angle  (degrees)",min:1,max:89,step:1,defaultValue:45,explanation:"Adjust the angle  of the right triangle."}],visualizations:[{type:"canvas",setup:x=>Ae(600,600),update:x=>{const{ctx:s,angle:n=45}=x;if(s){s.clearRect(0,0,600,600);const f=100,d=500,h=400,u=n*Math.PI/180,c=Math.sin(u)*h,r=Math.cos(u)*h;nt(s,f,d,f+r,d,f,d-c),g(s,"Opposite",f-80,d-c/2,16),g(s,"Adjacent",f+r/2,d+30,16),g(s,"Hypotenuse",f+r/2-40,d-c/2-20,16),g(s,` = ${n}`,f+30,d-20,16);const p=Math.sin(u),F=Math.cos(u),b=Math.tan(u);g(s,`sin() = Opposite / Hypotenuse = ${p.toFixed(3)}`,50,50,16),g(s,`cos() = Adjacent / Hypotenuse = ${F.toFixed(3)}`,50,80,16),g(s,`tan() = Opposite / Adjacent = ${b.toFixed(3)}`,50,110,16)}}}]},{id:"3.2",title:"Using Trigonometric Ratios to Solve Problems",content:`
                <h2>Finding Missing Sides and Angles</h2>
                <p>Trigonometric ratios are powerful tools for solving problems involving right-angled triangles. They allow us to find missing sides or angles when we have partial information about a triangle.</p>
                <h3>Steps to Solve:</h3>
                <ol>
                    <li>Identify the known and unknown parts of the triangle.</li>
                    <li>Determine which trigonometric ratio (sin, cos, or tan) relates the known and unknown parts.</li>
                    <li>Set up an equation using the appropriate ratio.</li>
                    <li>Solve the equation for the unknown value.</li>
                </ol>
                <p>Use the sliders to adjust the known values of a right triangle. The visualization will show you how to find the missing parts.</p>
            `,sliders:[{id:"knownAngle",label:"Known Angle (degrees)",min:1,max:89,step:1,defaultValue:30,explanation:"Set the known angle of the right triangle."},{id:"knownSide",label:"Known Side Length",min:50,max:300,step:10,defaultValue:100,explanation:"Set the length of the known side."}],visualizations:[{type:"canvas",setup:x=>Ae(600,600),update:x=>{const{ctx:s,knownAngle:n=30,knownSide:f=100}=x;if(s){s.clearRect(0,0,600,600);const d=100,h=500,u=1.5,c=n*Math.PI/180,r=Math.sin(c)*f,p=Math.cos(c)*f,F=f;nt(s,d,h,d+p*u,h,d,h-r*u),g(s,`${r.toFixed(1)}`,d-40,h-r*u/2,16),g(s,`${p.toFixed(1)}`,d+p*u/2,h+20,16),g(s,`${F.toFixed(1)}`,d+p*u/2-40,h-r*u/2-20,16),g(s,`${n}`,d+30,h-20,16),g(s,`${90-n}`,d+p*u-40,h-20,16),g(s,"Calculations:",50,50,20),g(s,`Given: Angle = ${n}, Hypotenuse = ${f}`,50,80,16),g(s,`Opposite = Hypotenuse  sin(${n}) = ${f}  ${Math.sin(c).toFixed(3)} = ${r.toFixed(1)}`,50,110,16),g(s,`Adjacent = Hypotenuse  cos(${n}) = ${f}  ${Math.cos(c).toFixed(3)} = ${p.toFixed(1)}`,50,140,16)}}}]},{id:"3.3",title:"Inverse Trigonometric Functions",content:`
                <h2>Understanding Arcsin, Arccos, and Arctan</h2>
                <p>Inverse trigonometric functions, also known as arcfunctions, allow us to find an angle when we know the value of its trigonometric ratio.</p>
                <ul>
                    <li><strong>Arcsin (sin):</strong> Returns the angle whose sine is the input value.</li>
                    <li><strong>Arccos (cos):</strong> Returns the angle whose cosine is the input value.</li>
                    <li><strong>Arctan (tan):</strong> Returns the angle whose tangent is the input value.</li>
                </ul>
                <p>These functions are particularly useful when we need to find an unknown angle in a right-angled triangle.</p>
                <p>Use the slider to input a ratio value and see the corresponding angle for each inverse trigonometric function.</p>
            `,sliders:[{id:"ratio",label:"Ratio Value",min:-1,max:1,step:.01,defaultValue:0,explanation:"Input a ratio value between -1 and 1 to see the corresponding angles."}],visualizations:[{type:"canvas",setup:x=>Ae(600,600),update:x=>{const{ctx:s,ratio:n=0}=x;if(s){s.clearRect(0,0,600,600);const f=Math.asin(n)*180/Math.PI,d=Math.acos(n)*180/Math.PI,h=Math.atan(n)*180/Math.PI;g(s,`Input ratio: ${n.toFixed(2)}`,50,50,20),g(s,`Arcsin(${n.toFixed(2)}) = ${f.toFixed(2)}`,50,100,18),g(s,`Arccos(${n.toFixed(2)}) = ${d.toFixed(2)}`,50,130,18),g(s,`Arctan(${n.toFixed(2)}) = ${h.toFixed(2)}`,50,160,18);const u=300,c=300,r=200;he(s,u,c,r),R(s,u-r,c,u+r,c),R(s,u,c-r,u,c+r);const p=["red","green","blue"],F=[f,d,h],b=["sin","cos","tan"];F.forEach((A,_)=>{const T=A*Math.PI/180;s.beginPath(),s.moveTo(u,c),s.arc(u,c,r,-Math.PI/2,-Math.PI/2+T),s.lineTo(u,c),s.strokeStyle=p[_],s.stroke(),g(s,`${b[_]}: ${A.toFixed(2)}`,u+10,c+20+_*30,16)})}}}]},{id:"3.4",title:"Solving Right Triangles",content:`
                <h2>Techniques for Solving All Parts of a Right Triangle</h2>
                <p>Solving a right triangle means finding the lengths of all sides and the measures of all angles. Here are the key techniques:</p>
                <ol>
                    <li><strong>Pythagorean Theorem:</strong> a + b = c, where c is the hypotenuse.</li>
                    <li><strong>Trigonometric Ratios:</strong> Use sin, cos, and tan to find sides or angles.</li>
                    <li><strong>Inverse Trigonometric Functions:</strong> Use arcsin, arccos, and arctan to find angles.</li>
                    <li><strong>Angle Sum Property:</strong> The sum of angles in a triangle is always 180.</li>
                </ol>
                <p>Use the sliders to input known values of a right triangle. The visualization will show you how to solve for all parts of the triangle.</p>
            `,sliders:[{id:"knownSide",label:"Known Side Length",min:50,max:300,step:10,defaultValue:100,explanation:"Set the length of the known side."},{id:"knownAngle",label:"Known Angle (degrees)",min:1,max:89,step:1,defaultValue:30,explanation:"Set the known angle of the right triangle."}],visualizations:[{type:"canvas",setup:x=>Ae(600,600),update:x=>{const{ctx:s,knownSide:n=100,knownAngle:f=30}=x;if(s){s.clearRect(0,0,600,600);const d=100,h=500,u=1.5,c=f*Math.PI/180,r=n,p=Math.sin(c)*r,F=Math.cos(c)*r,b=90-f;nt(s,d,h,d+F*u,h,d,h-p*u),g(s,`${p.toFixed(1)}`,d-40,h-p*u/2,16),g(s,`${F.toFixed(1)}`,d+F*u/2,h+20,16),g(s,`${r.toFixed(1)}`,d+F*u/2-40,h-p*u/2-20,16),g(s,`${f}`,d+30,h-20,16),g(s,`${b.toFixed(1)}`,d+F*u-40,h-20,16),g(s,"90",d+10,h-p*u+20,16),g(s,"Solving the Triangle:",50,50,20),g(s,`Given: One side = ${n}, One angle = ${f}`,50,80,16),g(s,`1. Other angle = 90 - ${f} = ${b.toFixed(1)}`,50,110,16),g(s,`2. Hypotenuse = Given side = ${r}`,50,140,16),g(s,`3. Opposite = Hypotenuse  sin(${f}) = ${r}  ${Math.sin(c).toFixed(3)} = ${p.toFixed(1)}`,50,170,16),g(s,`4. Adjacent = Hypotenuse  cos(${f}) = ${r}  ${Math.cos(c).toFixed(3)} = ${F.toFixed(1)}`,50,200,16)}}}]},{id:"3.5",title:"Applications in Real-World Problems",content:`
                <h2>Practical Examples Using Trigonometric Ratios</h2>
                <p>Trigonometric ratios have numerous real-world applications. Here are some common scenarios where these concepts are used:</p>
                <ul>
                    <li><strong>Architecture and Construction:</strong> Calculating heights of buildings, slopes of roofs, etc.</li>
                    <li><strong>Navigation:</strong> Determining distances and directions in maritime and aviation.</li>
                    <li><strong>Astronomy:</strong> Measuring distances to celestial bodies.</li>
                    <li><strong>Surveying:</strong> Mapping terrains and measuring land.</li>
                    <li><strong>Physics:</strong> Analyzing forces, motion, and waves.</li>
                </ul>
                <p>Let's explore a practical example: finding the height of a tall object using its shadow.</p>
                <p>Use the sliders to adjust the angle of the sun and the length of the shadow. The visualization will show how to calculate the height of the object.</p>
            `,sliders:[{id:"sunAngle",label:"Sun Angle (degrees)",min:1,max:89,step:1,defaultValue:45,explanation:"Adjust the angle of the sun above the horizon."},{id:"shadowLength",label:"Shadow Length (meters)",min:1,max:50,step:1,defaultValue:10,explanation:"Set the length of the shadow cast by the object."}],visualizations:[{type:"canvas",setup:x=>Ae(600,600),update:x=>{const{ctx:s,sunAngle:n=45,shadowLength:f=10}=x;if(s){s.clearRect(0,0,600,600);const d=500,h=10,u=50,c=n*Math.PI/180,r=f*Math.tan(c);R(s,0,d,600,d),R(s,u,d,u,d-r*h),R(s,u,d,u+f*h,d),s.beginPath(),s.moveTo(u,d),s.arc(u,d,50,-Math.PI/2,-Math.PI/2-c,!0),s.stroke(),g(s,`${f}m`,u+f*h/2,d+20,16),g(s,`${r.toFixed(2)}m`,u-40,d-r*h/2,16),g(s,`${n}`,u+60,d-30,16),g(s,"Calculating Object Height:",50,50,20),g(s,`Given: Sun angle = ${n}, Shadow length = ${f}m`,50,80,16),g(s,`tan(${n}) = Height / Shadow Length`,50,110,16),g(s,`Height = Shadow Length  tan(${n})`,50,140,16),g(s,`Height = ${f}  ${Math.tan(c).toFixed(3)} = ${r.toFixed(2)}m`,50,170,16)}}}]}]},a={id:4,title:"Angles and Angle Measure",introduction:`
        <p>Welcome to our lesson on Angles and Angle Measure! This lesson will deepen your understanding of angles, how we measure them, and why different measurement systems are important in mathematics.</p>
        <p>We'll explore various types of angles, learn about different ways to measure angles (including degrees and radians), and understand why these concepts are crucial in advanced mathematics and real-world applications.</p>
    `,prerequisites:[1,2,3],sublessons:[{id:"4.1",title:"Angle Terminology and Notation",content:`
                <h2>Types of Angles</h2>
                <p>Angles are classified based on their measure:</p>
                <ul>
                    <li><strong>Acute angle:</strong> Measures less than 90</li>
                    <li><strong>Right angle:</strong> Measures exactly 90</li>
                    <li><strong>Obtuse angle:</strong> Measures more than 90 but less than 180</li>
                    <li><strong>Straight angle:</strong> Measures exactly 180</li>
                    <li><strong>Reflex angle:</strong> Measures more than 180 but less than 360</li>
                </ul>
                <h3>Standard Position of Angles</h3>
                <p>An angle is in standard position when:</p>
                <ul>
                    <li>Its vertex is at the origin (0, 0) of a coordinate plane</li>
                    <li>Its initial side lies along the positive x-axis</li>
                    <li>Its terminal side extends from the origin at the specified angle</li>
                </ul>
                <p>Use the slider to explore different types of angles in standard position.</p>
            `,sliders:[{id:"angle",label:"Angle (degrees)",min:0,max:360,step:1,defaultValue:45,explanation:"Adjust the angle to see different angle types in standard position."}],visualizations:[{type:"canvas",setup:x=>Ae(600,600),update:x=>{const{ctx:s,angle:n=45}=x;if(s){s.clearRect(0,0,600,600);const f=300,d=300,h=200;R(s,100,300,500,300),R(s,300,100,300,500),g(s,"x",510,300,16),g(s,"y",300,90,16),he(s,f,d,h);const u=n*Math.PI/180,c=f+Math.cos(u)*h,r=d-Math.sin(u)*h;R(s,f,d,c,r),Sn(s,f,d,50,0,-u,!0),g(s,`${n}`,f+60,d-20,16);let p="";n===0||n===360?p="Zero angle":n<90?p="Acute angle":n===90?p="Right angle":n<180?p="Obtuse angle":n===180?p="Straight angle":p="Reflex angle",g(s,p,50,50,24)}}}]},{id:"4.2",title:"Degrees, Minutes, and Seconds",content:`
                <h2>Understanding Subdivisions of Degrees</h2>
                <p>While we commonly express angles in decimal degrees, there's another system that subdivides degrees into smaller units:</p>
                <ul>
                    <li><strong>Degrees ():</strong> The primary unit of angular measure</li>
                    <li><strong>Minutes ('):</strong> 1 degree = 60 minutes</li>
                    <li><strong>Seconds (''):</strong> 1 minute = 60 seconds</li>
                </ul>
                <p>This system is known as Degrees, Minutes, Seconds (DMS) notation.</p>
                <h3>Converting between Decimal Degrees and DMS</h3>
                <p>To convert from decimal degrees to DMS:</p>
                <ol>
                    <li>The whole number part becomes degrees</li>
                    <li>Multiply the fractional part by 60 to get minutes</li>
                    <li>Multiply the new fractional part by 60 to get seconds</li>
                </ol>
                <p>Use the slider to see conversions between decimal degrees and DMS notation.</p>
            `,sliders:[{id:"decimalDegrees",label:"Decimal Degrees",min:0,max:360,step:.1,defaultValue:45.5,explanation:"Adjust the angle in decimal degrees to see its DMS equivalent."}],visualizations:[{type:"canvas",setup:x=>Ae(600,600),update:x=>{const{ctx:s,decimalDegrees:n=45.5}=x;if(s){s.clearRect(0,0,600,600);const f=300,d=300,h=200,u=Math.floor(n),c=(n-u)*60,r=Math.floor(c),p=Math.round((c-r)*60);he(s,f,d,h);const F=n*Math.PI/180,b=f+Math.cos(F)*h,A=d-Math.sin(F)*h;R(s,f,d,b,A),Sn(s,f,d,50,0,-F,!0),g(s,`${n.toFixed(1)}`,f+60,d-20,16),g(s,"Decimal Degrees to DMS Conversion:",50,50,24),g(s,`${n.toFixed(1)} = ${u} ${r}' ${p}''`,50,90,20),g(s,"Conversion Process:",50,150,20),g(s,`1. Degrees: ${u}`,70,180,16),g(s,`2. Minutes: (${n.toFixed(1)} - ${u})  60 = ${c.toFixed(2)}`,70,210,16),g(s,`   ${r}'`,70,240,16),g(s,`3. Seconds: (${c.toFixed(2)} - ${r})  60 = ${p}''`,70,270,16)}}}]},{id:"4.3",title:"Radians in Depth",content:`
                <h2>Why Radians are Important in Advanced Math</h2>
                <p>Radians are an alternative way to measure angles, and they become increasingly important in advanced mathematics for several reasons:</p>
                <ul>
                    <li>They provide a more natural way to describe rotations and periodic functions</li>
                    <li>Many calculus formulas become simpler when expressed in radians</li>
                    <li>They eliminate the need for conversion factors in many physics equations</li>
                </ul>
                <h3>Relationship between Radians and Circle Radius</h3>
                <p>One radian is defined as the angle subtended at the center of a circle by an arc whose length is equal to the radius of the circle.</p>
                <ul>
                    <li>A full circle is 2 radians (approximately 6.28 radians)</li>
                    <li> radians = 180</li>
                    <li>1 radian  57.3</li>
                </ul>
                <p>Use the slider to explore the relationship between radians and the circle's radius.</p>
            `,sliders:[{id:"radians",label:"Angle (radians)",min:0,max:2*Math.PI,step:.1,defaultValue:1,explanation:"Adjust the angle in radians to see its relationship with the circle's radius."}],visualizations:[{type:"canvas",setup:x=>Ae(600,600),update:x=>{const{ctx:s,radians:n=1}=x;if(s){s.clearRect(0,0,600,600);const f=300,d=300,h=200;he(s,f,d,h);const u=f+Math.cos(-n)*h,c=d+Math.sin(-n)*h;R(s,f,d,u,c),Sn(s,f,d,h,0,n,!1),g(s,`${n.toFixed(2)} radians`,f+60,d-20,16),g(s,`${(n*180/Math.PI).toFixed(2)}`,f+60,d+10,16),R(s,f,d,f+h,d),g(s,"r",f+h/2,d-20,16);const r=f+Math.cos(-n/2)*(h+30),p=d+Math.sin(-n/2)*(h+30);g(s,"s = r  ",r,p,16),g(s,"Radian Measure:",50,50,24),g(s,"1 radian is the angle subtended by",50,90,18),g(s,"an arc length equal to the radius",50,120,18),g(s,"Arc length (s) = radius (r)  angle ()",50,160,18),g(s,`s = ${h}  ${n.toFixed(2)} = ${(h*n).toFixed(2)}`,50,190,18)}}}]},{id:"4.4",title:"Converting Between Degrees and Radians",content:`
                <h2>Conversion Formulas and Techniques</h2>
                <p>Being able to convert between degrees and radians is an essential skill in trigonometry and calculus. Here are the key conversion formulas:</p>
                <ul>
                    <li><strong>Degrees to Radians:</strong> radians = degrees  ( / 180)</li>
                    <li><strong>Radians to Degrees:</strong> degrees = radians  (180 / )</li>
                </ul>
                <p>Some common angles to remember:</p>
                <ul>
                    <li>180 =  radians</li>
                    <li>90 = /2 radians</li>
                    <li>60 = /3 radians</li>
                    <li>45 = /4 radians</li>
                    <li>30 = /6 radians</li>
                </ul>
                <p>Use the slider to practice converting between degrees and radians.</p>
            `,sliders:[{id:"angle",label:"Angle",min:0,max:360,step:1,defaultValue:45,explanation:"Adjust the angle to see its value in both degrees and radians."}],visualizations:[{type:"canvas",setup:x=>Ae(600,600),update:x=>{const{ctx:s,angle:n=45}=x;if(s){s.clearRect(0,0,600,600);const f=300,d=300,h=200;he(s,f,d,h);const u=n*(Math.PI/180),c=f+Math.cos(-u)*h,r=d+Math.sin(-u)*h;R(s,f,d,c,r),Sn(s,f,d,50,0,-u,!0),g(s,`${n}`,f+60,d-20,16),g(s,`${u.toFixed(4)} rad`,f+60,d+10,16),g(s,"Degree to Radian Conversion:",50,50,24),g(s,`${n}  ( / 180) = ${u.toFixed(4)} rad`,50,90,18),g(s,"Radian to Degree Conversion:",50,140,24),g(s,`${u.toFixed(4)} rad  (180 / ) = ${n}`,50,180,18),g(s,"Common Angle Conversions:",50,230,24),[{deg:180,rad:""},{deg:90,rad:"/2"},{deg:60,rad:"/3"},{deg:45,rad:"/4"},{deg:30,rad:"/6"}].forEach((F,b)=>{g(s,`${F.deg} = ${F.rad} rad`,70,270+b*30,16)})}}}]},{id:"4.5",title:"Arc Length and Sector Area",content:`
                <h2>Calculating Arc Length and Sector Area Using Radians</h2>
                <p>Radians are particularly useful when calculating arc lengths and sector areas of circles. Here are the formulas:</p>
                <ul>
                    <li><strong>Arc Length:</strong> L = r  
                        <ul>
                            <li>L is the arc length</li>
                            <li>r is the radius of the circle</li>
                            <li> is the central angle in radians</li>
                        </ul>
                    </li>
                    <li><strong>Sector Area:</strong> A = (1/2)  r  
                        <ul>
                            <li>A is the area of the sector</li>
                            <li>r is the radius of the circle</li>
                            <li> is the central angle in radians</li>
                        </ul>
                    </li>
                </ul>
                <p>Use the sliders to explore how changing the radius and central angle affects the arc length and sector area.</p>
            `,sliders:[{id:"radius",label:"Radius",min:50,max:200,step:10,defaultValue:100,explanation:"Adjust the radius of the circle."},{id:"angle",label:"Central Angle (degrees)",min:0,max:360,step:1,defaultValue:90,explanation:"Adjust the central angle of the sector."}],visualizations:[{type:"canvas",setup:x=>Ae(600,600),update:x=>{const{ctx:s,radius:n=100,angle:f=90}=x;if(s){s.clearRect(0,0,600,600);const d=300,h=300,u=f*(Math.PI/180);he(s,d,h,n),s.beginPath(),s.moveTo(d,h),s.arc(d,h,n,0,-u,!0),s.lineTo(d,h),s.fillStyle="rgba(0, 255, 255, 0.2)",s.fill(),s.strokeStyle="#00ffff",s.stroke(),R(s,d,h,d+n,h),g(s,`r = ${n}`,d+n/2,h-20,16),g(s,`${f} = ${u.toFixed(2)} rad`,d+60,h-60,16);const c=n*u,r=.5*n*n*u;g(s,"Arc Length and Sector Area:",50,50,24),g(s,"Arc Length (L) = r  ",50,90,18),g(s,`L = ${n}  ${u.toFixed(2)} = ${c.toFixed(2)}`,70,120,16),g(s,"Sector Area (A) = (1/2)  r  ",50,160,18),g(s,`A = 0.5  ${n}  ${u.toFixed(2)} = ${r.toFixed(2)}`,70,190,16)}}}]}]},l={id:5,title:"Graphs of Trigonometric Functions",introduction:`
        <p>Welcome to our lesson on Graphs of Trigonometric Functions! In this lesson, we'll explore the visual representations of sine, cosine, and tangent functions.</p>
        <p>Understanding these graphs is crucial for recognizing patterns in periodic phenomena and solving trigonometric equations. We'll examine the key features of each graph and how they relate to one another.</p>
    `,prerequisites:[2,3,4],sublessons:[{id:"5.1",title:"The Sine Graph",content:`
                <h2>Plotting the Sine Function</h2>
                <p>The sine function is one of the most fundamental trigonometric functions. Its graph is a smooth, periodic wave that repeats every 2 radians (360).</p>
                <h3>Key Features of the Sine Graph:</h3>
                <ul>
                    <li><strong>Amplitude:</strong> The maximum distance between the midline and the curve. For y = sin(x), the amplitude is 1.</li>
                    <li><strong>Period:</strong> The distance after which the function starts repeating. For y = sin(x), the period is 2.</li>
                    <li><strong>Phase:</strong> The horizontal shift of the graph. The basic sine function is not shifted.</li>
                    <li><strong>Midline:</strong> The horizontal line halfway between the maximum and minimum values. For y = sin(x), the midline is y = 0.</li>
                </ul>
                <p>Use the sliders to adjust the amplitude, period, and phase of the sine function and observe how the graph changes.</p>
            `,sliders:[{id:"amplitude",label:"Amplitude",min:.1,max:2,step:.1,defaultValue:1,explanation:"Adjust the amplitude of the sine wave."},{id:"period",label:"Period",min:.5,max:4,step:.1,defaultValue:1,explanation:"Adjust the period of the sine wave. Note: This actually adjusts the frequency (1/period)."},{id:"phase",label:"Phase Shift",min:-Math.PI,max:Math.PI,step:.1,defaultValue:0,explanation:"Adjust the phase shift of the sine wave."}],visualizations:[{type:"canvas",setup:x=>{const s=document.createElement("canvas"),n=s.getContext("2d");return{canvas:s,ctx:n}},update:x=>{const{canvas:s,ctx:n,amplitude:f=1,period:d=1,phase:h=0}=x;if(n&&s){const u=s.parentElement;u&&(s.width=u.clientWidth,s.height=u.clientHeight);const c=s.width,r=s.height;n.clearRect(0,0,c,r);const p=r/2,F=c/2,b=c/12,A=r/8;n.strokeStyle="#00ffff",n.fillStyle="#00ffff",n.lineWidth=2,n.font=`${Math.max(12,r/30)}px Arial`,R(n,0,p,c,p),R(n,F,0,F,r),g(n,"y",F+10,20,Math.max(12,r/30)),g(n,"x",c-20,p+20,Math.max(12,r/30)),n.beginPath();for(let C=-6;C<=6;C+=.01){const j=f*Math.sin((C-h)*(2*Math.PI/d));n.lineTo(F+C*b,p-j*A)}n.stroke();const _=Math.max(12,r/30);g(n,`Amplitude: ${f.toFixed(2)}`,20,_+10,_),g(n,`Period: ${(d*2*Math.PI).toFixed(2)}`,20,_*2+20,_),g(n,`Phase Shift: ${h.toFixed(2)}`,20,_*3+30,_);const T=d*b;R(n,F,r-30,F+T,r-30),g(n,"Period",F+T/2-30,r-40,_),R(n,c-30,p,c-30,p-f*A),g(n,"Amplitude",c-100,p-f*A/2,_)}}}]},{id:"5.2",title:"The Cosine Graph",content:`
                <h2>Plotting the Cosine Function</h2>
                <p>The cosine function is closely related to the sine function. Its graph is also a smooth, periodic wave that repeats every 2 radians (360).</p>
                <h3>Key Features of the Cosine Graph:</h3>
                <ul>
                    <li><strong>Amplitude:</strong> Like sine, the amplitude of y = cos(x) is 1.</li>
                    <li><strong>Period:</strong> The period of y = cos(x) is also 2.</li>
                    <li><strong>Phase:</strong> The cosine function is shifted /2 radians (90) to the left compared to sine.</li>
                    <li><strong>Midline:</strong> The midline for y = cos(x) is also y = 0.</li>
                </ul>
                <h3>Relationship to Sine Graph:</h3>
                <p>The cosine graph is identical to the sine graph, but shifted /2 radians (90) to the left. In other words, cos(x) = sin(x + /2).</p>
                <p>Use the slider to compare the sine and cosine functions.</p>
            `,sliders:[{id:"phase",label:"Phase Shift",min:-Math.PI,max:Math.PI,step:.1,defaultValue:0,explanation:"Adjust the phase shift to see how sine and cosine relate."}],visualizations:[{type:"canvas",setup:x=>{const s=document.createElement("canvas"),n=s.getContext("2d");return{canvas:s,ctx:n}},update:x=>{const{canvas:s,ctx:n,phase:f=0}=x;if(n&&s){const d=s.parentElement;d&&(s.width=d.clientWidth,s.height=d.clientHeight);const h=s.width,u=s.height;n.clearRect(0,0,h,u);const c=u/2,r=h/2,p=h/12,F=u/8;n.strokeStyle="#00ffff",n.fillStyle="#00ffff",n.lineWidth=2,n.font=`${Math.max(12,u/30)}px Arial`,R(n,0,c,h,c),R(n,r,0,r,u),g(n,"y",r+10,20,Math.max(12,u/30)),g(n,"x",h-20,c+20,Math.max(12,u/30)),n.beginPath(),n.strokeStyle="blue";for(let A=-6;A<=6;A+=.01){const _=Math.sin((A-f)*2*Math.PI);n.lineTo(r+A*p,c-_*F)}n.stroke(),n.beginPath(),n.strokeStyle="red";for(let A=-6;A<=6;A+=.01){const _=Math.cos((A-f)*2*Math.PI);n.lineTo(r+A*p,c-_*F)}n.stroke();const b=Math.max(12,u/30);n.fillStyle="blue",g(n,"sin(x)",20,b+10,b),n.fillStyle="red",g(n,"cos(x)",20,b*2+20,b),n.fillStyle="#00ffff",g(n,`Phase Shift: ${f.toFixed(2)}`,20,b*3+30,b),g(n,"cos(x) = sin(x + /2)",h-200,30,b)}}}]},{id:"5.3",title:"The Tangent Graph",content:`
                <h2>Plotting the Tangent Function</h2>
                <p>The tangent function, defined as tan(x) = sin(x) / cos(x), has a graph that is quite different from sine and cosine. It's not a smooth wave, but instead has vertical asymptotes.</p>
                <h3>Key Features of the Tangent Graph:</h3>
                <ul>
                    <li><strong>Period:</strong> The tangent function repeats every  radians (180), half the period of sine and cosine.</li>
                    <li><strong>Asymptotes:</strong> The graph has vertical asymptotes at x = /2 + n, where n is any integer. These occur where cos(x) = 0.</li>
                    <li><strong>Range:</strong> The tangent function can take any real value, so its range is all real numbers.</li>
                    <li><strong>x-intercepts:</strong> The graph crosses the x-axis at x = n, where n is any integer.</li>
                </ul>
                <h3>Understanding Asymptotes:</h3>
                <p>Asymptotes occur because the tangent is undefined when cos(x) = 0. As x approaches these points, tan(x) grows arbitrarily large in the positive or negative direction.</p>
                <p>Use the slider to zoom in and out of the tangent graph and observe its behavior near the asymptotes.</p>
            `,sliders:[{id:"zoom",label:"Zoom Level",min:.5,max:5,step:.1,defaultValue:1,explanation:"Adjust the zoom level to see different parts of the tangent graph."}],visualizations:[{type:"canvas",setup:x=>{const s=document.createElement("canvas"),n=s.getContext("2d");return{canvas:s,ctx:n}},update:x=>{const{canvas:s,ctx:n,zoom:f=1}=x;if(n&&s){const d=s.parentElement;d&&(s.width=d.clientWidth,s.height=d.clientHeight);const h=s.width,u=s.height;n.clearRect(0,0,h,u);const c=u/2,r=h/2,p=h/(12/f),F=u/8;n.strokeStyle="#00ffff",n.fillStyle="#00ffff",n.lineWidth=2,n.font=`${Math.max(12,u/30)}px Arial`,R(n,0,c,h,c),R(n,r,0,r,u),g(n,"y",r+10,20,Math.max(12,u/30)),g(n,"x",h-20,c+20,Math.max(12,u/30)),n.beginPath();let b=null;for(let _=-6/f;_<=6/f;_+=.01){const C=Math.tan(_*Math.PI)*F;Math.abs(C)<u/2?(b!==null&&Math.abs(C-b)<u/2?n.lineTo(r+_*p,c-C):n.moveTo(r+_*p,c-C),b=C):b=null}n.stroke();for(let _=-2;_<=2;_++){const T=r+(_+.5)*Math.PI*p/2;T>=0&&T<=h&&(n.setLineDash([5,5]),R(n,T,0,T,u),n.setLineDash([]),g(n,`x = ${_}/2`,T-30,u-20,Math.max(12,u/30)))}const A=Math.max(12,u/30);g(n,"y = tan(x)",20,A+10,A),g(n,`Zoom: ${f.toFixed(1)}x`,20,A*2+20,A)}}}]},{id:"5.4",title:"Amplitude and Period",content:`
                <h2>Effects of A and B in y = A * sin(Bx)</h2>
                <p>The general form y = A * sin(Bx) allows us to modify the amplitude and period of the sine function:</p>
                <ul>
                    <li><strong>A: Amplitude</strong> - The absolute value of A determines the amplitude of the function.
                        <ul>
                            <li>If |A| > 1, the graph is stretched vertically.</li>
                            <li>If 0 < |A| < 1, the graph is compressed vertically.</li>
                            <li>If A < 0, the graph is reflected over the x-axis.</li>
                        </ul>
                    </li>
                    <li><strong>B: Period</strong> - B affects the period of the function.
                        <ul>
                            <li>The period is given by (2 / |B|).</li>
                            <li>If |B| > 1, the graph is compressed horizontally.</li>
                            <li>If 0 < |B| < 1, the graph is stretched horizontally.</li>
                            <li>If B < 0, the graph is reflected over the y-axis.</li>
                        </ul>
                    </li>
                </ul>
                <p>Use the sliders to adjust A and B and observe how they affect the sine graph.</p>
            `,sliders:[{id:"A",label:"A (Amplitude)",min:-3,max:3,step:.1,defaultValue:1,explanation:"Adjust the amplitude of the sine function."},{id:"B",label:"B (Period)",min:.1,max:3,step:.1,defaultValue:1,explanation:"Adjust the period of the sine function."}],visualizations:[{type:"canvas",setup:x=>{const s=document.createElement("canvas"),n=s.getContext("2d");return{canvas:s,ctx:n}},update:x=>{const{canvas:s,ctx:n,A:f=1,B:d=1}=x;if(n&&s){const h=s.parentElement;h&&(s.width=h.clientWidth,s.height=h.clientHeight);const u=s.width,c=s.height;n.clearRect(0,0,u,c);const r=c/2,p=u/2,F=u/12,b=c/8;n.strokeStyle="#00ffff",n.fillStyle="#00ffff",n.lineWidth=2,n.font=`${Math.max(12,c/30)}px Arial`,R(n,0,r,u,r),R(n,p,0,p,c),g(n,"y",p+10,20,Math.max(12,c/30)),g(n,"x",u-20,r+20,Math.max(12,c/30)),n.beginPath();for(let T=-6;T<=6;T+=.01){const C=f*Math.sin(d*T*2*Math.PI);n.lineTo(p+T*F,r-C*b)}n.stroke(),n.beginPath(),n.setLineDash([5,5]),n.strokeStyle="gray";for(let T=-6;T<=6;T+=.01){const C=Math.sin(T*2*Math.PI);n.lineTo(p+T*F,r-C*b)}n.stroke(),n.setLineDash([]),n.strokeStyle="#00ffff";const A=Math.max(12,c/30);g(n,`y = ${f.toFixed(1)} * sin(${d.toFixed(1)}x)`,20,A+10,A),g(n,`Amplitude: ${Math.abs(f).toFixed(1)}`,20,A*2+20,A),g(n,`Period: ${(2*Math.PI/Math.abs(d)).toFixed(2)}`,20,A*3+30,A),R(n,u-30,r,u-30,r-f*b),g(n,"Amplitude",u-100,r-Math.abs(f)*b/2,A);const _=2*Math.PI/Math.abs(d)*F;R(n,p,c-30,p+_,c-30),g(n,"Period",p+_/2-30,c-40,A),n.strokeStyle="rgba(255, 255, 255, 0.1)";for(let T=-6;T<=6;T++)R(n,p+T*F,0,p+T*F,c),R(n,0,r+T*b,u,r+T*b);n.strokeStyle="#00ffff"}}}]},{id:"5.5",title:"Phase Shift and Vertical Shift",content:`
                <h2>Effects of C and D in y = sin(x - C) + D</h2>
                <p>The general form y = sin(x - C) + D allows us to shift the sine function horizontally and vertically:</p>
                <ul>
                    <li><strong>C: Phase Shift</strong> - C determines the horizontal shift of the function.
                        <ul>
                            <li>The graph is shifted C units to the right.</li>
                            <li>If C is negative, the shift is to the left.</li>
                        </ul>
                    </li>
                    <li><strong>D: Vertical Shift</strong> - D determines the vertical shift of the function.
                        <ul>
                            <li>The graph is shifted D units up.</li>
                            <li>If D is negative, the shift is down.</li>
                        </ul>
                    </li>
                </ul>
                <p>Use the sliders to adjust C and D and observe how they affect the sine graph.</p>
            `,sliders:[{id:"C",label:"C (Phase Shift)",min:-Math.PI,max:Math.PI,step:.1,defaultValue:0,explanation:"Adjust the phase shift of the sine function."},{id:"D",label:"D (Vertical Shift)",min:-2,max:2,step:.1,defaultValue:0,explanation:"Adjust the vertical shift of the sine function."}],visualizations:[{type:"canvas",setup:x=>{const s=document.createElement("canvas"),n=s.getContext("2d");return{canvas:s,ctx:n}},update:x=>{const{canvas:s,ctx:n,C:f=0,D:d=0}=x;if(n&&s){const h=s.parentElement;h&&(s.width=h.clientWidth,s.height=h.clientHeight);const u=s.width,c=s.height;n.clearRect(0,0,u,c);const r=c/2,p=u/2,F=u/12,b=c/8;n.strokeStyle="#00ffff",n.fillStyle="#00ffff",n.lineWidth=2,n.font=`${Math.max(12,c/30)}px Arial`,R(n,0,r,u,r),R(n,p,0,p,c),g(n,"y",p+10,20,Math.max(12,c/30)),g(n,"x",u-20,r+20,Math.max(12,c/30)),n.beginPath();for(let T=-6;T<=6;T+=.01){const C=Math.sin(T*2*Math.PI-f)+d;n.lineTo(p+T*F,r-C*b)}n.stroke(),n.beginPath(),n.setLineDash([5,5]),n.strokeStyle="gray";for(let T=-6;T<=6;T+=.01){const C=Math.sin(T*2*Math.PI);n.lineTo(p+T*F,r-C*b)}n.stroke(),n.setLineDash([]),n.strokeStyle="#00ffff";const A=Math.max(12,c/30);g(n,`y = sin(x - ${f.toFixed(2)}) + ${d.toFixed(2)}`,20,A+10,A),g(n,`Phase Shift: ${f.toFixed(2)}`,20,A*2+20,A),g(n,`Vertical Shift: ${d.toFixed(2)}`,20,A*3+30,A);const _=f*F/(2*Math.PI);R(n,p,c-30,p+_,c-30),g(n,"Phase Shift",p+_/2-40,c-40,A),R(n,u-30,r,u-30,r-d*b),g(n,"Vertical Shift",u-120,r-d*b/2,A)}}}]},{id:"5.6",title:"Graphing Composite Trigonometric Functions",content:`
                <h2>Combining Multiple Transformations</h2>
                <p>We can combine all the transformations we've learned to create complex trigonometric functions. The general form is:</p>
                <p><strong>y = A * sin(B(x - C)) + D</strong></p>
                <p>Where:</p>
                <ul>
                    <li>A affects the amplitude</li>
                    <li>B affects the period</li>
                    <li>C affects the phase shift</li>
                    <li>D affects the vertical shift</li>
                </ul>
                <p>The order of operations is important when graphing these functions:</p>
                <ol>
                    <li>Start with the basic sine function</li>
                    <li>Apply the period change (B)</li>
                    <li>Apply the phase shift (C)</li>
                    <li>Apply the amplitude change (A)</li>
                    <li>Apply the vertical shift (D)</li>
                </ol>
                <p>Use the sliders to adjust all parameters and see how they combine to transform the sine graph.</p>
            `,sliders:[{id:"A",label:"A (Amplitude)",min:-3,max:3,step:.1,defaultValue:1,explanation:"Adjust the amplitude of the function."},{id:"B",label:"B (Period)",min:.1,max:3,step:.1,defaultValue:1,explanation:"Adjust the period of the function."},{id:"C",label:"C (Phase Shift)",min:-Math.PI,max:Math.PI,step:.1,defaultValue:0,explanation:"Adjust the phase shift of the function."},{id:"D",label:"D (Vertical Shift)",min:-2,max:2,step:.1,defaultValue:0,explanation:"Adjust the vertical shift of the function."}],visualizations:[{type:"canvas",setup:x=>{const s=document.createElement("canvas"),n=s.getContext("2d");return{canvas:s,ctx:n}},update:x=>{const{canvas:s,ctx:n,A:f=1,B:d=1,C:h=0,D:u=0}=x;if(n&&s){const c=s.parentElement;c&&(s.width=c.clientWidth,s.height=c.clientHeight);const r=s.width,p=s.height;n.clearRect(0,0,r,p);const F=p/2,b=r/2,A=r/12,_=p/8;n.strokeStyle="#00ffff",n.fillStyle="#00ffff",n.lineWidth=2,n.font=`${Math.max(12,p/30)}px Arial`,R(n,0,F,r,F),R(n,b,0,b,p),g(n,"y",b+10,20,Math.max(12,p/30)),g(n,"x",r-20,F+20,Math.max(12,p/30)),n.beginPath();for(let C=-6;C<=6;C+=.01){const j=f*Math.sin(d*(C-h))+u;n.lineTo(b+C*A,F-j*_)}n.stroke(),n.beginPath(),n.setLineDash([5,5]),n.strokeStyle="gray";for(let C=-6;C<=6;C+=.01){const j=Math.sin(C);n.lineTo(b+C*A,F-j*_)}n.stroke(),n.setLineDash([]),n.strokeStyle="#00ffff";const T=Math.max(12,p/30);g(n,`y = ${f.toFixed(1)} * sin(${d.toFixed(1)}(x - ${h.toFixed(2)})) + ${u.toFixed(2)}`,20,T+10,T),g(n,`Amplitude: ${Math.abs(f).toFixed(1)}`,20,T*2+20,T),g(n,`Period: ${(2*Math.PI/Math.abs(d)).toFixed(2)}`,20,T*3+30,T),g(n,`Phase Shift: ${h.toFixed(2)}`,20,T*4+40,T),g(n,`Vertical Shift: ${u.toFixed(2)}`,20,T*5+50,T),n.strokeStyle="rgba(255, 255, 255, 0.1)";for(let C=-6;C<=6;C++)R(n,b+C*A,0,b+C*A,p),R(n,0,F+C*_,r,F+C*_);n.strokeStyle="#00ffff"}}}]}]},m={id:6,title:"Trigonometric Identities",introduction:`
        <p>Welcome to our lesson on Trigonometric Identities! In this lesson, we'll explore fundamental relationships between trigonometric functions that are true for all angles.</p>
        <p>Understanding these identities is crucial for simplifying trigonometric expressions, solving equations, and proving other trigonometric relationships. They form the backbone of more advanced trigonometric manipulations and are essential in many areas of mathematics and physics.</p>
    `,prerequisites:[2,3,5],sublessons:[{id:"6.1",title:"Pythagorean Identity",content:`
                <h2>The Pythagorean Identity: sin + cos = 1</h2>
                <p>The Pythagorean identity is one of the most fundamental trigonometric identities. It states that for any angle :</p>
                <p style="text-align: center; font-size: 1.2em;"><strong>sin + cos = 1</strong></p>
                <p>This identity is derived from the Pythagorean theorem and the definitions of sine and cosine in the unit circle.</p>
                <h3>Proof using the Unit Circle:</h3>
                <ol>
                    <li>Consider a point (x, y) on the unit circle.</li>
                    <li>By definition of the unit circle, x + y = 1.</li>
                    <li>In the unit circle, x = cos  and y = sin .</li>
                    <li>Substituting these into the unit circle equation: cos + sin = 1.</li>
                    <li>Rearranging: sin + cos = 1.</li>
                </ol>
                <p>This identity is incredibly useful for simplifying trigonometric expressions and solving equations.</p>
                <p>Use the slider below to see how sin and cos always sum to 1 for any angle.</p>
            `,sliders:[{id:"angle",label:"Angle  (degrees)",min:0,max:360,step:1,defaultValue:0,explanation:"Adjust the angle to see how sin and cos change while their sum remains 1."}],visualizations:[{type:"canvas",setup:x=>{const s=document.createElement("canvas"),n=s.getContext("2d");return{canvas:s,ctx:n}},update:x=>{const{canvas:s,ctx:n,angle:f=0}=x;if(n&&s){const d=s.parentElement;d&&(s.width=d.clientWidth,s.height=d.clientHeight);const h=s.width,u=s.height;n.clearRect(0,0,h,u);const c=h/2,r=u/2,p=Math.min(h,u)*.4;n.strokeStyle="#00ffff",n.fillStyle="#00ffff",n.lineWidth=2,n.font=`${Math.max(12,u/30)}px Arial`,he(n,c,r,p);const F=f*Math.PI/180,b=Math.sin(F),A=Math.cos(F);n.beginPath(),n.moveTo(c,r),n.arc(c,r,p/4,0,-F,!0),n.stroke(),le(n,c+A*p,r-b*p,5),n.setLineDash([5,5]),R(n,c+A*p,r-b*p,c+A*p,r),R(n,c+A*p,r-b*p,c,r-b*p),n.setLineDash([]),g(n,`sin  = ${b.toFixed(3)}`,c+10,r-b*p/2,Math.max(12,u/30)),g(n,`cos  = ${A.toFixed(3)}`,c+A*p/2,r+20,Math.max(12,u/30));const _=Math.max(16,u/20);g(n,`sin + cos = ${b.toFixed(3)} + ${A.toFixed(3)} = ${(b*b+A*A).toFixed(3)}`,20,u-60,_),g(n,` = ${f}`,20,u-20,_)}}}]},{id:"6.2",title:"Reciprocal Identities",content:`
                <h2>Reciprocal Identities</h2>
                <p>Reciprocal identities relate the six trigonometric functions: sine (sin), cosine (cos), tangent (tan), cosecant (csc), secant (sec), and cotangent (cot).</p>
                <p>The main reciprocal identities are:</p>
                <ul>
                    <li>sin  = 1 / csc   (and csc  = 1 / sin )</li>
                    <li>cos  = 1 / sec   (and sec  = 1 / cos )</li>
                    <li>tan  = 1 / cot   (and cot  = 1 / tan )</li>
                </ul>
                <p>These identities are based on the definitions of csc, sec, and cot:</p>
                <ul>
                    <li>csc  is defined as the reciprocal of sin </li>
                    <li>sec  is defined as the reciprocal of cos </li>
                    <li>cot  is defined as the reciprocal of tan </li>
                </ul>
                <p>Understanding these relationships helps in simplifying trigonometric expressions and solving equations involving these functions.</p>
                <p>Use the slider below to see how these reciprocal relationships hold for different angles.</p>
            `,sliders:[{id:"angle",label:"Angle  (degrees)",min:0,max:360,step:1,defaultValue:30,explanation:"Adjust the angle to see how the trigonometric functions and their reciprocals change."}],visualizations:[{type:"canvas",setup:x=>{const s=document.createElement("canvas"),n=s.getContext("2d");return{canvas:s,ctx:n}},update:x=>{const{canvas:s,ctx:n,angle:f=30}=x;if(n&&s){const d=s.parentElement;d&&(s.width=d.clientWidth,s.height=d.clientHeight);const h=s.width,u=s.height;n.clearRect(0,0,h,u),n.fillStyle="#00ffff",n.font=`${Math.max(12,u/30)}px Arial`;const c=f*Math.PI/180,r=Math.sin(c),p=Math.cos(c),F=Math.tan(c),b=1/r,A=1/p,_=1/F,T=Math.max(14,u/25);g(n,` = ${f}`,20,T+10,T),g(n,`sin  = ${r.toFixed(3)}  |  csc  = ${b.toFixed(3)}`,20,T*2+20,T),g(n,`cos  = ${p.toFixed(3)}  |  sec  = ${A.toFixed(3)}`,20,T*3+30,T),g(n,`tan  = ${F.toFixed(3)}  |  cot  = ${_.toFixed(3)}`,20,T*4+40,T),g(n,`sin  * csc  = ${(r*b).toFixed(3)}`,20,T*6+60,T),g(n,`cos  * sec  = ${(p*A).toFixed(3)}`,20,T*7+70,T),g(n,`tan  * cot  = ${(F*_).toFixed(3)}`,20,T*8+80,T)}}}]},{id:"6.3",title:"Quotient Identities",content:`
                <h2>Quotient Identities</h2>
                <p>Quotient identities relate tangent, sine, and cosine functions. The primary quotient identities are:</p>
                <ul>
                    <li><strong>tan  = sin  / cos </strong> (where cos   0)</li>
                    <li><strong>cot  = cos  / sin </strong> (where sin   0)</li>
                </ul>
                <p>These identities are derived from the definitions of trigonometric functions in the unit circle.</p>
                <h3>Proof of tan  = sin  / cos :</h3>
                <ol>
                    <li>In a unit circle, for any angle , we have a point (x, y) where:
                        <ul>
                            <li>x = cos </li>
                            <li>y = sin </li>
                        </ul>
                    </li>
                    <li>Tangent is defined as the ratio of y to x on the unit circle:
                        <p>tan  = y / x</p>
                    </li>
                    <li>Substituting the definitions of sine and cosine:
                        <p>tan  = sin  / cos </p>
                    </li>
                </ol>
                <p>These identities are particularly useful when converting between trigonometric expressions or solving equations involving these functions.</p>
                <p>Use the slider below to see how these quotient identities hold for different angles.</p>
            `,sliders:[{id:"angle",label:"Angle  (degrees)",min:0,max:360,step:1,defaultValue:45,explanation:"Adjust the angle to see how the quotient identities hold."}],visualizations:[{type:"canvas",setup:x=>{const s=document.createElement("canvas"),n=s.getContext("2d");return{canvas:s,ctx:n}},update:x=>{const{canvas:s,ctx:n,angle:f=45}=x;if(n&&s){const d=s.parentElement;d&&(s.width=d.clientWidth,s.height=d.clientHeight);const h=s.width,u=s.height;n.clearRect(0,0,h,u);const c=h/2,r=u/2,p=Math.min(h,u)*.4;n.strokeStyle="#00ffff",n.fillStyle="#00ffff",n.lineWidth=2,n.font=`${Math.max(12,u/30)}px Arial`,he(n,c,r,p);const F=f*Math.PI/180,b=Math.sin(F),A=Math.cos(F),_=Math.tan(F);n.beginPath(),n.moveTo(c,r),n.arc(c,r,p/4,0,-F,!0),n.stroke(),le(n,c+A*p,r-b*p,5),n.setLineDash([5,5]),R(n,c+A*p,r-b*p,c+A*p,r),R(n,c+A*p,r-b*p,c,r-b*p),n.setLineDash([]);const T=Math.max(12,u/30);if(g(n,`sin  = ${b.toFixed(3)}`,10,T+10,T),g(n,`cos  = ${A.toFixed(3)}`,10,T*2+20,T),g(n,`tan  = ${_.toFixed(3)}`,10,T*3+30,T),g(n,"tan  = sin  / cos ",10,u-T*3-30,T),g(n,`${_.toFixed(3)} = ${b.toFixed(3)} / ${A.toFixed(3)} = ${(b/A).toFixed(3)}`,10,u-T*2-20,T),b!==0){const C=1/_;g(n,"cot  = cos  / sin ",10,u-T-10,T),g(n,`${C.toFixed(3)} = ${A.toFixed(3)} / ${b.toFixed(3)} = ${(A/b).toFixed(3)}`,10,u-10,T)}}}}]},{id:"6.4",title:"Sum and Difference Formulas",content:`
                <h2>Sum and Difference Formulas</h2>
                <p>Sum and difference formulas allow us to express the sine, cosine, and tangent of the sum or difference of two angles in terms of the sines and cosines of the individual angles.</p>
                <h3>Key Formulas:</h3>
                <ul>
                    <li><strong>Sine Sum Formula:</strong> sin(A + B) = sin A cos B + cos A sin B</li>
                    <li><strong>Sine Difference Formula:</strong> sin(A - B) = sin A cos B - cos A sin B</li>
                    <li><strong>Cosine Sum Formula:</strong> cos(A + B) = cos A cos B - sin A sin B</li>
                    <li><strong>Cosine Difference Formula:</strong> cos(A - B) = cos A cos B + sin A sin B</li>
                    <li><strong>Tangent Sum Formula:</strong> tan(A + B) = (tan A + tan B) / (1 - tan A tan B)</li>
                    <li><strong>Tangent Difference Formula:</strong> tan(A - B) = (tan A - tan B) / (1 + tan A tan B)</li>
                </ul>
                <p>These formulas are particularly useful in simplifying trigonometric expressions and solving complex trigonometric equations.</p>
                <p>Use the sliders below to explore how these formulas work for different angle combinations.</p>
            `,sliders:[{id:"angleA",label:"Angle A (degrees)",min:0,max:360,step:1,defaultValue:30,explanation:"Adjust angle A"},{id:"angleB",label:"Angle B (degrees)",min:0,max:360,step:1,defaultValue:45,explanation:"Adjust angle B"}],visualizations:[{type:"canvas",setup:x=>{const s=document.createElement("canvas"),n=s.getContext("2d");return{canvas:s,ctx:n}},update:x=>{const{canvas:s,ctx:n,angleA:f=30,angleB:d=45}=x;if(n&&s){const h=s.parentElement;h&&(s.width=h.clientWidth,s.height=h.clientHeight);const u=s.width,c=s.height;n.clearRect(0,0,u,c),n.fillStyle="#00ffff",n.font=`${Math.max(12,c/40)}px Arial`;const r=f*Math.PI/180,p=d*Math.PI/180,F=Math.sin(r),b=Math.cos(r),A=Math.sin(p),_=Math.cos(p),T=Math.sin(r+p),C=Math.sin(r-p),j=Math.cos(r+p),O=Math.cos(r-p),k=Math.max(12,c/40);g(n,`A = ${f}, B = ${d}`,20,k+10,k),g(n,`sin(A + B) = ${T.toFixed(4)}`,20,k*3+30,k),g(n,`sin A cos B + cos A sin B = ${(F*_+b*A).toFixed(4)}`,20,k*4+40,k),g(n,`sin(A - B) = ${C.toFixed(4)}`,20,k*6+60,k),g(n,`sin A cos B - cos A sin B = ${(F*_-b*A).toFixed(4)}`,20,k*7+70,k),g(n,`cos(A + B) = ${j.toFixed(4)}`,20,k*9+90,k),g(n,`cos A cos B - sin A sin B = ${(b*_-F*A).toFixed(4)}`,20,k*10+100,k),g(n,`cos(A - B) = ${O.toFixed(4)}`,20,k*12+120,k),g(n,`cos A cos B + sin A sin B = ${(b*_+F*A).toFixed(4)}`,20,k*13+130,k)}}}]},{id:"6.5",title:"Double Angle and Half Angle Formulas",content:`
                <h2>Double Angle and Half Angle Formulas</h2>
                <p>Double angle and half angle formulas are special cases of the sum and difference formulas. They allow us to express trigonometric functions of 2 or /2 in terms of functions of .</p>
                <h3>Double Angle Formulas:</h3>
                <ul>
                    <li><strong>sin(2) = 2 sin  cos </strong></li>
                    <li><strong>cos(2) = cos  - sin  = 2 cos  - 1 = 1 - 2 sin </strong></li>
                    <li><strong>tan(2) = (2 tan ) / (1 - tan )</strong></li>
                </ul>
                <h3>Half Angle Formulas:</h3>
                <ul>
                    <li><strong>sin(/2) = [(1 - cos ) / 2]</strong></li>
                    <li><strong>cos(/2) = [(1 + cos ) / 2]</strong></li>
                    <li><strong>tan(/2) = [(1 - cos ) / (1 + cos )] = (1 - cos ) / sin  = sin  / (1 + cos )</strong></li>
                </ul>
                <p>These formulas are particularly useful in integrating certain trigonometric functions and solving trigonometric equations.</p>
                <p>Use the slider below to see how these formulas work for different angles.</p>
            `,sliders:[{id:"angle",label:"Angle  (degrees)",min:0,max:360,step:1,defaultValue:30,explanation:"Adjust the angle  to see how double and half angle formulas work."}],visualizations:[{type:"canvas",setup:x=>{const s=document.createElement("canvas"),n=s.getContext("2d");return{canvas:s,ctx:n}},update:x=>{const{canvas:s,ctx:n,angle:f=30}=x;if(n&&s){const d=s.parentElement;d&&(s.width=d.clientWidth,s.height=d.clientHeight);const h=s.width,u=s.height;n.clearRect(0,0,h,u),n.fillStyle="#00ffff",n.font=`${Math.max(12,u/40)}px Arial`;const c=f*Math.PI/180,r=Math.sin(c),p=Math.cos(c),F=Math.tan(c),b=Math.sin(2*c),A=Math.cos(2*c),_=Math.tan(2*c),T=Math.sin(c/2),C=Math.max(12,u/40);g(n,` = ${f}`,20,C+10,C),g(n,`sin(2) = ${b.toFixed(4)}`,20,C*3+30,C),g(n,`2 sin  cos  = ${(2*r*p).toFixed(4)}`,20,C*4+40,C),g(n,`cos(2) = ${A.toFixed(4)}`,20,C*6+60,C),g(n,`cos  - sin  = ${(p*p-r*r).toFixed(4)}`,20,C*7+70,C),g(n,`tan(2) = ${_.toFixed(4)}`,20,C*9+90,C),g(n,`(2 tan ) / (1 - tan ) = ${(2*F/(1-F*F)).toFixed(4)}`,20,C*10+100,C),g(n,`sin(/2) = ${T.toFixed(4)}`,20,C*12+120,C),g(n,`[(1 - cos ) / 2] = ${Math.sqrt((1-p)/2).toFixed(4)}`,20,C*13+130,C)}}}]},{id:"6.6",title:"Product-to-Sum and Sum-to-Product Formulas",content:`
                <h2>Product-to-Sum and Sum-to-Product Formulas</h2>
                <p>These formulas allow us to convert between products of trigonometric functions and sums or differences of trigonometric functions. They are particularly useful in integration and simplification of trigonometric expressions.</p>
                <h3>Product-to-Sum Formulas:</h3>
                <ul>
                    <li><strong>sin A cos B = 1/2[sin(A+B) + sin(A-B)]</strong></li>
                    <li><strong>cos A sin B = 1/2[sin(A+B) - sin(A-B)]</strong></li>
                    <li><strong>cos A cos B = 1/2[cos(A+B) + cos(A-B)]</strong></li>
                    <li><strong>sin A sin B = 1/2[cos(A-B) - cos(A+B)]</strong></li>
                </ul>
                <h3>Sum-to-Product Formulas:</h3>
                <ul>
                    <li><strong>sin A + sin B = 2 sin((A+B)/2) cos((A-B)/2)</strong></li>
                    <li><strong>sin A - sin B = 2 cos((A+B)/2) sin((A-B)/2)</strong></li>
                    <li><strong>cos A + cos B = 2 cos((A+B)/2) cos((A-B)/2)</strong></li>
                    <li><strong>cos A - cos B = -2 sin((A+B)/2) sin((A-B)/2)</strong></li>
                </ul>
                <p>Use the sliders below to explore how these formulas work for different angle combinations.</p>
            `,sliders:[{id:"angleA",label:"Angle A (degrees)",min:0,max:360,step:1,defaultValue:30,explanation:"Adjust angle A"},{id:"angleB",label:"Angle B (degrees)",min:0,max:360,step:1,defaultValue:45,explanation:"Adjust angle B"}],visualizations:[{type:"canvas",setup:x=>{const s=document.createElement("canvas"),n=s.getContext("2d");return{canvas:s,ctx:n}},update:x=>{const{canvas:s,ctx:n,angleA:f=30,angleB:d=45}=x;if(n&&s){const h=s.parentElement;h&&(s.width=h.clientWidth,s.height=h.clientHeight);const u=s.width,c=s.height;n.clearRect(0,0,u,c),n.fillStyle="#00ffff",n.font=`${Math.max(12,c/40)}px Arial`;const r=f*Math.PI/180,p=d*Math.PI/180,F=Math.sin(r),b=Math.cos(r),A=Math.sin(p),_=Math.cos(p),T=F*_,C=b*_,j=F+A,O=b+_,k=Math.max(12,c/40);g(n,`A = ${f}, B = ${d}`,10,k+10,k),g(n,"Product-to-Sum:",10,k*3+30,k),g(n,`sin A cos B = ${T.toFixed(4)}`,10,k*4+40,k),g(n,`1/2[sin(A+B) + sin(A-B)] = ${(.5*(Math.sin(r+p)+Math.sin(r-p))).toFixed(4)}`,10,k*5+50,k),g(n,`cos A cos B = ${C.toFixed(4)}`,10,k*7+70,k),g(n,`1/2[cos(A+B) + cos(A-B)] = ${(.5*(Math.cos(r+p)+Math.cos(r-p))).toFixed(4)}`,10,k*8+80,k),g(n,"Sum-to-Product:",10,k*10+100,k),g(n,`sin A + sin B = ${j.toFixed(4)}`,10,k*11+110,k),g(n,`2 sin((A+B)/2) cos((A-B)/2) = ${(2*Math.sin((r+p)/2)*Math.cos((r-p)/2)).toFixed(4)}`,10,k*12+120,k),g(n,`cos A + cos B = ${O.toFixed(4)}`,10,k*14+140,k),g(n,`2 cos((A+B)/2) cos((A-B)/2) = ${(2*Math.cos((r+p)/2)*Math.cos((r-p)/2)).toFixed(4)}`,10,k*15+150,k)}}}]}]},v={id:7,title:"Solving Trigonometric Equations",introduction:`
        <p>Welcome to our lesson on Solving Trigonometric Equations! In this lesson, we'll explore various techniques for solving equations involving trigonometric functions.</p>
        <p>Trigonometric equations appear in many areas of mathematics, physics, and engineering. Understanding how to solve these equations is crucial for analyzing periodic phenomena, wave motion, and many other real-world applications.</p>
        <p>We'll start with basic solving techniques and then move on to more specific types of trigonometric equations.</p>
    `,prerequisites:[2,3,5,6],sublessons:[{id:"7.1",title:"Basic Equation Solving Techniques",content:`
                <h2>Using Algebraic Methods with Trigonometric Functions</h2>
                <p>When solving trigonometric equations, we often use algebraic techniques similar to those used for solving other types of equations. Here are some key strategies:</p>
                <ol>
                    <li><strong>Isolation:</strong> Isolate the trigonometric function on one side of the equation.</li>
                    <li><strong>Factoring:</strong> Factor the equation if possible to break it into simpler parts.</li>
                    <li><strong>Substitution:</strong> Sometimes it's helpful to substitute a variable for a trigonometric expression.</li>
                    <li><strong>Using Identities:</strong> Apply trigonometric identities to simplify the equation.</li>
                    <li><strong>Finding Reference Angles:</strong> Use the unit circle to find all solutions within a given interval.</li>
                </ol>
                <p>Remember, when solving trigonometric equations:</p>
                <ul>
                    <li>Solutions are often periodic, meaning there may be infinitely many solutions.</li>
                    <li>It's common to be asked to find solutions within a specific interval, like [0, 2].</li>
                    <li>Always check your solutions by substituting them back into the original equation.</li>
                </ul>
                <p>Let's look at a simple example: solving cos x = 0</p>
                <ol>
                    <li>We know that cos x = 0 when x is at a 90 or 270 angle on the unit circle.</li>
                    <li>In radians, these angles are /2 and 3/2.</li>
                    <li>The general solution is: x = /2 + n or x = 3/2 + n, where n is any integer.</li>
                </ol>
                <p>Use the slider below to visualize this solution on the unit circle.</p>
            `,sliders:[{id:"angle",label:"Angle (degrees)",min:0,max:360,step:1,defaultValue:90,explanation:"Adjust the angle to see where cos x = 0 on the unit circle."}],visualizations:[{type:"canvas",setup:x=>{const s=document.createElement("canvas"),n=s.getContext("2d");return{canvas:s,ctx:n}},update:x=>{const{canvas:s,ctx:n,angle:f=90}=x;if(n&&s){const d=s.parentElement;d&&(s.width=d.clientWidth,s.height=d.clientHeight);const h=s.width,u=s.height;n.clearRect(0,0,h,u);const c=h/2,r=u/2,p=Math.min(h,u)*.4;n.strokeStyle="#00ffff",n.fillStyle="#00ffff",n.lineWidth=2,n.font=`${Math.max(12,u/30)}px Arial`,he(n,c,r,p),R(n,c-p,r,c+p,r),R(n,c,r-p,c,r+p);const F=f*Math.PI/180,b=Math.cos(F),A=Math.sin(F);n.beginPath(),n.moveTo(c,r),n.arc(c,r,p,0,-F,!0),n.stroke(),le(n,c+b*p,r-A*p,5),n.setLineDash([5,5]),R(n,c+b*p,r-A*p,c+b*p,r),n.setLineDash([]);const _=Math.max(12,u/30);g(n,`Angle: ${f}`,10,_+10,_),g(n,`cos x = ${b.toFixed(3)}`,10,_*2+20,_),Math.abs(b)<.01&&(n.strokeStyle="yellow",n.lineWidth=3,he(n,c+b*p,r-A*p,10),g(n,"Solution!",c+b*p+15,r-A*p-15,_))}}}]},{id:"7.2",title:"Equations Involving a Single Trigonometric Function",content:`
                <h2>Solving Equations like sin x = 0.5</h2>
                <p>When solving equations involving a single trigonometric function, we follow these general steps:</p>
                <ol>
                    <li>Isolate the trigonometric function on one side of the equation.</li>
                    <li>If the equation is not in the form function(x) = 1, 0, or 1/2, use the inverse trigonometric function to find the reference angle.</li>
                    <li>Find the reference angle using the inverse trigonometric function or recall standard angles.</li>
                    <li>Determine all angles that have the same trigonometric value within the desired interval.</li>
                </ol>
                <p>Let's solve the equation: sin x = 0.5</p>
                <ol>
                    <li>The equation is already isolated.</li>
                    <li>We can recall that this is a standard angle: sin(30) = 0.5, or we can use arcsin(0.5)  30.</li>
                    <li>In radians, this is /6.</li>
                    <li>The general solution is: x = /6 + 2n or x =  - /6 + 2n = 5/6 + 2n, where n is any integer.</li>
                </ol>
                <p>Use the slider below to visualize the solutions to sin x = 0.5 on the unit circle.</p>
            `,sliders:[{id:"angle",label:"Angle (degrees)",min:0,max:360,step:1,defaultValue:30,explanation:"Adjust the angle to see where sin x = 0.5 on the unit circle."}],visualizations:[{type:"canvas",setup:x=>{const s=document.createElement("canvas"),n=s.getContext("2d");return{canvas:s,ctx:n}},update:x=>{const{canvas:s,ctx:n,angle:f=30}=x;if(n&&s){const d=s.parentElement;d&&(s.width=d.clientWidth,s.height=d.clientHeight);const h=s.width,u=s.height;n.clearRect(0,0,h,u);const c=h/2,r=u/2,p=Math.min(h,u)*.4;n.strokeStyle="#00ffff",n.fillStyle="#00ffff",n.lineWidth=2,n.font=`${Math.max(12,u/30)}px Arial`,he(n,c,r,p),R(n,c-p,r,c+p,r),R(n,c,r-p,c,r+p);const F=f*Math.PI/180,b=Math.cos(F),A=Math.sin(F);n.beginPath(),n.moveTo(c,r),n.arc(c,r,p,0,-F,!0),n.stroke(),le(n,c+b*p,r-A*p,5),n.setLineDash([5,5]),R(n,c+b*p,r-A*p,c,r-A*p),n.setLineDash([]);const _=Math.max(12,u/30);g(n,`Angle: ${f}`,10,_+10,_),g(n,`sin x = ${A.toFixed(3)}`,10,_*2+20,_),Math.abs(A-.5)<.01&&(n.strokeStyle="yellow",n.lineWidth=3,he(n,c+b*p,r-A*p,10),g(n,"Solution!",c+b*p+15,r-A*p-15,_)),n.strokeStyle="red",R(n,c-p,r-.5*p,c+p,r-.5*p),g(n,"y = 0.5",c+p+5,r-.5*p,_)}}}]},{id:"7.3",title:"Equations Involving Multiple Trigonometric Functions",content:`
                <h2>Solving Equations Like sin x + cos x = 1</h2>
                <p>When dealing with equations involving multiple trigonometric functions, we often need to combine various techniques and identities. Here's a general approach:</p>
                <ol>
                    <li>Look for opportunities to use trigonometric identities to simplify the equation.</li>
                    <li>If possible, try to express the equation in terms of a single trigonometric function.</li>
                    <li>Consider squaring both sides if it helps to eliminate radicals or simplify the equation.</li>
                    <li>Use algebraic techniques like substitution or factoring when appropriate.</li>
                    <li>Solve for the unknown angle, remembering to find all solutions within the desired interval.</li>
                </ol>
                <p>Let's solve the equation: sin x + cos x = 1</p>
                <ol>
                    <li>This equation doesn't immediately simplify with common identities, so let's approach it algebraically.</li>
                    <li>Subtract cos x from both sides: sin x = 1 - cos x</li>
                    <li>Square both sides: sin x = (1 - cos x)</li>
                    <li>Expand the right side: sin x = 1 - 2cos x + cos x</li>
                    <li>Use the Pythagorean identity (sin x + cos x = 1) to replace sin x with 1 - cos x:
                       1 - cos x = 1 - 2cos x + cos x</li>
                    <li>Simplify: -cos x = -2cos x</li>
                    <li>Add cos x to both sides: 0 = -2cos x + cos x</li>
                    <li>Factor out cos x: 0 = cos x(-2 + cos x)</li>
                    <li>Solve the equation: cos x = 0 or cos x = 2</li>
                    <li>cos x = 0 when x = /2 + n, where n is any integer</li>
                    <li>cos x = 2 has no solution (cosine is always between -1 and 1)</li>
                    <li>Check the solution: When x = /2, sin(/2) + cos(/2) = 1 + 0 = 1</li>
                </ol>
                <p>Use the slider below to visualize the solution to sin x + cos x = 1 on the unit circle.</p>
            `,sliders:[{id:"angle",label:"Angle (degrees)",min:0,max:360,step:1,defaultValue:90,explanation:"Adjust the angle to see where sin x + cos x = 1 on the unit circle."}],visualizations:[{type:"canvas",setup:x=>{const s=document.createElement("canvas"),n=s.getContext("2d");return{canvas:s,ctx:n}},update:x=>{const{canvas:s,ctx:n,angle:f=90}=x;if(n&&s){const d=s.parentElement;d&&(s.width=d.clientWidth,s.height=d.clientHeight);const h=s.width,u=s.height;n.clearRect(0,0,h,u);const c=h/2,r=u/2,p=Math.min(h,u)*.4;n.strokeStyle="#00ffff",n.fillStyle="#00ffff",n.lineWidth=2,n.font=`${Math.max(12,u/30)}px Arial`,he(n,c,r,p),R(n,c-p,r,c+p,r),R(n,c,r-p,c,r+p);const F=f*Math.PI/180,b=Math.sin(F),A=Math.cos(F);n.beginPath(),n.moveTo(c,r),n.arc(c,r,p,0,-F,!0),n.stroke(),le(n,c+A*p,r-b*p,5),n.setLineDash([5,5]),R(n,c+A*p,r-b*p,c+A*p,r),R(n,c+A*p,r-b*p,c,r-b*p),n.setLineDash([]);const _=Math.max(12,u/30);g(n,`Angle: ${f}`,10,_+10,_),g(n,`sin x = ${b.toFixed(3)}`,10,_*2+20,_),g(n,`cos x = ${A.toFixed(3)}`,10,_*3+30,_),g(n,`sin x + cos x = ${(b+A).toFixed(3)}`,10,_*4+40,_),Math.abs(b+A-1)<.01&&(n.strokeStyle="yellow",n.lineWidth=3,he(n,c+A*p,r-b*p,10),g(n,"Solution!",c+A*p+15,r-b*p-15,_))}}}]},{id:"7.4",title:"Trigonometric Substitution",content:`
                <h2>Using Substitution to Simplify Complex Equations</h2>
                <p>Trigonometric substitution is a powerful technique for simplifying complex trigonometric equations. The basic idea is to replace a trigonometric expression with a single variable, solve the resulting equation, and then solve for the original variable.</p>
                <p>Common substitutions include:</p>
                <ul>
                    <li>Let u = sin x</li>
                    <li>Let u = cos x</li>
                    <li>Let u = tan x</li>
                </ul>
                <p>Steps for using trigonometric substitution:</p>
                <ol>
                    <li>Identify a trigonometric expression that appears multiple times in the equation.</li>
                    <li>Substitute this expression with a new variable (often 'u').</li>
                    <li>Rewrite the equation in terms of the new variable.</li>
                    <li>Solve the equation for the new variable.</li>
                    <li>Substitute back to find the solution in terms of the original variable.</li>
                    <li>Solve for the original variable and find all solutions within the desired interval.</li>
                </ol>
                <p>Let's solve the equation: sin x - sin x - 1 = 0</p>
                <ol>
                    <li>Let u = sin x</li>
                    <li>The equation becomes: u - u - 1 = 0</li>
                    <li>This is a quadratic equation. We can solve it using the quadratic formula:
                       u = [-(-1)  ((-1) - 4(1)(-1))] / (2(1)) = (1  5) / 2</li>
                    <li>u = (1 + 5) / 2 or u = (1 - 5) / 2</li>
                    <li>Substituting back: sin x = (1 + 5) / 2 or sin x = (1 - 5) / 2</li>
                    <li>The second solution can be discarded as sin x is always between -1 and 1</li>
                    <li>Solve sin x = (1 + 5) / 2  0.618</li>
                    <li>x = arcsin(0.618)  0.665 radians or 38.17</li>
                    <li>The general solution is: x = 0.665 + 2n or x =  - 0.665 + 2n, where n is any integer</li>
                </ol>
                <p>Use the slider below to visualize the solution to sin x - sin x - 1 = 0 on the unit circle.</p>
            `,sliders:[{id:"angle",label:"Angle (degrees)",min:0,max:360,step:1,defaultValue:38,explanation:"Adjust the angle to see where sin x - sin x - 1 = 0 on the unit circle."}],visualizations:[{type:"canvas",setup:x=>{const s=document.createElement("canvas"),n=s.getContext("2d");return{canvas:s,ctx:n}},update:x=>{const{canvas:s,ctx:n,angle:f=38}=x;if(n&&s){const d=s.parentElement;d&&(s.width=d.clientWidth,s.height=d.clientHeight);const h=s.width,u=s.height;n.clearRect(0,0,h,u);const c=h/2,r=u/2,p=Math.min(h,u)*.4;n.strokeStyle="#00ffff",n.fillStyle="#00ffff",n.lineWidth=2,n.font=`${Math.max(12,u/30)}px Arial`,he(n,c,r,p),R(n,c-p,r,c+p,r),R(n,c,r-p,c,r+p);const F=f*Math.PI/180,b=Math.sin(F);n.beginPath(),n.moveTo(c,r),n.arc(c,r,p,0,-F,!0),n.stroke();const A=Math.cos(F),_=b;le(n,c+A*p,r-_*p,5),n.setLineDash([5,5]),R(n,c+A*p,r-_*p,c,r-_*p),n.setLineDash([]);const T=Math.max(12,u/30);g(n,`Angle: ${f}`,10,T+10,T),g(n,`sin x = ${b.toFixed(3)}`,10,T*2+20,T),g(n,`sin x - sin x - 1 = ${(b*b-b-1).toFixed(3)}`,10,T*3+30,T),Math.abs(b*b-b-1)<.01&&(n.strokeStyle="yellow",n.lineWidth=3,he(n,c+A*p,r-_*p,10),g(n,"Solution!",c+A*p+15,r-_*p-15,T));const C=(1+Math.sqrt(5))/2;n.strokeStyle="red",R(n,c-p,r-C*p,c+p,r-C*p),g(n,"y = (1 + 5) / 2",c+p+5,r-C*p,T)}}}]}]},y={id:8,title:"Applications of Trigonometry",introduction:`
        <p>Welcome to our lesson on Applications of Trigonometry! In this lesson, we'll explore how trigonometric concepts are used in various real-world situations.</p>
        <p>Trigonometry has a wide range of practical applications, from measuring heights of tall structures to navigating ships and planes, and even describing circular motion in physics. Understanding these applications helps us appreciate the power and versatility of trigonometry in solving real-world problems.</p>
    `,prerequisites:[2,3,5,7],sublessons:[{id:"8.1",title:"Finding Heights and Distances",content:`
                <h2>Using Trigonometry for Indirect Measurement</h2>
                <p>One of the most practical applications of trigonometry is in measuring heights and distances that are difficult or impossible to measure directly. This technique is often used in surveying, construction, and astronomy.</p>
                <h3>Key Concepts:</h3>
                <ul>
                    <li><strong>Angle of Elevation:</strong> The angle formed between the horizontal line of sight and the line of sight to an object above the horizontal.</li>
                    <li><strong>Angle of Depression:</strong> The angle formed between the horizontal line of sight and the line of sight to an object below the horizontal.</li>
                    <li><strong>Triangulation:</strong> A technique using the angles and sides of triangles to determine distances.</li>
                </ul>
                <h3>Example Problem:</h3>
                <p>A surveyor wants to measure the height of a tall building. Standing 50 meters away from the base of the building, she measures the angle of elevation to the top of the building as 32. How tall is the building?</p>
                <h3>Solution:</h3>
                <ol>
                    <li>This forms a right triangle with:
                        <ul>
                            <li>The adjacent side (ground distance) = 50 meters</li>
                            <li>The opposite side (building height) = unknown</li>
                            <li>The angle of elevation = 32</li>
                        </ul>
                    </li>
                    <li>We can use the tangent function: tan() = opposite / adjacent</li>
                    <li>tan(32) = height / 50</li>
                    <li>height = 50 * tan(32)</li>
                    <li>height  31.1 meters</li>
                </ol>
                <p>Use the slider below to adjust the angle of elevation and see how it affects the calculated height of the building.</p>
            `,sliders:[{id:"angle",label:"Angle of Elevation (degrees)",min:0,max:89,step:1,defaultValue:32,explanation:"Adjust the angle of elevation to see how it affects the calculated height of the building."}],visualizations:[{type:"canvas",setup:x=>{const s=document.createElement("canvas"),n=s.getContext("2d");return{canvas:s,ctx:n}},update:x=>{const{canvas:s,ctx:n,angle:f=32}=x;if(n&&s){const d=s.parentElement;d&&(s.width=d.clientWidth,s.height=d.clientHeight);const h=s.width,u=s.height;n.clearRect(0,0,h,u),n.strokeStyle="#00ffff",n.fillStyle="#00ffff",n.lineWidth=2,n.font=`${Math.max(12,u/30)}px Arial`;const r=h*.6*Math.tan(f*Math.PI/180),p=Math.min(1,u/(r+50));R(n,0,u-20,h,u-20),R(n,h-50,u-20,h-50,u-20-r*p),R(n,50,u-50,h-50,u-20-r*p),n.beginPath(),n.arc(50,u-50,40,-Math.PI/2,-f*Math.PI/180-Math.PI/2,!0),n.stroke(),g(n,`${f}`,100,u-60,Math.max(12,u/30)),g(n,"50 m",h/2,u-10,Math.max(12,u/30)),g(n,`${r.toFixed(1)} m`,h-40,u-20-r*p/2,Math.max(12,u/30)),g(n,`Calculated Height: ${r.toFixed(1)} m`,50,50,Math.max(16,u/20))}}}]},{id:"8.2",title:"Navigation and Surveying",content:`
                <h2>Practical Applications in GPS and Mapping</h2>
                <p>Trigonometry plays a crucial role in navigation and surveying, from traditional methods to modern GPS technology. These applications rely on principles of triangulation and distance calculation using trigonometric functions.</p>
                <h3>Key Applications:</h3>
                <ul>
                    <li><strong>GPS (Global Positioning System):</strong> Uses trilateration, a process similar to triangulation, to determine position based on distances from satellites.</li>
                    <li><strong>Cartography:</strong> Map-making relies on trigonometry to accurately represent curved surfaces on flat maps.</li>
                    <li><strong>Land Surveying:</strong> Surveyors use trigonometry to measure property boundaries and determine land areas.</li>
                    <li><strong>Marine Navigation:</strong> Sailors use trigonometry to calculate distances and bearings between points.</li>
                </ul>
                <h3>Example: Triangulation in GPS</h3>
                <p>GPS receivers use signals from multiple satellites to determine position. The basic principle involves:</p>
                <ol>
                    <li>Receiving signals from at least four satellites</li>
                    <li>Calculating the distance to each satellite based on the time the signal took to arrive</li>
                    <li>Using these distances to determine the receiver's position through trilateration</li>
                </ol>
                <p>The visualization below demonstrates a simplified 2D version of GPS triangulation. Adjust the sliders to see how changing your distance from two "satellites" affects your position.</p>
            `,sliders:[{id:"distanceA",label:"Distance from Satellite A (km)",min:10,max:200,step:1,defaultValue:100,explanation:"Adjust the distance from Satellite A"},{id:"distanceB",label:"Distance from Satellite B (km)",min:10,max:200,step:1,defaultValue:150,explanation:"Adjust the distance from Satellite B"}],visualizations:[{type:"canvas",setup:x=>{const s=document.createElement("canvas"),n=s.getContext("2d");return{canvas:s,ctx:n}},update:x=>{const{canvas:s,ctx:n,distanceA:f=100,distanceB:d=150}=x;if(n&&s){const h=s.parentElement;h&&(s.width=h.clientWidth,s.height=h.clientHeight);const u=s.width,c=s.height;n.clearRect(0,0,u,c),n.strokeStyle="#00ffff",n.fillStyle="#00ffff",n.lineWidth=2,n.font=`${Math.max(12,c/30)}px Arial`;const r=Math.min(u,c)/400;le(n,u*.25,c*.5,5),g(n,"Satellite A",u*.25-30,c*.5-20,Math.max(12,c/30)),le(n,u*.75,c*.5,5),g(n,"Satellite B",u*.75-30,c*.5-20,Math.max(12,c/30)),he(n,u*.25,c*.5,f*r),he(n,u*.75,c*.5,d*r);const p=u*.5,F=(p*p+f*f-d*d)/(2*p),b=Math.sqrt(f*f-F*F);le(n,u*.25+F*r,c*.5+b*r,5),le(n,u*.25+F*r,c*.5-b*r,5),g(n,`${f} km`,u*.25,c*.5+f*r+20,Math.max(12,c/30)),g(n,`${d} km`,u*.75,c*.5+d*r+20,Math.max(12,c/30)),g(n,"Possible positions:",20,30,Math.max(16,c/20)),g(n,`(${(F*r).toFixed(1)}, ${(b*r).toFixed(1)})`,20,60,Math.max(14,c/25)),g(n,`(${(F*r).toFixed(1)}, ${(-b*r).toFixed(1)})`,20,90,Math.max(14,c/25))}}}]},{id:"8.3",title:"Circular Motion",content:`
                <h2>Describing Rotational Movement with Trigonometric Functions</h2>
                <p>Circular motion is a fundamental concept in physics, and trigonometric functions are essential for describing this type of movement mathematically. This application of trigonometry is crucial in fields such as engineering, astronomy, and physics.</p>
                <h3>Key Concepts:</h3>
                <ul>
                    <li><strong>Angular Velocity ():</strong> The rate of change of angular position with respect to time.</li>
                    <li><strong>Period (T):</strong> The time taken for one complete revolution.</li>
                    <li><strong>Frequency (f):</strong> The number of revolutions per unit time (f = 1/T).</li>
                    <li><strong>Sine and Cosine Functions:</strong> Used to describe the position of an object in circular motion.</li>
                </ul>
                <h3>Mathematical Description:</h3>
                <p>For an object moving in a circle with radius r and angular velocity :</p>
                <ul>
                    <li>x-position: x = r * cos(t)</li>
                    <li>y-position: y = r * sin(t)</li>
                    <li>Where t is time and  = 2/T = 2f</li>
                </ul>
                <h3>Applications:</h3>
                <ul>
                    <li>Planetary motion</li>
                    <li>Gears and rotary engines</li>
                    <li>AC electrical circuits</li>
                    <li>Sound and light waves</li>
                </ul>
                <p>Use the slider below to see how an object moves in circular motion and how its position is described using sine and cosine functions.</p>
            `,sliders:[{id:"time",label:"Time (seconds)",min:0,max:10,step:.1,defaultValue:0,explanation:"Adjust the time to see the object's position in circular motion"}],visualizations:[{type:"canvas",setup:x=>{const s=document.createElement("canvas"),n=s.getContext("2d");return{canvas:s,ctx:n}},update:x=>{const{canvas:s,ctx:n,time:f=0}=x;if(n&&s){const d=s.parentElement;d&&(s.width=d.clientWidth,s.height=d.clientHeight);const h=s.width,u=s.height;n.clearRect(0,0,h,u),n.strokeStyle="#00ffff",n.fillStyle="#00ffff",n.lineWidth=2,n.font=`${Math.max(12,u/30)}px Arial`;const c=h*.3,r=u*.5,p=Math.min(h,u)*.2,F=2*Math.PI/5,b=F*f,A=c+p*Math.cos(b),_=r-p*Math.sin(b);he(n,c,r,p),le(n,A,_,5),R(n,c,r,A,_),g(n,`(${(A-c).toFixed(1)}, ${(r-_).toFixed(1)})`,A+10,_-10,Math.max(12,u/30));const T=h*.6,C=u*.4,j=h*.35,O=u*.8;n.beginPath();for(let K=0;K<=10;K+=.1){const W=j+K/10*T,G=O-Math.sin(F*K)*C/2;K===0?n.moveTo(W,G):n.lineTo(W,G)}n.stroke();const k=j+f/10*T,ee=O-Math.sin(b)*C/2;le(n,k,ee,5),g(n,"Circular Motion",c-50,r-p-20,Math.max(14,u/25)),g(n,"Sine Wave",j,O-C/2-20,Math.max(14,u/25)),g(n,`Time: ${f.toFixed(1)} s`,20,30,Math.max(16,u/20))}}}]},{id:"8.4",title:"Simple Harmonic Motion",content:`
                <h2>Modeling Oscillations Using Sine and Cosine</h2>
                <p>Simple Harmonic Motion (SHM) is a type of periodic motion where the restoring force is directly proportional to the displacement from the equilibrium position. This concept is fundamental in physics and engineering, and it's described mathematically using trigonometric functions.</p>
                <h3>Key Concepts:</h3>
                <ul>
                    <li><strong>Amplitude (A):</strong> The maximum displacement from the equilibrium position.</li>
                    <li><strong>Angular Frequency ():</strong> Related to the frequency f by  = 2f.</li>
                    <li><strong>Phase ():</strong> Determines the starting point of the oscillation.</li>
                </ul>
                <h3>Mathematical Description:</h3>
                <p>The displacement x of an object in SHM is given by:</p>
                <p>x(t) = A * cos(t + )</p>
                <p>where t is time.</p>
                <h3>Applications:</h3>
                <ul>
                    <li>Pendulums</li>
                    <li>Mass-spring systems</li>
                    <li>Sound waves</li>
                    <li>AC electrical circuits</li>
                    <li>Molecular vibrations</li>
                </ul>
                <p>Use the sliders below to adjust the parameters of simple harmonic motion and observe how they affect the oscillation.</p>
            `,sliders:[{id:"amplitude",label:"Amplitude",min:10,max:100,step:5,defaultValue:50,explanation:"Adjust the amplitude of the oscillation"},{id:"frequency",label:"Frequency (Hz)",min:.1,max:2,step:.1,defaultValue:.5,explanation:"Adjust the frequency of the oscillation"},{id:"phase",label:"Phase (degrees)",min:0,max:360,step:15,defaultValue:0,explanation:"Adjust the phase of the oscillation"}],visualizations:[{type:"canvas",setup:x=>{const s=document.createElement("canvas"),n=s.getContext("2d");return{canvas:s,ctx:n}},update:x=>{const{canvas:s,ctx:n,amplitude:f=50,frequency:d=.5,phase:h=0}=x;if(n&&s){const u=s.parentElement;u&&(s.width=u.clientWidth,s.height=u.clientHeight);const c=s.width,r=s.height;n.clearRect(0,0,c,r),n.strokeStyle="#00ffff",n.fillStyle="#00ffff",n.lineWidth=2,n.font=`${Math.max(12,r/30)}px Arial`;const p=r/2,F=c/10,b=r/(4*f),A=2*Math.PI*d,_=h*Math.PI/180;R(n,0,p,c,p),R(n,50,0,50,r),n.beginPath();for(let T=0;T<=c;T++){const C=T/F,j=p-f*Math.cos(A*C+_)*b;T===0?n.moveTo(T,j):n.lineTo(T,j)}n.stroke(),n.setLineDash([5,5]),R(n,0,p-f*b,c,p-f*b),R(n,0,p+f*b,c,p+f*b),n.setLineDash([]),g(n,"Simple Harmonic Motion",60,30,Math.max(16,r/20)),g(n,`Amplitude: ${f}`,60,60,Math.max(14,r/25)),g(n,`Frequency: ${d} Hz`,60,90,Math.max(14,r/25)),g(n,`Phase: ${h}`,60,120,Math.max(14,r/25)),g(n,"Time (s)",c-70,p+30,Math.max(14,r/25)),g(n,"Displacement",60,20,Math.max(14,r/25));for(let T=0;T<=10;T+=2){const C=T*F;R(n,C,p-5,C,p+5),g(n,T.toString(),C-5,p+20,Math.max(12,r/30))}}}}]},{id:"8.6",title:"Trigonometry in Engineering",content:`
                <h2>Uses in Electrical Engineering and Signal Processing</h2>
                <p>Trigonometry plays a crucial role in various branches of engineering, particularly in electrical engineering and signal processing. Its applications range from analyzing electrical circuits to processing complex signals.</p>
                <h3>Key Applications:</h3>
                <ul>
                    <li><strong>AC Circuit Analysis:</strong> Sine and cosine functions are used to describe alternating current and voltage.</li>
                    <li><strong>Fourier Analysis:</strong> Complex signals are broken down into sums of sinusoidal components.</li>
                    <li><strong>Signal Processing:</strong> Trigonometric functions are used in filters, modulation, and demodulation.</li>
                    <li><strong>Control Systems:</strong> Used in describing and analyzing system responses.</li>
                    <li><strong>Antenna Design:</strong> Radiation patterns often involve trigonometric functions.</li>
                </ul>
                <h3>Example: Sine Wave in AC Circuits</h3>
                <p>In AC circuits, voltage and current are typically described by sine waves:</p>
                <p>V(t) = V<sub>max</sub> * sin(t + )</p>
                <p>Where:</p>
                <ul>
                    <li>V(t) is the voltage at time t</li>
                    <li>V<sub>max</sub> is the peak voltage</li>
                    <li> is the angular frequency (2f, where f is the frequency in Hz)</li>
                    <li> is the phase angle</li>
                </ul>
                <p>Use the sliders below to see how different parameters affect an AC voltage waveform.</p>
            `,sliders:[{id:"amplitude",label:"Amplitude (V)",min:1,max:10,step:.5,defaultValue:5,explanation:"Adjust the peak voltage of the AC waveform"},{id:"frequency",label:"Frequency (Hz)",min:1,max:10,step:.5,defaultValue:2,explanation:"Adjust the frequency of the AC waveform"},{id:"phase",label:"Phase (degrees)",min:0,max:360,step:15,defaultValue:0,explanation:"Adjust the phase angle of the AC waveform"}],visualizations:[{type:"canvas",setup:x=>{const s=document.createElement("canvas"),n=s.getContext("2d");return{canvas:s,ctx:n}},update:x=>{const{canvas:s,ctx:n,amplitude:f=5,frequency:d=2,phase:h=0}=x;if(n&&s){const u=s.parentElement;u&&(s.width=u.clientWidth,s.height=u.clientHeight);const c=s.width,r=s.height;n.clearRect(0,0,c,r),n.strokeStyle="#00ffff",n.fillStyle="#00ffff",n.lineWidth=2,n.font=`${Math.max(12,r/30)}px Arial`;const p=r/2,F=c/4,b=r/(4*f),A=2*Math.PI*d,_=h*Math.PI/180;R(n,0,p,c,p),R(n,50,0,50,r),n.beginPath();for(let T=0;T<=c;T++){const C=T/F,j=p-f*Math.sin(A*C+_)*b;T===0?n.moveTo(T,j):n.lineTo(T,j)}n.stroke(),n.setLineDash([5,5]),R(n,0,p-f*b,c,p-f*b),R(n,0,p+f*b,c,p+f*b),n.setLineDash([]),g(n,"AC Voltage Waveform",60,30,Math.max(16,r/20)),g(n,`Amplitude: ${f} V`,60,60,Math.max(14,r/25)),g(n,`Frequency: ${d} Hz`,60,90,Math.max(14,r/25)),g(n,`Phase: ${h}`,60,120,Math.max(14,r/25)),g(n,"Time",c-50,p+30,Math.max(14,r/25)),g(n,"Voltage",60,20,Math.max(14,r/25));for(let T=0;T<=4;T++){const C=T*F;R(n,C,p-5,C,p+5),g(n,`${T/d}s`,C-10,p+20,Math.max(12,r/30))}}}}]}]},M={id:9,title:"Polar Coordinates and Complex Numbers",introduction:`
        <p>Welcome to our lesson on Polar Coordinates and Complex Numbers! In this lesson, we'll explore an alternative way of describing points in a plane and see how it relates to complex numbers.</p>
        <p>Polar coordinates provide a natural way to describe many physical systems and phenomena, especially those involving circular or rotational motion. Understanding polar coordinates is also crucial for working with complex numbers in their trigonometric form.</p>
    `,prerequisites:[2,3,5,8],sublessons:[{id:"9.1",title:"Introduction to Polar Coordinates",content:`
                <h2>Understanding r and </h2>
                <p>Polar coordinates describe a point in a plane using two numbers:</p>
                <ul>
                    <li><strong>r:</strong> The radial coordinate, which is the distance from the origin to the point.</li>
                    <li><strong> (theta):</strong> The angular coordinate, which is the angle from the positive x-axis to the line from the origin to the point.</li>
                </ul>
                <h3>Key Concepts:</h3>
                <ul>
                    <li>The origin in polar coordinates is called the pole.</li>
                    <li>The ray from which  is measured is called the polar axis.</li>
                    <li>r is always non-negative, while  can be positive or negative.</li>
                    <li> is typically measured in radians, but degrees can also be used.</li>
                </ul>
                <h3>Conversion between Polar and Cartesian Coordinates:</h3>
                <p>To convert from polar (r, ) to Cartesian (x, y):</p>
                <ul>
                    <li>x = r * cos()</li>
                    <li>y = r * sin()</li>
                </ul>
                <p>To convert from Cartesian (x, y) to polar (r, ):</p>
                <ul>
                    <li>r = (x + y)</li>
                    <li> = atan2(y, x)</li>
                </ul>
                <p>Use the sliders below to see how changing r and  affects the position of a point in polar coordinates.</p>
            `,sliders:[{id:"r",label:"r (radius)",min:0,max:5,step:.1,defaultValue:3,explanation:"Adjust the radial coordinate"},{id:"theta",label:" (angle in degrees)",min:0,max:360,step:1,defaultValue:45,explanation:"Adjust the angular coordinate"}],visualizations:[{type:"canvas",setup:x=>{const s=document.createElement("canvas"),n=s.getContext("2d");return{canvas:s,ctx:n}},update:x=>{const{canvas:s,ctx:n,r:f=3,theta:d=45}=x;if(n&&s){const h=s.parentElement;h&&(s.width=h.clientWidth,s.height=h.clientHeight);const u=s.width,c=s.height;n.clearRect(0,0,u,c),n.strokeStyle="#00ffff",n.fillStyle="#00ffff",n.lineWidth=2,n.font=`${Math.max(12,c/30)}px Arial`;const r=u/2,p=c/2,F=Math.min(u,c)/12;R(n,0,p,u,p),R(n,r,0,r,c);for(let T=1;T<=5;T++)he(n,r,p,T*F),g(n,T.toString(),r+T*F,p+20,Math.max(12,c/30));for(let T=0;T<360;T+=30){const C=T*Math.PI/180;R(n,r,p,r+Math.cos(C)*5*F,p-Math.sin(C)*5*F),g(n,T.toString()+"",r+Math.cos(C)*5.2*F,p-Math.sin(C)*5.2*F,Math.max(12,c/30))}const b=d*Math.PI/180,A=r+f*F*Math.cos(b),_=p-f*F*Math.sin(b);le(n,A,_,5),n.setLineDash([5,5]),R(n,r,p,A,_),n.setLineDash([]),n.beginPath(),n.arc(r,p,30,0,-b,!0),n.stroke(),g(n,`r = ${f}`,A+10,_-10,Math.max(14,c/25)),g(n,` = ${d}`,r+40,p-10,Math.max(14,c/25)),g(n,`(${(A-r).toFixed(2)}, ${(p-_).toFixed(2)})`,10,30,Math.max(14,c/25))}}}]},{id:"9.2",title:"Plotting Points in Polar Form",content:`
                <h2>Techniques for Graphing in Polar Coordinates</h2>
                <p>Plotting points in polar coordinates requires a different approach compared to Cartesian coordinates. Here are some key techniques:</p>
                <ol>
                    <li><strong>Use a polar grid:</strong> This consists of concentric circles for r values and radial lines for  values.</li>
                    <li><strong>Start at the pole:</strong> This is equivalent to the origin (0,0) in Cartesian coordinates.</li>
                    <li><strong>Measure the radial distance:</strong> Move outward from the pole by the distance r.</li>
                    <li><strong>Rotate to the angle:</strong> From the positive x-axis, rotate by  (counterclockwise for positive , clockwise for negative ).</li>
                    <li><strong>Plot the point:</strong> Mark the point where the r distance intersects with the  angle.</li>
                </ol>
                <h3>Special Cases:</h3>
                <ul>
                    <li>When r = 0, the point is always at the pole, regardless of .</li>
                    <li>Points with the same r but  differing by multiples of 2 are identical.</li>
                    <li>Negative r values can be interpreted by adding  to  and using |r|.</li>
                </ul>
                <p>Use the interactive polar graph below to plot multiple points and see how they appear in polar coordinates.</p>
            `,sliders:[{id:"r",label:"r (radius)",min:0,max:5,step:.1,defaultValue:3,explanation:"Set the radial coordinate for the new point"},{id:"theta",label:" (angle in degrees)",min:0,max:360,step:1,defaultValue:45,explanation:"Set the angular coordinate for the new point"}],visualizations:[{type:"canvas",setup:x=>{const s=document.createElement("canvas"),n=s.getContext("2d");return{canvas:s,ctx:n,points:[]}},update:x=>{const{canvas:s,ctx:n,r:f=3,theta:d=45,points:h=[]}=x;if(n&&s){const u=s.parentElement;u&&(s.width=u.clientWidth,s.height=u.clientHeight);const c=s.width,r=s.height;n.clearRect(0,0,c,r),n.strokeStyle="#00ffff",n.fillStyle="#00ffff",n.lineWidth=2,n.font=`${Math.max(12,r/30)}px Arial`;const p=c/2,F=r/2,b=Math.min(c,r)/12;for(let C=1;C<=5;C++)he(n,p,F,C*b),g(n,C.toString(),p+C*b,F+20,Math.max(12,r/30));for(let C=0;C<360;C+=30){const j=C*Math.PI/180;R(n,p,F,p+Math.cos(j)*5*b,F-Math.sin(j)*5*b),g(n,C.toString()+"",p+Math.cos(j)*5.2*b,F-Math.sin(j)*5.2*b,Math.max(12,r/30))}h.forEach((C,j)=>{const O=p+C.r*b*Math.cos(C.theta*Math.PI/180),k=F-C.r*b*Math.sin(C.theta*Math.PI/180);n.fillStyle=`hsl(${j*137.5%360}, 100%, 50%)`,le(n,O,k,5),g(n,`(${C.r}, ${C.theta})`,O+10,k-10,Math.max(12,r/30))});const A=d*Math.PI/180,_=p+f*b*Math.cos(A),T=F-f*b*Math.sin(A);n.fillStyle="#00ffff",le(n,_,T,5),g(n,`(${f}, ${d})`,_+10,T-10,Math.max(12,r/30)),g(n,"Click to add point. Right-click to clear.",10,r-20,Math.max(12,r/30))}}}]},{id:"9.3",title:"Converting Between Rectangular and Polar Forms",content:`
                <h2>Formulas and Methods for Conversion</h2>
                <p>Converting between rectangular (Cartesian) and polar coordinates is a fundamental skill when working with these coordinate systems. Here are the formulas and methods for conversion:</p>
                <h3>Rectangular to Polar Conversion:</h3>
                <p>Given (x, y) in rectangular coordinates:</p>
                <ul>
                    <li>r = (x + y)</li>
                    <li> = atan2(y, x)</li>
                </ul>
                <p>Note: atan2(y, x) is a function that returns the angle in the correct quadrant, unlike the regular arctangent function.</p>
                <h3>Polar to Rectangular Conversion:</h3>
                <p>Given (r, ) in polar coordinates:</p>
                <ul>
                    <li>x = r * cos()</li>
                    <li>y = r * sin()</li>
                </ul>
                <h3>Important Considerations:</h3>
                <ul>
                    <li>When converting to polar form, r is always non-negative.</li>
                    <li>The angle  in polar form is not unique; adding any multiple of 2 gives an equivalent angle.</li>
                    <li>When x = y = 0, the polar angle  is undefined.</li>
                </ul>
                <p>Use the interactive tool below to practice converting between rectangular and polar coordinates.</p>
            `,sliders:[{id:"x",label:"x",min:-5,max:5,step:.1,defaultValue:3,explanation:"Set the x-coordinate"},{id:"y",label:"y",min:-5,max:5,step:.1,defaultValue:4,explanation:"Set the y-coordinate"}],visualizations:[{type:"canvas",setup:x=>{const s=document.createElement("canvas"),n=s.getContext("2d");return{canvas:s,ctx:n}},update:x=>{const{canvas:s,ctx:n,x:f=3,y:d=4}=x;if(n&&s){const h=s.parentElement;h&&(s.width=h.clientWidth,s.height=h.clientHeight);const u=s.width,c=s.height;n.clearRect(0,0,u,c),n.strokeStyle="#00ffff",n.fillStyle="#00ffff",n.lineWidth=2,n.font=`${Math.max(12,c/30)}px Arial`;const r=u/2,p=c/2,F=Math.min(u,c)/12;R(n,0,p,u,p),R(n,r,0,r,c),n.strokeStyle="rgba(0, 255, 255, 0.2)";for(let C=-5;C<=5;C++)R(n,r+C*F,0,r+C*F,c),R(n,0,p+C*F,u,p+C*F);n.strokeStyle="#00ffff";const b=Math.sqrt(f*f+d*d),A=Math.atan2(d,f)*180/Math.PI,_=r+f*F,T=p-d*F;le(n,_,T,5),n.setLineDash([5,5]),R(n,r,p,_,T),n.setLineDash([]),n.beginPath(),n.arc(r,p,30,0,-Math.atan2(d,f),!0),n.stroke(),g(n,`Rectangular: (${f.toFixed(2)}, ${d.toFixed(2)})`,10,30,Math.max(14,c/25)),g(n,`Polar: (${b.toFixed(2)}, ${A.toFixed(2)})`,10,60,Math.max(14,c/25)),g(n,`r = ${b.toFixed(2)}`,_+10,T-10,Math.max(14,c/25)),g(n,` = ${A.toFixed(2)}`,r+40,p-10,Math.max(14,c/25))}}}]},{id:"9.4",title:"Graphs of Polar Equations",content:`
                <h2>Plotting Common Polar Curves</h2>
                <p>Polar equations can produce a variety of interesting and beautiful curves. Some of the most common types include rose curves and limaons.</p>
                <h3>Rose Curves</h3>
                <p>Rose curves are described by the equation r = a * cos(n) or r = a * sin(n), where:</p>
                <ul>
                    <li>a determines the size of the curve</li>
                    <li>n determines the number of petals</li>
                    <li>If n is odd, the curve has n petals</li>
                    <li>If n is even, the curve has 2n petals</li>
                </ul>
                <h3>Limaons</h3>
                <p>Limaons are described by the equation r = a + b * cos() or r = a + b * sin(), where:</p>
                <ul>
                    <li>a and b determine the shape and size of the curve</li>
                    <li>If a > b > 0, the curve is a convex limaon</li>
                    <li>If b > a > 0, the curve is a looped limaon</li>
                    <li>If a = b, the curve is a cardioid</li>
                </ul>
                <p>Use the controls below to explore different polar curves and see how changing parameters affects their shape.</p>
            `,sliders:[{id:"curveType",label:"Curve Type",min:0,max:1,step:1,defaultValue:0,explanation:"Switch between Rose Curve (0) and Limaon (1)"},{id:"a",label:"a",min:0,max:5,step:.1,defaultValue:2,explanation:"Adjust the 'a' parameter of the equation"},{id:"b",label:"b or n",min:0,max:5,step:.1,defaultValue:1,explanation:"Adjust the 'b' parameter for Limaon or 'n' for Rose Curve"}],visualizations:[{type:"canvas",setup:x=>{const s=document.createElement("canvas"),n=s.getContext("2d");return{canvas:s,ctx:n}},update:x=>{const{canvas:s,ctx:n,curveType:f=0,a:d=2,b:h=1}=x;if(n&&s){const u=s.parentElement;u&&(s.width=u.clientWidth,s.height=u.clientHeight);const c=s.width,r=s.height;n.clearRect(0,0,c,r),n.strokeStyle="#00ffff",n.fillStyle="#00ffff",n.lineWidth=2,n.font=`${Math.max(12,r/30)}px Arial`;const p=c/2,F=r/2,b=Math.min(c,r)/10;for(let T=1;T<=5;T++)he(n,p,F,T*b);for(let T=0;T<360;T+=30){const C=T*Math.PI/180;R(n,p,F,p+Math.cos(C)*5*b,F-Math.sin(C)*5*b)}n.beginPath();for(let T=0;T<=2*Math.PI;T+=.01){let C;f===0?C=d*Math.cos(h*T):C=d+h*Math.cos(T);const j=p+C*Math.cos(T)*b,O=F-C*Math.sin(T)*b;T===0?n.moveTo(j,O):n.lineTo(j,O)}n.stroke();const A=f===0?"Rose Curve":"Limaon",_=f===0?`r = ${d.toFixed(1)} * cos(${h.toFixed(1)})`:`r = ${d.toFixed(1)} + ${h.toFixed(1)} * cos()`;g(n,A,10,30,Math.max(16,r/20)),g(n,_,10,60,Math.max(14,r/25))}}}]},{id:"9.5",title:"Complex Numbers in Trigonometric Form",content:`
                <h2>Expressing Complex Numbers Using r(cos  + i sin )</h2>
                <p>Complex numbers can be represented in trigonometric (or polar) form, which is especially useful for multiplication, division, and exponentiation of complex numbers.</p>
                <h3>Key Concepts:</h3>
                <ul>
                    <li>A complex number z = x + yi can be written as z = r(cos  + i sin )</li>
                    <li>r is the modulus (absolute value) of z: r = (x + y)</li>
                    <li> is the argument of z:  = atan2(y, x)</li>
                    <li>This form is also known as Euler's formula when written as z = r * e^(i)</li>
                </ul>
                <h3>Conversions:</h3>
                <p>From rectangular to trigonometric form:</p>
                <ul>
                    <li>r = (x + y)</li>
                    <li> = atan2(y, x)</li>
                </ul>
                <p>From trigonometric to rectangular form:</p>
                <ul>
                    <li>x = r * cos()</li>
                    <li>y = r * sin()</li>
                </ul>
                <p>Use the sliders below to see how complex numbers are represented in both rectangular and trigonometric forms.</p>
            `,sliders:[{id:"x",label:"Real Part (x)",min:-5,max:5,step:.1,defaultValue:3,explanation:"Adjust the real part of the complex number"},{id:"y",label:"Imaginary Part (y)",min:-5,max:5,step:.1,defaultValue:4,explanation:"Adjust the imaginary part of the complex number"}],visualizations:[{type:"canvas",setup:x=>{const s=document.createElement("canvas"),n=s.getContext("2d");return{canvas:s,ctx:n}},update:x=>{const{canvas:s,ctx:n,x:f=3,y:d=4}=x;if(n&&s){const h=s.parentElement;h&&(s.width=h.clientWidth,s.height=h.clientHeight);const u=s.width,c=s.height;n.clearRect(0,0,u,c),n.strokeStyle="#00ffff",n.fillStyle="#00ffff",n.lineWidth=2,n.font=`${Math.max(12,c/30)}px Arial`;const r=u/2,p=c/2,F=Math.min(u,c)/12;R(n,0,p,u,p),R(n,r,0,r,c),g(n,"Re",u-20,p+20,Math.max(12,c/30)),g(n,"Im",r-20,20,Math.max(12,c/30));const b=r+f*F,A=p-d*F;le(n,b,A,5),n.setLineDash([5,5]),R(n,r,p,b,A),R(n,b,p,b,A),R(n,r,A,b,A),n.setLineDash([]);const _=Math.sqrt(f*f+d*d),T=Math.atan2(d,f);n.beginPath(),n.arc(r,p,30,0,-T,!0),n.stroke(),g(n,`z = ${f.toFixed(2)} + ${d.toFixed(2)}i`,10,30,Math.max(14,c/25)),g(n,`r = ${_.toFixed(2)}`,10,60,Math.max(14,c/25)),g(n,` = ${(T*180/Math.PI).toFixed(2)}`,10,90,Math.max(14,c/25)),g(n,`z = ${_.toFixed(2)}(cos(${(T*180/Math.PI).toFixed(2)}) + i sin(${(T*180/Math.PI).toFixed(2)}))`,10,120,Math.max(14,c/25))}}}]},{id:"9.6",title:"De Moivre's Theorem and Applications",content:`
                <h2>Using De Moivre's Theorem for Powers and Roots</h2>
                <p>De Moivre's Theorem is a powerful tool in complex number theory, particularly useful for calculating powers and roots of complex numbers in polar form.</p>
                <h3>De Moivre's Theorem:</h3>
                <p>For any real number x and integer n:</p>
                <p style="text-align: center;">[cos(x) + i sin(x)]<sup>n</sup> = cos(nx) + i sin(nx)</p>
                <h3>Applications:</h3>
                <ol>
                    <li><strong>Powers of Complex Numbers:</strong>
                        <ul>
                            <li>If z = r(cos  + i sin ), then z<sup>n</sup> = r<sup>n</sup>(cos(n) + i sin(n))</li>
                            <li>This simplifies the process of raising complex numbers to powers</li>
                        </ul>
                    </li>
                    <li><strong>Roots of Complex Numbers:</strong>
                        <ul>
                            <li>The nth roots of z = r(cos  + i sin ) are given by:</li>
                            <li>z<sub>k</sub> = r<sup>1/n</sup>(cos(( + 2k)/n) + i sin(( + 2k)/n))</li>
                            <li>Where k = 0, 1, 2, ..., n-1</li>
                        </ul>
                    </li>
                </ol>
                <h3>Key Points:</h3>
                <ul>
                    <li>The theorem simplifies multiplication and division of complex numbers to addition and subtraction of angles</li>
                    <li>It's particularly useful in fields like electrical engineering and signal processing</li>
                    <li>The theorem extends to fractional and negative powers as well</li>
                </ul>
                <p>Use the interactive visualization below to explore powers and roots of complex numbers using De Moivre's Theorem.</p>
            `,sliders:[{id:"r",label:"Magnitude (r)",min:.1,max:2,step:.1,defaultValue:1,explanation:"Adjust the magnitude of the complex number"},{id:"theta",label:"Angle  (degrees)",min:0,max:360,step:1,defaultValue:45,explanation:"Adjust the angle of the complex number"},{id:"n",label:"Power/Root (n)",min:-5,max:5,step:1,defaultValue:2,explanation:"Adjust n for z^n (positive) or nth root (negative)"}],visualizations:[{type:"canvas",setup:x=>{const s=document.createElement("canvas"),n=s.getContext("2d");return{canvas:s,ctx:n}},update:x=>{const{canvas:s,ctx:n,r:f=1,theta:d=45,n:h=2}=x;if(n&&s){const u=s.parentElement;u&&(s.width=u.clientWidth,s.height=u.clientHeight);const c=s.width,r=s.height;n.clearRect(0,0,c,r),n.strokeStyle="#00ffff",n.fillStyle="#00ffff",n.lineWidth=2,n.font=`${Math.max(12,r/30)}px Arial`;const p=c/2,F=r/2,b=Math.min(c,r)/6;R(n,0,F,c,F),R(n,p,0,p,r),he(n,p,F,b);const A=d*Math.PI/180,_=f*Math.cos(A),T=f*Math.sin(A);le(n,p+_*b,F-T*b,5),n.strokeStyle="rgba(0, 255, 255, 0.5)",R(n,p,F,p+_*b,F-T*b),n.strokeStyle="#00ffff";let C=[];if(h>0){const j=Math.pow(f,h),O=h*A,k=j*Math.cos(O),ee=j*Math.sin(O);C.push({x:k,y:ee})}else if(h<0){const j=-h;for(let O=0;O<j;O++){const k=Math.pow(f,1/j),ee=(A+2*Math.PI*O)/j,K=k*Math.cos(ee),W=k*Math.sin(ee);C.push({x:K,y:W})}}C.forEach((j,O)=>{n.fillStyle=`hsl(${O*137.5%360}, 100%, 50%)`,le(n,p+j.x*b,F-j.y*b,5),R(n,p,F,p+j.x*b,F-j.y*b)}),n.fillStyle="#00ffff",g(n,`z = ${f.toFixed(2)}(cos(${d.toFixed(2)}) + i sin(${d.toFixed(2)}))`,10,30,Math.max(14,r/25)),h>0?g(n,`z^${h} = ${Math.pow(f,h).toFixed(2)}(cos(${(h*d).toFixed(2)}) + i sin(${(h*d).toFixed(2)}))`,10,60,Math.max(14,r/25)):h<0&&(g(n,`${-h}th roots of z:`,10,60,Math.max(14,r/25)),C.forEach((j,O)=>{const k=Math.sqrt(j.x*j.x+j.y*j.y),ee=Math.atan2(j.y,j.x)*180/Math.PI;g(n,`Root ${O+1}: ${k.toFixed(2)}(cos(${ee.toFixed(2)}) + i sin(${ee.toFixed(2)}))`,10,90+30*O,Math.max(14,r/25))}))}}}]}]},S={id:10,title:"3D Trigonometry and Vectors",introduction:`
        <p>Welcome to our lesson on 3D Trigonometry and Vectors! In this lesson, we'll extend our understanding of trigonometry and vector concepts from 2D to 3D space.</p>
        <p>3D trigonometry and vectors are crucial in various fields, including computer graphics, robotics, physics, and engineering. Understanding these concepts allows us to describe and analyze complex three-dimensional systems and movements.</p>
    `,prerequisites:[1,2,3,5,9],sublessons:[{id:"10.1",title:"3D Coordinate Systems",content:`
                <h2>Extending 2D Concepts to 3D Space</h2>
                <p>The 3D coordinate system, also known as the Cartesian coordinate system, extends the familiar 2D xy-plane by adding a third axis, the z-axis, perpendicular to both x and y axes.</p>
                <h3>Key Concepts:</h3>
                <ul>
                    <li><strong>Origin:</strong> The point where all three axes intersect, denoted as (0, 0, 0).</li>
                    <li><strong>Axes:</strong> Three perpendicular lines intersecting at the origin:
                        <ul>
                            <li>x-axis: horizontal (left-right)</li>
                            <li>y-axis: vertical (up-down)</li>
                            <li>z-axis: depth (forward-backward)</li>
                        </ul>
                    </li>
                    <li><strong>Coordinates:</strong> Any point in 3D space is described by three numbers (x, y, z).</li>
                    <li><strong>Right-hand Rule:</strong> A convention for orienting the axes. Point your right-hand thumb along the positive z-axis, your index finger along the positive x-axis, and your middle finger will point along the positive y-axis.</li>
                </ul>
                <h3>Planes in 3D Space:</h3>
                <ul>
                    <li><strong>xy-plane:</strong> z = 0</li>
                    <li><strong>yz-plane:</strong> x = 0</li>
                    <li><strong>xz-plane:</strong> y = 0</li>
                </ul>
                <p>Use the interactive visualization below to explore the 3D coordinate system. You can adjust the coordinates to see how points are positioned in 3D space.</p>
            `,sliders:[{id:"x",label:"x-coordinate",min:-5,max:5,step:.1,defaultValue:2,explanation:"Adjust the x-coordinate of the point"},{id:"y",label:"y-coordinate",min:-5,max:5,step:.1,defaultValue:3,explanation:"Adjust the y-coordinate of the point"},{id:"z",label:"z-coordinate",min:-5,max:5,step:.1,defaultValue:4,explanation:"Adjust the z-coordinate of the point"}],visualizations:[{type:"canvas",setup:x=>{const s=document.createElement("canvas"),n=s.getContext("2d");return{canvas:s,ctx:n}},update:x=>{const{canvas:s,ctx:n,x:f=2,y:d=3,z:h=4}=x;if(n&&s){const u=s.parentElement;u&&(s.width=u.clientWidth,s.height=u.clientHeight);const c=s.width,r=s.height;n.clearRect(0,0,c,r),n.strokeStyle="#00ffff",n.fillStyle="#00ffff",n.lineWidth=2,n.font=`${Math.max(12,r/30)}px Arial`;const p=c/2,F=r/2,b=Math.min(c,r)/12,A=Math.PI/6,_=(ee,K,W)=>({x:p+(ee-W)*Math.cos(A)*b,y:F+(ee+W)*Math.sin(A)*b-K*b}),T=_(0,0,0),C=_(6,0,0),j=_(0,6,0),O=_(0,0,6);R(n,T.x,T.y,C.x,C.y),R(n,T.x,T.y,j.x,j.y),R(n,T.x,T.y,O.x,O.y),g(n,"x",C.x+10,C.y,Math.max(12,r/30)),g(n,"y",j.x-20,j.y-10,Math.max(12,r/30)),g(n,"z",O.x-20,O.y,Math.max(12,r/30)),n.globalAlpha=.2,n.fillStyle="#FF0000",n.beginPath(),n.moveTo(...Object.values(_(0,0,0))),n.lineTo(...Object.values(_(0,6,0))),n.lineTo(...Object.values(_(0,6,6))),n.lineTo(...Object.values(_(0,0,6))),n.fill(),n.fillStyle="#00FF00",n.beginPath(),n.moveTo(...Object.values(_(0,0,0))),n.lineTo(...Object.values(_(6,0,0))),n.lineTo(...Object.values(_(6,0,6))),n.lineTo(...Object.values(_(0,0,6))),n.fill(),n.fillStyle="#0000FF",n.beginPath(),n.moveTo(...Object.values(_(0,0,0))),n.lineTo(...Object.values(_(6,0,0))),n.lineTo(...Object.values(_(6,6,0))),n.lineTo(...Object.values(_(0,6,0))),n.fill(),n.globalAlpha=1;const k=_(f,d,h);le(n,k.x,k.y,5),n.setLineDash([5,5]),R(n,k.x,k.y,...Object.values(_(f,d,0))),R(n,k.x,k.y,...Object.values(_(f,0,h))),R(n,k.x,k.y,...Object.values(_(0,d,h))),n.setLineDash([]),g(n,`(${f}, ${d}, ${h})`,k.x+10,k.y-10,Math.max(12,r/30)),g(n,`(${f}, ${d}, 0)`,...Object.values(_(f,d,0)),Math.max(12,r/30)),g(n,`(${f}, 0, ${h})`,...Object.values(_(f,0,h)),Math.max(12,r/30)),g(n,`(0, ${d}, ${h})`,...Object.values(_(0,d,h)),Math.max(12,r/30))}}}]},{id:"10.2",title:"Distance in 3D Space",content:`
                <h2>Calculating Distances Between Points in 3D</h2>
                <p>In 3D space, we can calculate the distance between two points using an extension of the Pythagorean theorem. This concept is fundamental in many applications, including computer graphics, robotics, and physics simulations.</p>
                <h3>Distance Formula in 3D:</h3>
                <p>Given two points P1(x, y, z) and P2(x, y, z), the distance d between them is:</p>
                <p style="text-align: center;">d = [(x - x) + (y - y) + (z - z)]</p>
                <h3>Key Concepts:</h3>
                <ul>
                    <li><strong>3D Pythagorean Theorem:</strong> The distance formula is a direct application of the Pythagorean theorem in three dimensions.</li>
                    <li><strong>Coordinate Differences:</strong> We calculate the differences in each coordinate (x, y, z) between the two points.</li>
                    <li><strong>Squared Differences:</strong> These differences are squared to ensure positive values and to apply the Pythagorean theorem.</li>
                    <li><strong>Square Root:</strong> Taking the square root of the sum gives us the actual distance.</li>
                </ul>
                <h3>Applications:</h3>
                <ul>
                    <li>Calculating distances between objects in 3D games or simulations</li>
                    <li>Determining the length of 3D vectors</li>
                    <li>Measuring distances in geographical information systems (GIS)</li>
                    <li>Computing trajectories in physics and engineering</li>
                </ul>
                <p>Use the interactive visualization below to explore distances between points in 3D space. You can adjust the coordinates of two points and see how the distance between them changes.</p>
            `,sliders:[{id:"x1",label:"x",min:-5,max:5,step:.1,defaultValue:1,explanation:"Adjust the x-coordinate of the first point"},{id:"y1",label:"y",min:-5,max:5,step:.1,defaultValue:2,explanation:"Adjust the y-coordinate of the first point"},{id:"z1",label:"z",min:-5,max:5,step:.1,defaultValue:3,explanation:"Adjust the z-coordinate of the first point"},{id:"x2",label:"x",min:-5,max:5,step:.1,defaultValue:-2,explanation:"Adjust the x-coordinate of the second point"},{id:"y2",label:"y",min:-5,max:5,step:.1,defaultValue:-1,explanation:"Adjust the y-coordinate of the second point"},{id:"z2",label:"z",min:-5,max:5,step:.1,defaultValue:1,explanation:"Adjust the z-coordinate of the second point"}],visualizations:[{type:"canvas",setup:x=>{const s=document.createElement("canvas"),n=s.getContext("2d");return{canvas:s,ctx:n}},update:x=>{const{canvas:s,ctx:n,x1:f=1,y1:d=2,z1:h=3,x2:u=-2,y2:c=-1,z2:r=1}=x;if(n&&s){const p=s.parentElement;p&&(s.width=p.clientWidth,s.height=p.clientHeight);const F=s.width,b=s.height;n.clearRect(0,0,F,b),n.strokeStyle="#00ffff",n.fillStyle="#00ffff",n.lineWidth=2,n.font=`${Math.max(12,b/30)}px Arial`;const A=F/2,_=b/2,T=Math.min(F,b)/12,C=Math.PI/6,j=(be,Te,Fe)=>({x:A+(be-Fe)*Math.cos(C)*T,y:_+(be+Fe)*Math.sin(C)*T-Te*T}),O=j(0,0,0),k=j(6,0,0),ee=j(0,6,0),K=j(0,0,6);R(n,O.x,O.y,k.x,k.y),R(n,O.x,O.y,ee.x,ee.y),R(n,O.x,O.y,K.x,K.y),g(n,"x",k.x+10,k.y,Math.max(12,b/30)),g(n,"y",ee.x-20,ee.y-10,Math.max(12,b/30)),g(n,"z",K.x-20,K.y,Math.max(12,b/30));const W=j(f,d,h),G=j(u,c,r);n.fillStyle="#FF0000",le(n,W.x,W.y,5),n.fillStyle="#00FF00",le(n,G.x,G.y,5),n.strokeStyle="#FFFF00",R(n,W.x,W.y,G.x,G.y),n.strokeStyle="#00ffff",g(n,`P1(${f}, ${d}, ${h})`,W.x+10,W.y-10,Math.max(12,b/30)),g(n,`P2(${u}, ${c}, ${r})`,G.x+10,G.y-10,Math.max(12,b/30));const me=Math.sqrt(Math.pow(u-f,2)+Math.pow(c-d,2)+Math.pow(r-h,2));g(n,`Distance: ${me.toFixed(2)}`,10,30,Math.max(16,b/20));const ve=Math.abs(u-f).toFixed(2),fe=Math.abs(c-d).toFixed(2),ue=Math.abs(r-h).toFixed(2);g(n,`d = (${ve} + ${fe} + ${ue})`,10,60,Math.max(14,b/25))}}}]},{id:"10.3",title:"Introduction to Vectors",content:`
                <h2>Vector Notation and Basic Operations</h2>
                <p>Vectors are mathematical objects that have both magnitude and direction. They are fundamental in physics, engineering, and computer graphics for representing quantities like velocity, force, and displacement.</p>
                <h3>Vector Notation:</h3>
                <ul>
                    <li><strong>Arrow Notation:</strong> Vectors are often represented by arrows, where the length of the arrow indicates magnitude and the direction of the arrow indicates... direction.</li>
                    <li><strong>Bold Letter Notation:</strong> In text, vectors are often written in bold, like <strong>v</strong>.</li>
                    <li><strong>Component Form:</strong> A 3D vector can be written as <strong>v</strong> = (x, y, z) or <strong>v</strong> = xi + yj + zk, where i, j, and k are unit vectors in the x, y, and z directions respectively.</li>
                </ul>
                <h3>Basic Vector Operations:</h3>
                <ol>
                    <li><strong>Vector Addition:</strong> Add corresponding components.
                        <br><strong>a</strong> + <strong>b</strong> = (a + b, a + b, a + b)</li>
                    <li><strong>Scalar Multiplication:</strong> Multiply each component by the scalar.
                        <br>k<strong>a</strong> = (ka, ka, ka)</li>
                    <li><strong>Magnitude:</strong> The length of the vector.
                        <br>|<strong>a</strong>| = (a + a + a)</li>
                    <li><strong>Direction:</strong> Often represented by angle with coordinate axes or as a unit vector (vector with magnitude 1).</li>
                </ol>
                <h3>Properties of Vector Operations:</h3>
                <ul>
                    <li>Commutative: <strong>a</strong> + <strong>b</strong> = <strong>b</strong> + <strong>a</strong></li>
                    <li>Associative: (<strong>a</strong> + <strong>b</strong>) + <strong>c</strong> = <strong>a</strong> + (<strong>b</strong> + <strong>c</strong>)</li>
                    <li>Distributive: k(<strong>a</strong> + <strong>b</strong>) = k<strong>a</strong> + k<strong>b</strong></li>
                </ul>
                <p>Use the interactive visualization below to explore vector addition and scalar multiplication in 3D space.</p>
            `,sliders:[{id:"x1",label:"Vector 1 x-component",min:-5,max:5,step:.1,defaultValue:2,explanation:"Adjust the x-component of the first vector"},{id:"y1",label:"Vector 1 y-component",min:-5,max:5,step:.1,defaultValue:3,explanation:"Adjust the y-component of the first vector"},{id:"z1",label:"Vector 1 z-component",min:-5,max:5,step:.1,defaultValue:1,explanation:"Adjust the z-component of the first vector"},{id:"x2",label:"Vector 2 x-component",min:-5,max:5,step:.1,defaultValue:-1,explanation:"Adjust the x-component of the second vector"},{id:"y2",label:"Vector 2 y-component",min:-5,max:5,step:.1,defaultValue:2,explanation:"Adjust the y-component of the second vector"},{id:"z2",label:"Vector 2 z-component",min:-5,max:5,step:.1,defaultValue:-2,explanation:"Adjust the z-component of the second vector"},{id:"scalar",label:"Scalar",min:-2,max:2,step:.1,defaultValue:1,explanation:"Adjust the scalar for multiplication"}],visualizations:[{type:"canvas",setup:x=>{const s=document.createElement("canvas"),n=s.getContext("2d");return{canvas:s,ctx:n}},update:x=>{const{canvas:s,ctx:n,x1:f=2,y1:d=3,z1:h=1,x2:u=-1,y2:c=2,z2:r=-2,scalar:p=1}=x;if(n&&s){const F=s.parentElement;F&&(s.width=F.clientWidth,s.height=F.clientHeight);const b=s.width,A=s.height;n.clearRect(0,0,b,A),n.strokeStyle="#00ffff",n.fillStyle="#00ffff",n.lineWidth=2,n.font=`${Math.max(12,A/30)}px Arial`;const _=b/2,T=A/2,C=Math.min(b,A)/15,j=Math.PI/6,O=(se,xe,w)=>({x:_+(se-w)*Math.cos(j)*C,y:T+(se+w)*Math.sin(j)*C-xe*C}),k=O(0,0,0),ee=O(6,0,0),K=O(0,6,0),W=O(0,0,6);R(n,k.x,k.y,ee.x,ee.y),R(n,k.x,k.y,K.x,K.y),R(n,k.x,k.y,W.x,W.y),g(n,"x",ee.x+10,ee.y,Math.max(12,A/30)),g(n,"y",K.x-20,K.y-10,Math.max(12,A/30)),g(n,"z",W.x-20,W.y,Math.max(12,A/30));const G=O(f,d,h),me=O(u,c,r);He(n,k.x,k.y,G.x,G.y,"#FF0000"),He(n,k.x,k.y,me.x,me.y,"#00FF00"),g(n,"v",G.x+10,G.y-10,Math.max(12,A/30)),g(n,"v",me.x+10,me.y-10,Math.max(12,A/30));const ve=f+u,fe=d+c,ue=h+r,be=O(ve,fe,ue);He(n,k.x,k.y,be.x,be.y,"#FFFF00"),g(n,"v + v",be.x+10,be.y-10,Math.max(12,A/30));const Te=f*p,Fe=d*p,Me=h*p,I=O(Te,Fe,Me);He(n,k.x,k.y,I.x,I.y,"#FF00FF"),g(n,`${p}v`,I.x+10,I.y-10,Math.max(12,A/30)),g(n,`v = (${f}, ${d}, ${h})`,10,30,Math.max(14,A/25)),g(n,`v = (${u}, ${c}, ${r})`,10,60,Math.max(14,A/25)),g(n,`v + v = (${ve}, ${fe}, ${ue})`,10,90,Math.max(14,A/25)),g(n,`${p}v = (${Te}, ${Fe}, ${Me})`,10,120,Math.max(14,A/25));const U=Math.sqrt(f*f+d*d+h*h),B=Math.sqrt(u*u+c*c+r*r),X=Math.sqrt(ve*ve+fe*fe+ue*ue);g(n,`|v| = ${U.toFixed(2)}`,10,A-90,Math.max(14,A/25)),g(n,`|v| = ${B.toFixed(2)}`,10,A-60,Math.max(14,A/25)),g(n,`|v + v| = ${X.toFixed(2)}`,10,A-30,Math.max(14,A/25))}}}]},{id:"10.4",title:"Dot Product and Vector Projections",content:`
                <h2>Understanding and Calculating Dot Products</h2>
                <p>The dot product is a fundamental operation in vector algebra that results in a scalar value. It has numerous applications in physics and engineering, including work calculations and vector projections.</p>
                <h3>Dot Product Definition:</h3>
                <p>For two vectors <strong>a</strong> = (a, a, a) and <strong>b</strong> = (b, b, b), the dot product is defined as:</p>
                <p style="text-align: center;"><strong>a</strong>  <strong>b</strong> = ab + ab + ab</p>
                <h3>Geometric Interpretation:</h3>
                <p>The dot product can also be expressed as:</p>
                <p style="text-align: center;"><strong>a</strong>  <strong>b</strong> = |<strong>a</strong>| |<strong>b</strong>| cos </p>
                <p>Where  is the angle between the vectors.</p>
                <h3>Properties of Dot Product:</h3>
                <ul>
                    <li>Commutative: <strong>a</strong>  <strong>b</strong> = <strong>b</strong>  <strong>a</strong></li>
                    <li>Distributive: <strong>a</strong>  (<strong>b</strong> + <strong>c</strong>) = <strong>a</strong>  <strong>b</strong> + <strong>a</strong>  <strong>c</strong></li>
                    <li>Scalar Multiple: (k<strong>a</strong>)  <strong>b</strong> = k(<strong>a</strong>  <strong>b</strong>)</li>
                </ul>
                <h3>Applications of Dot Product:</h3>
                <ol>
                    <li><strong>Work in Physics:</strong> Work = Force  Displacement</li>
                    <li><strong>Finding Angles:</strong> cos  = (<strong>a</strong>  <strong>b</strong>) / (|<strong>a</strong>| |<strong>b</strong>|)</li>
                    <li><strong>Vector Projections:</strong> proj<sub><strong>b</strong></sub><strong>a</strong> = ((<strong>a</strong>  <strong>b</strong>) / |<strong>b</strong>|) <strong>b</strong></li>
                    <li><strong>Testing Perpendicularity:</strong> If <strong>a</strong>  <strong>b</strong> = 0, then <strong>a</strong>  <strong>b</strong></li>
                </ol>
                <h3>Vector Projections:</h3>
                <p>The vector projection of <strong>a</strong> onto <strong>b</strong> is the vector component of <strong>a</strong> in the direction of <strong>b</strong>. It's calculated using the dot product:</p>
                <p style="text-align: center;">proj<sub><strong>b</strong></sub><strong>a</strong> = ((<strong>a</strong>  <strong>b</strong>) / |<strong>b</strong>|) <strong>b</strong></p>
                <p>Use the interactive visualization below to explore dot products and vector projections in 3D space.</p>
            `,sliders:[{id:"x1",label:"Vector a x-component",min:-5,max:5,step:.1,defaultValue:3,explanation:"Adjust the x-component of vector a"},{id:"y1",label:"Vector a y-component",min:-5,max:5,step:.1,defaultValue:2,explanation:"Adjust the y-component of vector a"},{id:"z1",label:"Vector a z-component",min:-5,max:5,step:.1,defaultValue:1,explanation:"Adjust the z-component of vector a"},{id:"x2",label:"Vector b x-component",min:-5,max:5,step:.1,defaultValue:1,explanation:"Adjust the x-component of vector b"},{id:"y2",label:"Vector b y-component",min:-5,max:5,step:.1,defaultValue:4,explanation:"Adjust the y-component of vector b"},{id:"z2",label:"Vector b z-component",min:-5,max:5,step:.1,defaultValue:-2,explanation:"Adjust the z-component of vector b"}],visualizations:[{type:"canvas",setup:x=>{const s=document.createElement("canvas"),n=s.getContext("2d");return{canvas:s,ctx:n}},update:x=>{const{canvas:s,ctx:n,x1:f=3,y1:d=2,z1:h=1,x2:u=1,y2:c=4,z2:r=-2}=x;if(n&&s){const p=s.parentElement;p&&(s.width=p.clientWidth,s.height=p.clientHeight);const F=s.width,b=s.height;n.clearRect(0,0,F,b),n.strokeStyle="#00ffff",n.fillStyle="#00ffff",n.lineWidth=2,n.font=`${Math.max(12,b/30)}px Arial`;const A=F/2,_=b/2,T=Math.min(F,b)/15,C=Math.PI/6,j=(U,B,X)=>({x:A+(U-X)*Math.cos(C)*T,y:_+(U+X)*Math.sin(C)*T-B*T}),O=j(0,0,0),k=j(6,0,0),ee=j(0,6,0),K=j(0,0,6);R(n,O.x,O.y,k.x,k.y),R(n,O.x,O.y,ee.x,ee.y),R(n,O.x,O.y,K.x,K.y),g(n,"x",k.x+10,k.y,Math.max(12,b/30)),g(n,"y",ee.x-20,ee.y-10,Math.max(12,b/30)),g(n,"z",K.x-20,K.y,Math.max(12,b/30));const W=j(f,d,h),G=j(u,c,r);He(n,O.x,O.y,W.x,W.y,"#FF0000"),He(n,O.x,O.y,G.x,G.y,"#00FF00"),g(n,"a",W.x+10,W.y-10,Math.max(12,b/30)),g(n,"b",G.x+10,G.y-10,Math.max(12,b/30));const me=f*u+d*c+h*r,ve=Math.sqrt(f*f+d*d+h*h),fe=Math.sqrt(u*u+c*c+r*r),ue=Math.acos(me/(ve*fe)),be=me/(fe*fe),Te=be*u,Fe=be*c,Me=be*r,I=j(Te,Fe,Me);n.strokeStyle="#FFFF00",n.setLineDash([5,5]),R(n,O.x,O.y,I.x,I.y),n.setLineDash([]),He(n,O.x,O.y,I.x,I.y,"#FFFF00"),g(n,"proj_b a",I.x+10,I.y-10,Math.max(12,b/30)),g(n,`a = (${f}, ${d}, ${h})`,10,30,Math.max(14,b/25)),g(n,`b = (${u}, ${c}, ${r})`,10,60,Math.max(14,b/25)),g(n,`a  b = ${me.toFixed(2)}`,10,90,Math.max(14,b/25)),g(n,`|a| = ${ve.toFixed(2)}, |b| = ${fe.toFixed(2)}`,10,120,Math.max(14,b/25)),g(n,`Angle between a and b: ${(ue*180/Math.PI).toFixed(2)}`,10,150,Math.max(14,b/25)),g(n,`proj_b a = (${Te.toFixed(2)}, ${Fe.toFixed(2)}, ${Me.toFixed(2)})`,10,180,Math.max(14,b/25))}}}]},{id:"10.5",title:"Cross Product",content:`
                <h2>Understanding and Calculating Cross Products</h2>
                <p>The cross product is a binary operation on two vectors in three-dimensional space that results in another vector perpendicular to both input vectors. It has numerous applications in physics, engineering, and computer graphics.</p>
                <h3>Cross Product Definition:</h3>
                <p>For two vectors <strong>a</strong> = (a, a, a) and <strong>b</strong> = (b, b, b), the cross product <strong>a</strong>  <strong>b</strong> is defined as:</p>
                <p style="text-align: center;"><strong>a</strong>  <strong>b</strong> = (ab - ab, ab - ab, ab - ab)</p>
                <h3>Geometric Interpretation:</h3>
                <p>The magnitude of the cross product is equal to the area of the parallelogram spanned by the two vectors:</p>
                <p style="text-align: center;">|<strong>a</strong>  <strong>b</strong>| = |<strong>a</strong>| |<strong>b</strong>| sin </p>
                <p>Where  is the angle between the vectors.</p>
                <h3>Properties of Cross Product:</h3>
                <ul>
                    <li>Anti-commutative: <strong>a</strong>  <strong>b</strong> = -(<strong>b</strong>  <strong>a</strong>)</li>
                    <li>Distributive: <strong>a</strong>  (<strong>b</strong> + <strong>c</strong>) = <strong>a</strong>  <strong>b</strong> + <strong>a</strong>  <strong>c</strong></li>
                    <li>Scalar Multiple: (k<strong>a</strong>)  <strong>b</strong> = k(<strong>a</strong>  <strong>b</strong>) = <strong>a</strong>  (k<strong>b</strong>)</li>
                    <li><strong>a</strong>  <strong>a</strong> = <strong>0</strong> (zero vector)</li>
                </ul>
                <h3>Applications of Cross Product:</h3>
                <ol>
                    <li><strong>Torque in Physics:</strong>  = r  F</li>
                    <li><strong>Angular Momentum:</strong> L = r  p</li>
                    <li><strong>Area Calculation:</strong> Area of parallelogram = |<strong>a</strong>  <strong>b</strong>|</li>
                    <li><strong>Normal Vectors:</strong> Finding a vector perpendicular to a plane</li>
                    <li><strong>Computer Graphics:</strong> Determining the outward normal of a surface</li>
                </ol>
                <h3>Right-Hand Rule:</h3>
                <p>The direction of the cross product follows the right-hand rule: if you curl the fingers of your right hand from the first vector towards the second vector, your thumb points in the direction of the cross product.</p>
                <p>Use the interactive visualization below to explore cross products in 3D space.</p>
            `,sliders:[{id:"x1",label:"Vector a x-component",min:-5,max:5,step:.1,defaultValue:3,explanation:"Adjust the x-component of vector a"},{id:"y1",label:"Vector a y-component",min:-5,max:5,step:.1,defaultValue:2,explanation:"Adjust the y-component of vector a"},{id:"z1",label:"Vector a z-component",min:-5,max:5,step:.1,defaultValue:1,explanation:"Adjust the z-component of vector a"},{id:"x2",label:"Vector b x-component",min:-5,max:5,step:.1,defaultValue:1,explanation:"Adjust the x-component of vector b"},{id:"y2",label:"Vector b y-component",min:-5,max:5,step:.1,defaultValue:4,explanation:"Adjust the y-component of vector b"},{id:"z2",label:"Vector b z-component",min:-5,max:5,step:.1,defaultValue:-2,explanation:"Adjust the z-component of vector b"}],visualizations:[{type:"canvas",setup:x=>{const s=document.createElement("canvas"),n=s.getContext("2d");return{canvas:s,ctx:n}},update:x=>{const{canvas:s,ctx:n,x1:f=3,y1:d=2,z1:h=1,x2:u=1,y2:c=4,z2:r=-2}=x;if(n&&s){const p=s.parentElement;p&&(s.width=p.clientWidth,s.height=p.clientHeight);const F=s.width,b=s.height;n.clearRect(0,0,F,b),n.strokeStyle="#00ffff",n.fillStyle="#00ffff",n.lineWidth=2,n.font=`${Math.max(12,b/30)}px Arial`;const A=F/2,_=b/2,T=Math.min(F,b)/15,C=Math.PI/6,j=(U,B,X)=>({x:A+(U-X)*Math.cos(C)*T,y:_+(U+X)*Math.sin(C)*T-B*T}),O=j(0,0,0),k=j(6,0,0),ee=j(0,6,0),K=j(0,0,6);R(n,O.x,O.y,k.x,k.y),R(n,O.x,O.y,ee.x,ee.y),R(n,O.x,O.y,K.x,K.y),g(n,"x",k.x+10,k.y,Math.max(12,b/30)),g(n,"y",ee.x-20,ee.y-10,Math.max(12,b/30)),g(n,"z",K.x-20,K.y,Math.max(12,b/30));const W=j(f,d,h),G=j(u,c,r);He(n,O.x,O.y,W.x,W.y,"#FF0000"),He(n,O.x,O.y,G.x,G.y,"#00FF00"),g(n,"a",W.x+10,W.y-10,Math.max(12,b/30)),g(n,"b",G.x+10,G.y-10,Math.max(12,b/30));const me=d*r-h*c,ve=h*u-f*r,fe=f*c-d*u,ue=j(me,ve,fe);He(n,O.x,O.y,ue.x,ue.y,"#FFFF00"),g(n,"a  b",ue.x+10,ue.y-10,Math.max(12,b/30));const be=Math.sqrt(f*f+d*d+h*h),Te=Math.sqrt(u*u+c*c+r*r),Fe=Math.sqrt(me*me+ve*ve+fe*fe),Me=f*u+d*c+h*r,I=Math.acos(Me/(be*Te));g(n,`a = (${f}, ${d}, ${h})`,10,30,Math.max(14,b/25)),g(n,`b = (${u}, ${c}, ${r})`,10,60,Math.max(14,b/25)),g(n,`a  b = (${me.toFixed(2)}, ${ve.toFixed(2)}, ${fe.toFixed(2)})`,10,90,Math.max(14,b/25)),g(n,`|a  b| = ${Fe.toFixed(2)}`,10,120,Math.max(14,b/25)),g(n,`|a| = ${be.toFixed(2)}, |b| = ${Te.toFixed(2)}`,10,150,Math.max(14,b/25)),g(n,`Angle between a and b: ${(I*180/Math.PI).toFixed(2)}`,10,180,Math.max(14,b/25)),g(n,`Area of parallelogram: ${Fe.toFixed(2)}`,10,210,Math.max(14,b/25))}}}]},{id:"10.6",title:"Applications in Physics and Engineering",content:`
                <h2>Using 3D Trigonometry and Vectors in Real-World Problems</h2>
                <p>3D trigonometry and vector operations are fundamental in solving various real-world problems in physics and engineering. Let's explore some key applications:</p>
                <h3>1. Force Analysis in Mechanics</h3>
                <ul>
                    <li><strong>Free Body Diagrams:</strong> Representing forces acting on an object in 3D space.</li>
                    <li><strong>Resultant Force:</strong> Using vector addition to find the net force on an object.</li>
                    <li><strong>Equilibrium:</strong> Solving for forces that balance each other in 3D structures.</li>
                </ul>
                <h3>2. Motion in 3D Space</h3>
                <ul>
                    <li><strong>Projectile Motion:</strong> Analyzing the path of objects launched in 3D.</li>
                    <li><strong>Orbital Mechanics:</strong> Describing the motion of satellites and celestial bodies.</li>
                    <li><strong>Robotic Arm Movement:</strong> Calculating joint angles for desired end-effector positions.</li>
                </ul>
                <h3>3. Electromagnetic Fields</h3>
                <ul>
                    <li><strong>Field Vectors:</strong> Representing electric and magnetic fields in 3D space.</li>
                    <li><strong>Lorentz Force:</strong> Calculating the force on charged particles in electromagnetic fields.</li>
                    <li><strong>Antenna Design:</strong> Optimizing radiation patterns using 3D vector analysis.</li>
                </ul>
                <h3>4. Fluid Dynamics</h3>
                <ul>
                    <li><strong>Flow Fields:</strong> Describing fluid velocity and pressure in 3D space.</li>
                    <li><strong>Lift and Drag:</strong> Analyzing forces on aircraft wings or underwater structures.</li>
                    <li><strong>Turbulence Modeling:</strong> Using vector calculus to model complex fluid behaviors.</li>
                </ul>
                <h3>5. Computer Graphics and Animation</h3>
                <ul>
                    <li><strong>3D Transformations:</strong> Rotating, scaling, and translating objects in virtual 3D space.</li>
                    <li><strong>Lighting and Shading:</strong> Calculating light reflection and surface normals.</li>
                    <li><strong>Camera Positioning:</strong> Determining view angles and perspectives in 3D scenes.</li>
                </ul>
                <h3>6. Structural Engineering</h3>
                <ul>
                    <li><strong>Truss Analysis:</strong> Calculating forces in 3D structural members.</li>
                    <li><strong>Stress and Strain Tensors:</strong> Analyzing material deformation in 3D.</li>
                    <li><strong>Earthquake Engineering:</strong> Modeling 3D ground motion and structural responses.</li>
                </ul>
                <p>Let's explore a practical example: analyzing the forces on a suspended bridge cable.</p>
            `,sliders:[{id:"cableLength",label:"Cable Length (m)",min:10,max:100,step:1,defaultValue:50,explanation:"Adjust the length of the bridge cable"},{id:"cableAngle",label:"Cable Angle (degrees)",min:0,max:90,step:1,defaultValue:30,explanation:"Adjust the angle of the cable with respect to the horizontal"},{id:"loadWeight",label:"Load Weight (kN)",min:0,max:1e3,step:10,defaultValue:500,explanation:"Adjust the weight of the load on the cable"}],visualizations:[{type:"canvas",setup:x=>{const s=document.createElement("canvas"),n=s.getContext("2d");return{canvas:s,ctx:n}},update:x=>{const{canvas:s,ctx:n,cableLength:f=50,cableAngle:d=30,loadWeight:h=500}=x;if(n&&s){const u=s.parentElement;u&&(s.width=u.clientWidth,s.height=u.clientHeight);const c=s.width,r=s.height;n.clearRect(0,0,c,r),n.strokeStyle="#00ffff",n.fillStyle="#00ffff",n.lineWidth=2,n.font=`${Math.max(12,r/30)}px Arial`;const p=Math.min(c,r)/150,F=r-50,b=c/4,A=F-f*Math.sin(d*Math.PI/180)*p,_=b+f*Math.cos(d*Math.PI/180)*p,T=F;n.beginPath(),n.moveTo(0,F),n.lineTo(c,F),n.stroke(),n.strokeStyle="#FFFF00",R(n,b,A,_,T),n.strokeStyle="#00ffff";const C=(b+_)/2,j=(A+T)/2;le(n,C,j,5),He(n,C,j,C,j+50,"#FF0000");const O=d*Math.PI/180,k=h/(2*Math.sin(O)),ee=k*Math.cos(O),K=k*Math.sin(O),W=.1;He(n,b,A,b-ee*W,A,"#00FF00"),He(n,b,A,b,A+K*W,"#0000FF"),g(n,"Cable",(b+_)/2+10,(A+T)/2-10,Math.max(12,r/30)),g(n,"Load",C+10,j+30,Math.max(12,r/30)),g(n,"Tension",b-60,A-10,Math.max(12,r/30)),g(n,"Horizontal",b-ee*W-40,A+20,Math.max(12,r/30)),g(n,"Vertical",b-70,A+K*W/2,Math.max(12,r/30)),g(n,`Cable Length: ${f} m`,10,30,Math.max(14,r/25)),g(n,`Cable Angle: ${d}`,10,60,Math.max(14,r/25)),g(n,`Load Weight: ${h} kN`,10,90,Math.max(14,r/25)),g(n,`Tension: ${k.toFixed(2)} kN`,10,120,Math.max(14,r/25)),g(n,`Horizontal Force: ${ee.toFixed(2)} kN`,10,150,Math.max(14,r/25)),g(n,`Vertical Force: ${K.toFixed(2)} kN`,10,180,Math.max(14,r/25))}}}]}]},$={id:11,title:"Parametric Equations and Curves",introduction:`
        <p>Welcome to our lesson on Parametric Equations and Curves! In this lesson, we'll explore a powerful way to describe curves and motions in mathematics and physics.</p>
        <p>Parametric equations allow us to express the coordinates of a point on a curve as functions of a parameter, typically denoted as t. This approach provides a dynamic way to represent curves and is particularly useful in describing motion and complex shapes.</p>
    `,prerequisites:[2,3,5,9],sublessons:[{id:"11.1",title:"Introduction to Parametric Equations",content:`
                <h2>Understanding the Concept of Parameter</h2>
                <p>Parametric equations describe a set of quantities as functions of one or more independent variables called parameters. In the context of curves, we often use a single parameter, usually denoted as t.</p>
                <h3>Key Concepts:</h3>
                <ul>
                    <li><strong>Parameter:</strong> An independent variable that determines the values of other variables.</li>
                    <li><strong>Parametric Form:</strong> A way to express the coordinates of a point on a curve as functions of a parameter.</li>
                    <li><strong>General Form:</strong> For a curve in 2D space: x = f(t), y = g(t), where t is the parameter.</li>
                </ul>
                <h3>Advantages of Parametric Equations:</h3>
                <ol>
                    <li><strong>Describing Motion:</strong> Easily represent position as a function of time.</li>
                    <li><strong>Complex Shapes:</strong> Represent curves that are not functions in Cartesian coordinates.</li>
                    <li><strong>Multiple Traversals:</strong> Describe curves that cross over themselves.</li>
                    <li><strong>Direction:</strong> Indicate the direction of motion along a curve.</li>
                </ol>
                <h3>Example: Circle as Parametric Equations</h3>
                <p>A circle with radius r centered at the origin can be described parametrically as:</p>
                <p>x = r cos(t), y = r sin(t), where 0  t < 2</p>
                <p>Here, t represents the angle from the positive x-axis.</p>
                <p>Use the slider below to explore how the parameter t determines a point's position on a circle.</p>
            `,sliders:[{id:"parameter",label:"Parameter t",min:0,max:2*Math.PI,step:.1,defaultValue:0,explanation:"Adjust the parameter t to move the point along the circle"}],visualizations:[{type:"canvas",setup:x=>{const s=document.createElement("canvas"),n=s.getContext("2d");return{canvas:s,ctx:n}},update:x=>{const{canvas:s,ctx:n,parameter:f=0}=x;if(n&&s){const d=s.parentElement;d&&(s.width=d.clientWidth,s.height=d.clientHeight);const h=s.width,u=s.height;n.clearRect(0,0,h,u),n.strokeStyle="#00ffff",n.fillStyle="#00ffff",n.lineWidth=2,n.font=`${Math.max(12,u/30)}px Arial`;const c=h/2,r=u/2,p=Math.min(h,u)*.4;R(n,0,r,h,r),R(n,c,0,c,u),g(n,"x",h-20,r+20,Math.max(12,u/30)),g(n,"y",c+10,20,Math.max(12,u/30)),n.beginPath(),n.arc(c,r,p,0,2*Math.PI),n.stroke();const F=c+p*Math.cos(f),b=r-p*Math.sin(f);le(n,F,b,5),n.setLineDash([5,5]),R(n,c,r,F,b),n.setLineDash([]),g(n,`t = ${f.toFixed(2)}`,10,30,Math.max(14,u/25)),g(n,`x = ${((F-c)/p).toFixed(2)}`,10,60,Math.max(14,u/25)),g(n,`y = ${((r-b)/p).toFixed(2)}`,10,90,Math.max(14,u/25)),g(n,"x = cos(t)",h-150,30,Math.max(14,u/25)),g(n,"y = sin(t)",h-150,60,Math.max(14,u/25))}}}]},{id:"11.2",title:"Parametric Forms of Lines and Circles",content:`
                <h2>Converting Standard Equations to Parametric Form</h2>
                <p>Many geometric shapes that we're familiar with in standard form can be expressed parametrically. Let's look at how to convert lines and circles to parametric form.</p>
                <h3>Lines in Parametric Form:</h3>
                <p>For a line with slope m and y-intercept b (y = mx + b), we can use the parametric form:</p>
                <ul>
                    <li>x = t</li>
                    <li>y = mt + b</li>
                </ul>
                <p>Where t is any real number. This form allows us to generate any point on the line by choosing a value for t.</p>
                <h3>Circles in Parametric Form:</h3>
                <p>For a circle with center (h, k) and radius r, we can use the parametric form:</p>
                <ul>
                    <li>x = h + r cos(t)</li>
                    <li>y = k + r sin(t)</li>
                </ul>
                <p>Where 0  t < 2. This form generates points on the circle as t varies from 0 to 2.</p>
                <h3>Advantages of Parametric Form:</h3>
                <ul>
                    <li>Easier to represent motion along the curve</li>
                    <li>Can represent curves that are not functions in Cartesian coordinates</li>
                    <li>Simplifies certain calculations in physics and engineering</li>
                </ul>
                <p>Use the sliders below to explore parametric forms of lines and circles.</p>
            `,sliders:[{id:"shapeType",label:"Shape Type",min:0,max:1,step:1,defaultValue:0,explanation:"Toggle between line (0) and circle (1)"},{id:"parameter",label:"Parameter t",min:-5,max:5,step:.1,defaultValue:0,explanation:"Adjust the parameter t to move along the shape"},{id:"slope",label:"Slope (for line)",min:-2,max:2,step:.1,defaultValue:1,explanation:"Adjust the slope of the line"}],visualizations:[{type:"canvas",setup:x=>{const s=document.createElement("canvas"),n=s.getContext("2d");return{canvas:s,ctx:n}},update:x=>{const{canvas:s,ctx:n,shapeType:f=0,parameter:d=0,slope:h=1}=x;if(n&&s){const u=s.parentElement;u&&(s.width=u.clientWidth,s.height=u.clientHeight);const c=s.width,r=s.height;n.clearRect(0,0,c,r),n.strokeStyle="#00ffff",n.fillStyle="#00ffff",n.lineWidth=2,n.font=`${Math.max(12,r/30)}px Arial`;const p=c/2,F=r/2,b=Math.min(c,r)/12;R(n,0,F,c,F),R(n,p,0,p,r),g(n,"x",c-20,F+20,Math.max(12,r/30)),g(n,"y",p+10,20,Math.max(12,r/30));let A,_;if(f===0){const T=F-h*5*b,C=F+h*5*b;R(n,0,T,c,C),A=p+d*b,_=F-h*d*b,g(n,`Line: x = t, y = ${h}t`,10,30,Math.max(14,r/25))}else{const T=3*b;n.beginPath(),n.arc(p,F,T,0,2*Math.PI),n.stroke(),A=p+T*Math.cos(d),_=F-T*Math.sin(d),g(n,"Circle: x = 3cos(t), y = 3sin(t)",10,30,Math.max(14,r/25))}le(n,A,_,5),g(n,`t = ${d.toFixed(2)}`,10,60,Math.max(14,r/25)),g(n,`x = ${((A-p)/b).toFixed(2)}`,10,90,Math.max(14,r/25)),g(n,`y = ${((F-_)/b).toFixed(2)}`,10,120,Math.max(14,r/25))}}}]}]};e.addLesson(t),e.addLesson(i),e.addLesson(o),e.addLesson(a),e.addLesson(l),e.addLesson(m),e.addLesson(v),e.addLesson(y),e.addLesson(y),e.addLesson(M),e.addLesson(S),e.addLesson($)}const as=tc(yu),qu=oc();as.use(qu);as.use(Ou);zu();as.mount("#app");export{os as _,Ce as a,Ue as c,je as o};
